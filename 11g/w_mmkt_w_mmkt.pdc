rem Differences between W_MMKT@PROG and W_MMKT@MAIN, created on 26.11.2009
rem Press Apply button, or run in Command Window or SQL*Plus connected as W_MMKT@MAIN

---------------------------------
--  New table mv_persogl_tv_t  --
---------------------------------
-- Create table
create table W_MMKT.MV_PERSOGL_TV_T
(
  DT_IZMSTEXIST DATE,
  RN_PERSOGL    NUMBER,
  RN_TYPEDOC    NUMBER,
  RN_TV         NUMBER,
  RN_ISPOB      NUMBER,
  ATT_VAR       NUMBER
)
tablespace TS_NOTLOG
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
-- Create/Recreate indexes 
create index W_MMKT.I_MV_PERSOGL_T_ISP on W_MMKT.MV_PERSOGL_TV_T (RN_ISPOB)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index W_MMKT.I_MV_PERSOGL_T_RNPS on W_MMKT.MV_PERSOGL_TV_T (RN_PERSOGL)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index W_MMKT.I_MV_PERSOGL_T_RNTV on W_MMKT.MV_PERSOGL_TV_T (RN_TV)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

-----------------------------
--  Changed table mv_test  --
-----------------------------
-- Add comments to the table 
comment on table W_MMKT.MV_TEST
  is 'snapshot table for snapshot W_MMKT.MV_TEST';
------------------------------------
--  Changed table mv_tv_find_inf  --
------------------------------------
-- Add comments to the table 
comment on table W_MMKT.MV_TV_FIND_INF
  is 'snapshot table for snapshot W_MMKT.MV_TV_FIND_INF';
-- Create/Recreate indexes 
create unique index W_MMKT.I_MV_TV_FIND_INF_RN on W_MMKT.MV_TV_FIND_INF (RN)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
-------------------------------
--  Changed table mv_tv_inf  --
-------------------------------
-- Add comments to the table 
comment on table W_MMKT.MV_TV_INF
  is 'snapshot table for snapshot W_MMKT.MV_TV_INF';
---------------------------
--  Changed table tb_cp  --
---------------------------
-- Add/modify columns 
alter table W_MMKT.TB_CP modify KOL NUMBER(13,3);
-- Create/Recreate indexes 
create index W_MMKT.I_CP_CH on W_MMKT.TB_CP (KDCE_CH)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index W_MMKT.I_CP_K on W_MMKT.TB_CP (KDCE_K)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
---------------------------
--  Changed table tb_mn  --
---------------------------
-- Create/Recreate indexes 
create index W_MMKT.I_MN_KDCE on W_MMKT.TB_MN (KDCE)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index W_MMKT.I_MN_NN on W_MMKT.TB_MN (NN)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
---------------------------
--  Changed table tb_mo  --
---------------------------
-- Create/Recreate indexes 
create bitmap index W_MMKT.I_MO_CEX on W_MMKT.TB_MO (CEX)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
create index W_MMKT.I_MO_KDCE on W_MMKT.TB_MO (KDCE)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );
-----------------------------
--  New table tb_tmp_delt  --
-----------------------------
-- Create table
create table W_MMKT.TB_TMP_DELT
(
  RNISP_K NUMBER,
  RNTV_K  NUMBER,
  RNISP_C NUMBER,
  RNTV_C  NUMBER,
  UROV    NUMBER(2)
)
tablespace MATERIAL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

-------------------------------
--  New table tb_tmp_izm_mo  --
-------------------------------
-- Create table
create table W_MMKT.TB_TMP_IZM_MO
(
  DCE       VARCHAR2(255),
  RN_ISP_OB NUMBER,
  VI        VARCHAR2(30),
  RN_TV     NUMBER,
  MO_B      VARCHAR2(2000),
  MO_S      VARCHAR2(2000),
  NOM_PS    VARCHAR2(30)
)
tablespace MATERIAL
  pctfree 10
  initrans 1
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  );

----------------------------------
--  Changed view mv_persogl_tv  --
----------------------------------
create or replace view w_mmkt.mv_persogl_tv as
select "DT_IZMSTEXIST","RN_PERSOGL","RN_TYPEDOC","RN_TV","RN_ISPOB","ATT_VAR"
    from mv_persogl_tv_t;
------------------------------
--  Changed view v0_tv_inf  --
------------------------------
CREATE OR REPLACE VIEW W_MMKT.V0_TV_INF AS
SELECT 
/* 29.09.06 Бельтюков Н.В.
   Утвержденная информация об тех. вариантах с дополнительной информацией
*/
  io0.OBOZN,
  io0.TIP_ISPOB,
  io0.PACK_OBOZN, 
  tv.*,
  tv0.DOLY,
  tv0.TVNAIM,
  tv0.TVMASSA,
  tv0.TVNOTE
FROM 
  W_KTSG.TB_TV tv,
  W_KTSG.V0_TV_S tv0,
  W_KTSG.V0_ISP_OB_S io0
WHERE
  tv.rn = tv0.RN_TV AND
  tv.rn_ispob = io0.RN_ISPOB;
------------------------------
--  Changed view v1_tv_inf  --
------------------------------
CREATE OR REPLACE VIEW W_MMKT.V1_TV_INF AS
SELECT 
/* 29.09.06 Бельтюков Н.В.
   Неутвержденная информация об тех. вариантах с дополнительной информацией
*/
  io1.OBOZN,
  io1.TIP_ISPOB,
  io1.PACK_OBOZN, 
  tv.*,
  tv1.DOLY,
  tv1.TVNAIM,
  tv1.TVMASSA,
  tv1.TVNOTE
FROM 
  W_KTSG.TB_TV tv,
  W_KTSG.V1_TV_S tv1,
  W_KTSG.V1_ISP_OB_S io1
WHERE
  tv.rn = tv1.RN_TV AND
  tv.rn_ispob = io1.RN_ISPOB;
---------------------
--  New view v_cp  --
---------------------
create or replace view w_mmkt.v_cp as
select "KDCE_CH","KDCE_K","KOL","CEXSB"
    from tb_cp;

---------------------------
--  Changed view v_podr  --
---------------------------
CREATE OR REPLACE VIEW W_MMKT.V_PODR AS
SELECT 
/* 17.02.05 Бельтюков Н.В.
   Подразделения с наименованиями
   Удалены "левые" записи
*/  
  P.*,
  pn.naim
FROM  
  w_mp.tb_podr p,
  w_mp.tb_podr_naim pn
WHERE 
  p.rn = pn.rn (+) AND
  p.ukazpr = 0;
-----------------------------------
--  Changed view v_doly_vig_inf  --
-----------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_DOLY_VIG_INF AS
SELECT --+star
/* 21.03.05 Бельтюков Н.В.
   Информация о долях выгод с информацией о подразделении
*/
  dv.*,
  p.kornaim AS PODR
FROM
  W_KTSG.V_DOLY_VIG  dv,
  V_PODR p
WHERE
  dv.rn_podr = p.rn;
-------------------------
--  Changed view v_ei  --
-------------------------
CREATE OR REPLACE VIEW W_MMKT.V_EI AS
SELECT
/* 17.02.05 Бельтюков Н.В.
   Единицы измерения с наименованиями
   Удалены "левые" записи
*/
  ei.*,
  ein.naim
FROM
  w_ei.tb_ei ei,
  w_ei.tb_ei_naim ein
WHERE
  ei.rn = ein.rn (+) AND
  ei.ukazpr = 0;
----------------------------------
--  Changed view v_ei_for_comp  --
----------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_EI_FOR_COMP AS
SELECT
/* 11.04.06 Бельтюков Н.В.
   Единицы измерения, которые могут исрользоваться в компонентах
*/
  e.*
FROM
  W_EI.V_EI0 e,
  TB_EI_FOR_USTCOMP ec
WHERE
  e.rn = ec.rn;
---------------------------------
--  Changed type rec_tb_izmtv  --
---------------------------------
CREATE OR REPLACE TYPE W_MMKT.rec_tb_izmtv AS OBJECT(
      nomizm                   VARCHAR2(30),
      rn                                      NUMBER,
      DT_IZMSTEXIST                   DATE,
      kolstate                               CHAR(1),
      att_arstart                            DATE
   );
/
-----------------------------
--  Changed type tb_izmtv  --
-----------------------------
CREATE OR REPLACE TYPE W_MMKT.tb_izmtv AS TABLE OF rec_tb_izmtv;
/
-----------------------------------
--  Changed package pk_mmk_info  --
-----------------------------------
CREATE OR REPLACE PACKAGE W_MMKT.PK_MMK_INFO IS

   -- Author  : BRULEV
   -- Created : 29.06.2006 11:13:50
   -- Purpose :

   -- Public type declarations

   TYPE curtyp IS REF CURSOR;

   -- Public function and procedure declarations
   FUNCTION F_GET_IZMTV (p_rntv IN NUMBER, p_date IN DATE DEFAULT NULL) RETURN tb_izmtv PIPELINED ;
   --
   PROCEDURE P_FIND(P_OBOZN  IN VARCHAR2,
                    P_CONT   IN VARCHAR2,
                    P_KOL    IN INTEGER,
                    P_CURSEL OUT curtyp);

   -- Агафонова Н.С.(11.07.2006)
   FUNCTION F_MO(P_RN IN INTEGER) RETURN VARCHAR2;
   /*PROCEDURE P_FIND_1(P_OBOZN  IN VARCHAR2,
   P_CONT   IN VARCHAR2,
   P_KOL    IN INTEGER,
   P_CURSEL OUT curtyp);  */
   PROCEDURE P_FIND_1(P_OBOZN  IN VARCHAR2,
                      P_CONT   IN VARCHAR2,
                      P_KOL    IN INTEGER,
                      P_PACKED IN VARCHAR2,
                      P_CURSEL OUT curtyp);
   FUNCTION F_TRUD(P_RN IN NUMBER,
            p_dst IN INTEGER DEFAULT 0/*0-только вед, 1-тетрадные, -1 - определение*/,
            p_date IN DATE DEFAULT w_ktsg.pk_values.curdate) RETURN VARCHAR2;
    --*************************************************************
PROCEDURE    p_tv_info(p_rntv IN NUMBER,
                                       p_date IN DATE,
                                             p_tv OUT curtyp);
--*************************************************************
PROCEDURE    p_izd_cexs(p_rntv IN NUMBER,
                                      p_date IN DATE,
                                      p_cur OUT curtyp);
--*************************************************************
PROCEDURE    p_izd_dce_by_cex(p_rntv IN NUMBER,
                        p_cex IN VARCHAR2,
                        p_date IN DATE,
                        p_cur OUT curtyp);
--*************************************************************
PROCEDURE    p_zag(p_rntv IN NUMBER,
                                             p_rzr IN NUMBER DEFAULT 0,
                                             p_zag OUT curtyp
);
--*************************************************************
PROCEDURE    p_all(p_rntv IN NUMBER,
                                    p_date IN DATE,
                                             p_tv OUT curtyp,
                                             p_mo OUT curtyp,
                                             p_zag OUT curtyp,
                                             p_obr OUT curtyp,
                                             p_sost OUT curtyp,
                                             p_vhod OUT curtyp,
                                             p_izmtv OUT curtyp,
                                       p_oinfo OUT curtyp);
--**************************************************************
PROCEDURE    p_info_mo(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_mo OUT curtyp
                         );
--**************************************************************
PROCEDURE    p_info_zag(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_zag OUT curtyp
                         );
--**************************************************************
PROCEDURE    p_info_izm(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_izm OUT curtyp
                         );                         
--**************************************************************
PROCEDURE    p_act_td(p_arid IN NUMBER,
                                       p_DATE IN DATE,
                                       p_td out curtyp);
--**************************************************************
PROCEDURE    p_findizm(p_nomizm IN varchar2,
                                       p_typ IN INTEGER DEFAULT -1, --Тип извещения
                                       p_status IN VARCHAR2 DEFAULT 'РСУН', --Извещения с какими статусами искать - по умолчанию все
                                       p_aut IN VARCHAR2 DEFAULT NULL, -- Автор извещений - по умолчанию все
                                       p_ncompl IN INTEGER DEFAULT 0, -- Необработанные
                                       p_psh out curtyp);
--**************************************************************
PROCEDURE    p_getpsh(p_rnps in number,
                      p_psh out curtyp);
--**************************************************************
--Данные изменения
PROCEDURE    p_izmdata(p_rntv IN NUMBER,
                                       p_rnps IN NUMBER,
                                       p_psh out curtyp,
                                       p_tv out curtyp,
                                       p_mo OUT curtyp,
                                       p_zag OUT curtyp,
                                       p_obr OUT curtyp,
                                       p_sost OUT curtyp,
                                       p_vhod OUT curtyp,
                                       p_isp OUT curtyp,
                                       p_td OUT curtyp);

--**************************************************************
PROCEDURE    p_izmdce(p_rnps IN number,
                                       p_dce out curtyp);
--**************************************************************
PROCEDURE    p_td(p_arid IN NUMBER,
                                       p_DATE IN VARCHAR2,
                                       p_old IN VARCHAR2 DEFAULT NULL,
                                       p_td out curtyp);
--**************************************************************
PROCEDURE    p_matizm(p_rnmat IN NUMBER,
                                       p_psh out curtyp)    ;
--**************************************************************
PROCEDURE    p_matizmdce(p_rnps IN number,
                                                    p_rnmat IN NUMBER,
                                                    p_dce out curtyp);
PROCEDURE p_rel_cursor (p_cur IN curtyp);

   TYPE T_Find_tv IS RECORD( --Иванова Вера 14.02.2007
      Rn       NUMBER,
      Obozn    VARCHAR2(300),
      vi       VARCHAR2(2),
      TvNaim   VARCHAR2(300),
      m        VARCHAR2(300),
      Nom_num  VARCHAR2(200),
      z        VARCHAR2(300),
      doly     VARCHAR2(50),
      geomr_dl NUMBER,
      geomr_sh NUMBER,
      ind_komp NUMBER);
   TYPE tb_find IS TABLE OF t_find_tv INDEX BY BINARY_INTEGER;
   TYPE T_Find_tv_klon IS RECORD( --Иванова Вера 14.02.2007
      Rn       NUMBER,
      Obozn    VARCHAR2(300),
      vi       VARCHAR2(2),
      TvNaim   VARCHAR2(300),
      m        VARCHAR2(300),
      tr       VARCHAR2(300),
      Nom_num  VARCHAR2(200),
      z        VARCHAR2(300),
      doly     VARCHAR2(50),
      geomr_dl NUMBER,
      geomr_sh NUMBER,
      ind_komp NUMBER,
      rn_ispob NUMBER,
      kol      NUMBER,
      ap       NUMBER,
      ez       VARCHAR2(10));
   TYPE tb_find_klon IS TABLE OF t_find_tv_klon INDEX BY BINARY_INTEGER;
   TYPE rec_tb_temp IS RECORD(
      kdce_ch NUMBER,
      tv_ch   NUMBER,
      ez      NUMBER,
      kol     NUMBER,
      ap      NUMBER);
   TYPE tb_temp IS TABLE OF rec_tb_temp INDEX BY BINARY_INTEGER;

END PK_MMK_INFO;
/
-------------------------------
--  Changed view v_find_tv1  --
-------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_FIND_TV1 AS
SELECT   tv.*,   nvl(w_mmkt.pk_mmk_info.F_trud(tv.rn),' ') as  tr,                 w_mmkt.pk_mmk_info.F_MO(tv.rn) as  m   FROM  w_ktsg.tb_tv tv;
-----------------------------
--  Changed type t_izm_mo  --
-----------------------------
create or replace type w_mmkt.T_IZM_MO as object
(--Изместьев А.А. 4.09.2007
MO_TV_RN             number,                --РН ТВ объекта
MO_RN                   number,                --РН МО
MO_PORNOM         number,                 --Пор Ном МО
MO_IND_MPR         char(1),                   --Индикатор местаприменения "1" ДА
MO_ATT_ARID         number,
--MO_RN_POZMO      number,
MO_RNPODR          number,
MO_TXTPODR         varchar2(30),
MO_RNVO               number,
MO_TXTVO              varchar2(30),
MO_NOTE               varchar2(2000),
MO_TD                     varchar2(2000),        --Примечание по техдобавке
--F_GET_TEHNDOB_STRING
MO_IS_CH              Number --1 - если поменялось состояние 0  - нет
)
/
--------------------------------
--  Changed type t_tb_izm_mo  --
--------------------------------
create or replace type w_mmkt.T_TB_IZM_MO is Table of T_IZM_MO
--Изместьев А.А. 4.09.07
/
------------------------------
--  Changed type t_izm_obr  --
------------------------------
create or replace type w_mmkt.T_IZM_OBR as object
(--Изместьев А.А. 4.09.2007
OBR_TYP                   number, --Тип изменения (1- анулирование, 2 - введение, 3 - изменение)
OBR_SOSTIZM number, -- состояние изменения 0-Было 1-Стало
OBR_RN_POZ_MOS     number, --РН  ПОЗMOS установки  
OBR_OBOZN_Z            varchar2(255), --Обозначение  Защищаемого объекта
   
OBR_RNTV_IZG                 number,  --РН ТВ совместно изготавливаетмого
OBR_RNTV_OBR          number, --РНТВ образца
OBR_OBOZN_OBR varchar2(255), --Обозначение  образца

OBR_OBOZN_IZG varchar2(255), --Обозначение  совместноизгот ДСЕ

OBR_NAME_IZG varchar2(255),
OBR_NAME_OBR varchar2(255),
OBR_NAME_ZACH varchar2(255),
--Обозначение совместно изготавляемого объекта!!!!
--Наименование Образца
--Наименование Защищ объекта
--Наименование Совместно Изгот Объекта

OBR_RNPODR_ISP number, --Цех испытатель
RN_PODR_INITTD number, --Цех инициатор
OBR_TEHN_KOL              number, --Кол-во было технологическое
OBR_MAX_PART number, --МАксимальная партия
OBR_NOTE            varchar2(2000), --Примечания


OBR_MO_Z                varchar2(7), --Цех защиты текстовый + Вид обработки 
OBR_MO_IN                varchar2(3), --Цех инициатор защиты
OBR_MO_IS         varchar2(3) --Цех испытатель


)
/
---------------------------------
--  Changed type t_tb_izm_obr  --
---------------------------------
create or replace type w_mmkt.T_TB_IZM_OBR is Table of T_IZM_OBR
--Изместьев А.А. 4.09.07
/
-------------------------------
--  Changed type t_izms_isp  --
-------------------------------
create or replace type w_mmkt.T_IZMS_ISP as object
(
rn_ispob Number,
t_cordate date, 
t_start  date, 
t_end date, 
att_alt    Number, 
att_alttype Number, 
att_auth    Number, 
att_authtype Number, 
att_arid_B    Number, 
att_arid_S     Number, 
obozn_B   Varchar2(255), 
obozn_S   Varchar2(255),
tip_ispob_B Char(1), 
tip_ispob_S   Char(1),
pack_obozn_B   Varchar2(255),  
pack_obozn_S   Varchar2(255)
 
)
/
----------------------------------
--  Changed type t_tb_izms_isp  --
----------------------------------
create or replace type w_mmkt.T_TB_IZMS_ISP as TABLE OF T_IZMS_ISP;
/
--------------------------------
--  Changed type t_izms_izms  --
--------------------------------
create or replace type w_mmkt.T_IZMS_IZMS as object
(
att_auth NUMBER 
)
/
-----------------------------------
--  Changed type t_tb_izms_izms  --
-----------------------------------
create or replace type w_mmkt.T_TB_IZMS_IZMS as TABLE OF T_IZMS_IZMS;
/
------------------------------
--  Changed type t_izms_mo  --
------------------------------
create or replace type w_mmkt.T_IZMS_MO as object
(-- v15.01.2008
RN_POZMO              Number,               --РН ТехВар 
RN_TV                 Number,               --РН ТехВар 
att_AUTH              NUMBER,           -- Ид документа основания
att_AUTHTYPE          NUMBER,           -- Тип документа основания
att_ALT               NUMBER,           -- GUID пользователя породившего состояние
att_ALTTYPE           NUMBER,          -- Тип пользователя
pornom                NUMBER,    -- номер позиции
dizm                  DATE,                -- Дата корректировки
T_Start               DATE,               --  Дата дата начала действия
T_End                 DATE,               -- Дата окончания действия 
ARIDmo_B              Number,               --Арид МО было
ARIDmo_S              Number,               --Арид МО Cтало
RNPODR_b              number,               --Доли варианта Было
RNPODR_s              number,               --Доли варианта Стало
RNVO_b                number,        --Вид обработки Было
RNVO_s                number,        --Вид обработки Стало
POZMONOTE_b           varchar2(255),               --Примечание  Было
POZMONOTE_s           varchar2(255)               --Примечание Стало
)
/
---------------------------------
--  Changed type t_tb_izms_mo  --
---------------------------------
create or replace type w_mmkt.T_TB_IZMS_MO as TABLE OF T_IZMS_MO;
/
-------------------------------
--  Changed type t_izms_obr  --
-------------------------------
create or replace type w_mmkt.T_IZMS_OBR as object
(-- v24.04.2009
RN_TV_OBR         NUMBER,            -- РН ТВ образца
RN_TV_IZG         NUMBER,            -- РН ТВ с кем совместно изготавливается
ARID_POZMO        NUMBER,            -- Арид защиты
RN_TV_ZA          NUMBER,            -- РН Техварианта который защищаем
ATT_AUTH          NUMBER,            -- Ид документа основания
ATT_AUTHTYPE      NUMBER,            -- Тип документа основания
ATT_ALT           NUMBER,            -- GUID пользователя породившего состояние
ATT_ALTTYPE       NUMBER,            -- Тип пользователя
rn_podr           NUMBER,            -- Ид. подр защиты
rn_vo             NUMBER,            -- Ид. вида обработки защиты
DIZM              DATE,              -- Дата корректировки
T_Start           DATE,              --  Дата дата начала действия
T_End             DATE,              -- Дата окончания действия 
RN_PODR_ISP_B     NUMBER,            -- Ид. подразделения испытателя было
RN_PODR_ISP_S     NUMBER,            -- Ид. подразделения испытателя стало
RN_PODR_INITTD_B  NUMBER,            -- ИД. подразделения инициатора тех. добавки было 
RN_PODR_INITTD_S  NUMBER,            -- ИД. подразделения инициатора тех. добавки стало
TEHNKOL_b         NUMBER,            -- технологическое количество было
TEHNKOL_s         NUMBER,            -- технологическое количество стало
MAXPART_b         NUMBER,            -- Максимальная партия Было
MAXPART_s         NUMBER,            -- Максимальная партия Стало
INFOBRNOTE_b      VARCHAR2(2000),        --Индикатор не устанавливать Было
INFOBRNOTE_s      VARCHAR2(2000)        --Индикатор не устанавливать Стало
)
/
----------------------------------
--  Changed type t_tb_izms_obr  --
----------------------------------
create or replace type w_mmkt.T_TB_IZMs_OBR is Table of T_IZMS_OBR
/
------------------------------
--  Changed type t_izms_td  --
------------------------------
create or replace type w_mmkt.T_IZMS_TD as object
(-- v24.04.2009
RN_TV             NUMBER,            -- РН ТВ 
pornum            NUMBER,            -- Порядковый номер позиции МО
rn_pozmo          NUMBER,            -- Ид позиции 
ARID_POZMO        NUMBER,            -- Арид на который добавка
RN_PODR_INITTD    NUMBER,
TD_ARID_B         NUMBER,            -- Арид техдоб БЫЛО
TD_ARID_S         NUMBER,            -- Арид техдоб СТАЛО
ATT_AUTH          NUMBER,            -- Ид документа основания
ATT_AUTHTYPE      NUMBER,            -- Тип документа основания
ATT_ALT           NUMBER,            -- GUID пользователя породившего состояние
ATT_ALTTYPE       NUMBER,            -- Тип пользователя
DIZM              DATE,              -- Дата корректировки
T_Start           DATE,              --  Дата дата начала действия
T_End             DATE,              -- Дата окончания действия 
TEHNDOB_B         NUMBER,            -- Техдоб. пользователя было
TEHNDOB_N         NUMBER,            -- Техдоб. пользователя стало
TEHNKOL_B         NUMBER,            -- Техн. кол. пользователя
TEHNKOL_S         NUMBER,            -- Техн. кол. пользователя стало
MAXPART_B         NUMBER,            -- Макс. партия было
MAXPART_S         NUMBER,            -- Макс. партия стало
MINPART_B         NUMBER,            -- Мин. партия было
MINPART_S         NUMBER,            -- Мин. партия стало
RN_PODR_ISP_B     NUMBER,            -- Ид. подразделения испытателя было
RN_PODR_ISP_S     NUMBER,            -- Ид. подразделения испытателя стало
IND_SADKA_B       CHAR(1),           -- Одной садкой было
IND_SADKA_S       CHAR(1),           -- Одной садкой стало
TEHNDOBNOTE_B     VARCHAR2(2000),    -- Примечание было
TEHNDOBNOTE_S     VARCHAR2(2000)    -- Примечания стало
)
/
---------------------------------
--  Changed type t_tb_izms_td  --
---------------------------------
create or replace type w_mmkt.T_TB_IZMS_TD is Table of T_IZMS_TD
/
----------------------------------
--  Changed type t_izms_td_all  --
----------------------------------
create or replace type w_mmkt.T_IZMS_TD_ALL as object
(-- v24.04.2009
RN_TV             NUMBER,            -- РН ТВ 
pornum            NUMBER,            -- Порядковый номер позиции МО
rn_pozmo          NUMBER,            -- Ид позиции 
TD_ARID_B         NUMBER,            -- Арид техдоб БЫЛО
TD_ARID_S         NUMBER            -- Арид техдоб СТАЛО
)
/
-------------------------------------
--  Changed type t_tb_izms_td_all  --
-------------------------------------
create or replace type w_mmkt.T_TB_IZMS_TD_ALL is Table of T_IZMS_TD_ALL
/
------------------------------
--  Changed type t_izms_tv  --
------------------------------
create or replace type w_mmkt.T_IZMS_TV as object
(--Изместьев А.А. XЗ.09.2007
TV_RN_TV                    Number,               --РН ТехВар 
att_AUTH                 NUMBER,           -- Ид документа основания
att_AUTHTYPE        NUMBER,           -- Тип документа основания
att_ALT                     NUMBER,           -- GUID пользователя породившего состояние
att_ALTTYPE            NUMBER,          -- Тип пользователя
T_CorDate                 DATE,                -- Дата корректировки
T_Start                       DATE,               --  Дата дата начала действия
T_End                         DATE,               -- Дата окончания действия 
TV_ARID_B           Number,               --Арид ТВ было
TV_ARID_S           Number,               --Арид ТВ Cтало
TV_DOLY_B               number,               --Доли варианта Было
TV_DOLY_S               number,               --Доли варианта Стало
TV_NAIM_B                varchar2(255),        --НАименованриеТВ Было
TV_NAIM_S                varchar2(255),        --НАименованриеТВ Было
TV_MASSA_B                   number,               --Масса  Было
TV_MASSA_S                   number,               --Масса Стало
TV_NOTE_B                varchar2(2000),        --Примечание TV Было
TV_NOTE_S                varchar2(2000)      --Примечание TV Стало

)
/
---------------------------------
--  Changed type t_tb_izms_tv  --
---------------------------------
create or replace type w_mmkt.T_TB_IZMS_TV as TABLE OF T_IZMS_TV;
/
-------------------------------
--  Changed type t_izms_ust  --
-------------------------------
create or replace type w_mmkt.T_IZMS_UST as object
(-- v16.01.2008
RN_POZMO            Number,               -- РН ТехПозиции МО 
RN_ISPOB_CH       NUMBER,            -- Ид. используемого объекта
att_AUTH                 NUMBER,           -- Ид документа основания
att_AUTHTYPE        NUMBER,           -- Тип документа основания
att_ALT                     NUMBER,           -- GUID пользователя породившего состояние
att_ALTTYPE            NUMBER,           -- Тип пользователя
dizm                              DATE,                -- Дата корректировки
T_Start                          DATE,               --  Дата дата начала действия
T_End                           DATE,               -- Дата окончания действия 
ARIDust_B            number,                    --Арид МО было
ARIDust_S            Number,                    --Арид МО Cтало
rn_tv                   NUMBER,
kol_b                      number,                    --Доли варианта Было
kol_s                       number,               --Доли варианта Стало
ind1_variant_b       CHAR(1),        --Индикатор Было
ind1_variant_s        CHAR(1),        --Индикатор Стало
IND2_NEUST_b    CHAR(1),        --Индикатор не устанавливать Было
ind2_neust_s          CHAR(1),        --Индикатор не устанавливать Стало
USTCOMPNOTE_b         VARCHAR2(2000),--Комментарии Было
USTCOMPNOTE_s         VARCHAR2(2000), --Комментарии Стало
RN_EI_UST_b                 NUMBER,   -- Ид. единицы измерения Было
RN_EI_UST_s                 NUMBER,   -- Ид. единицы измерения Стало
ARIDMO_B                    NUMBER,   -- Ид. состояния позмо цеха сборщика было
ARIDMO_S                    NUMBER,   -- Ид. состояния позмо цеха сборщика стало
RNPODR_B                    NUMBER,   -- Ид. цеха сборщика было
RNPODR_S                    NUMBER,   -- Ид. цеха сборщика стало
RNVO_B                    NUMBER,     -- Ид. вида обработки сборщика было
RNVO_S                    NUMBER,     -- Ид. вида обработки сборщика стало
POZMONOTE_B               VARCHAR2(2000), -- Примечание было
POZMONOTE_S               VARCHAR2(2000)  -- Примечание стало
)
/
----------------------------------
--  Changed type t_tb_izms_ust  --
----------------------------------
create or replace type w_mmkt.T_TB_IZMs_UST is Table of T_IZMs_UST
/
-------------------------------
--  Changed type t_izms_zag  --
-------------------------------
create or replace type w_mmkt.T_IZMS_ZAG as object
(--Брылев С.В.. 13.09.2007
ARID_B           Number,               --Арид заготовки было
ARID_S           Number,               --Арид заготовки Cтало
RN_TV                    Number,               --РН ТехВар для которого заготовка
att_AUTH                 NUMBER,           -- Ид документа основания
att_AUTHTYPE        NUMBER,           -- Тип документа основания
att_ALT                     NUMBER,           -- GUID пользователя породившего состояние
att_ALTTYPE            NUMBER,          -- Тип пользователя
T_CorDate                 DATE,                -- Дата корректировки
T_Start                       DATE,               --  Дата дата начала действия
T_End                         DATE,               -- Дата окончания действия
RN_ISPOB_ZAG_B               number,               -- объекта заготовки Было
RN_ISPOB_ZAG_S               number,               -- объекта заготовки стало
RN_EI_B                   number,               --РН ед измерения Было
RN_EI_S                   number,               --РН ед измерения Стало
NORMRASH_B            number,               --Норма расхода Было
NORMRASH_S            number,               --Норма расхода Стало
VIDZAG_B               varchar2(30),        --Вид   заготовки было (КОД)
VIDZAG_S               varchar2(30),        --Вид   заготовки СТАЛО (КОД)
KOLDETZAG_B                      number,                --Кол Дет из заг было
KOLDETZAG_S                      number,                --Кол Дет из заг Стало
VESZAG_B                      number,                --Вес заготовки БЫЛО
VESZAG_S                      number,                --Вес заготовки СТАЛО
GEOMR_DL_B                      number,                --Геометрия Длина БЫЛО
GEOMR_DL_S                      number,                --Геометрия Длина Стало
GEOMR_SH_B                      number,                --Геометрия Ширина БЫЛО
GEOMR_SH_S                      number,                --Геометрия Ширина СТало
TZAGNOTE_B                varchar2(2000),        --Примечание заготовки Было
TZAGNOTE_S                varchar2(2000)        --Примечание заготовки Стало
)
;
/
----------------------------------
--  Changed type t_tb_izms_zag  --
----------------------------------
create or replace type w_mmkt.T_TB_IZMS_ZAG as TABLE OF T_IZMS_ZAG;
/
------------------------------
--  Changed type t_izm_ust  --
------------------------------
create or replace type w_mmkt.T_IZM_UST as object
(--Изместьев А.А. 4.09.2007
UST_TYP                   number, --Тип изменения (1- анулирование, 2 - введение, 3 - изменение)
UST_RN_POZ_MO     number, --РН  ПОЗЩО установки     
UST_RNTV                 number, 
UST_KOL_B              number, --Кол-во было
UST_KOL_S              number, --Кол-во было
UST_IND1_B             char(1),
UST_IND1_S             char(1),
UST_IND2_B             char(1),
UST_IND2_S             char(1),
UST_NOTE_B             varchar2(2000),
UST_NOTE_S             varchar2(2000),
UST_RNEI_B             number,
UST_RNEI_S             number,
UST_EI_B             Varchar2(30),
UST_EI_S             Varchar2(30),
UST_MODET_B             Varchar2(50), -- Последний цех + цех установки был
UST_MODET_S             Varchar2(50),
UST_MO_B                varchar2(7), --Цех установки
UST_MO_S                varchar2(7),
UST_RNISP               number,
UST_VID_IZM             number, --0 было 1 - стало
USN_ISPOB_B             Varchar2(255),
USN_ISPOB_S             Varchar2(255),
UST_TV_NAIM            varchar2(255),
UST_TV_DOL_B            number,
UST_TV_VI               varchar2(30), 
Is_NOTFIR number --Если первая запись по ТВ то 0 иначе больше 0



--Все стало кроме обозначения не нужны Гыыыыы
)
/
---------------------------------
--  Changed type t_tb_izm_ust  --
---------------------------------
create or replace type w_mmkt.T_TB_IZM_UST is Table of T_IZM_UST
/
---------------------------------
--  Changed view v_isp_ob_inf  --
---------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_ISP_OB_INF AS
SELECT -- RULE
/* 22.03.05 Бельтюков Н.В.
   Информация об используемом объекте с доп. информацией
*/
  io.*,
  vio.kornaim AS VID_ISPOB,
  vio.naim AS VID_NAIM,
  CASE io.TIP_ISPOB
    WHEN 'С' THEN 'свой'
    WHEN 'П' THEN 'покупной'
    when  'М' then 'Мусор' --теперь еще и такое есть ( 1.10.07)
    when  'Д' then 'с доработкой' --теперь еще и такое есть ( 1.02.09)
  END AS TIP_NAIM,
  CASE vio.kornaim
    WHEN 'Х' THEN (SELECT ms.NAME_FULL FROM W_SPRMAT.VW_MAT_SPR_EX_WITH_MAT118 ms WHERE ms.rn = io.RN_MAT) --Х поставил за место М так как терь материалы тащим нормально!!!!
    ELSE io.OBOZN
  END AS OBOZN1
FROM
  W_KTSG.v_isp_ob_F io,
  w_ktsg.tb_vid_isp_ob vio
WHERE
  io.RN_VID_ISPOB = vio.rn;
----------------------------------
--  Changed view v_isp_ob0_inf  --
----------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_ISP_OB0_INF AS
SELECT 
/* 02.02.05 Бельтюков Н.В.
   Информация об используемом объекте с доп. информацией
*/  
  io.*
FROM
  V_ISP_OB_INF io 
WHERE
  io.T_VAR=0 AND io.T_DIS is null;
---------------------------------------
--  Changed view v_izm_tv_completed  --
---------------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_IZM_TV_COMPLETED AS
SELECT t.*
FROM  
  w_ktsg.tb_izm_tv t
where 
  t.ind_zavrazr in ('Н','1');
---------------------------------
--  Changed view v_izm_tv_inf  --
---------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_IZM_TV_INF AS
SELECT --+ STAR
/* 01.02.05 Бельтюков Н.В.
   Изменения технологических вариантов с доп. информацией
   об используемом объекте
*/  
  it.*,
  CASE it.pornom_tv
    WHEN 0 THEN '+'
    ELSE 'И'
  END AS VID_IZM,
  io.OBOZN,
  tv.vi,
  tv.TVNAIM,
  io.VID_ISPOB,
  io.VID_NAIM,
  io.TIP_ISPOB,
  io.TIP_NAIM,
  ps.nomizm,
  ps.ind_stexist,
  ps.dt_izmstexist,
  ps.vid_doc
from 
  W_KTSG.TB_IZM_TV it,
  W_KTSG.TB_PER_SOGL ps,
  V_TV_LAST tv,
  V_ISP_OB_INF io
WHERE
  --it.pornom_tv >= 0 AND
  it.rn_persogl = ps.rn AND
  it.rn_tv = tv.RN AND
  tv.rn_ispob = io.rn;
--------------------------------
--  Changed view v_kts_mo_pn  --
--------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_KTS_MO_PN AS
SELECT m.*,rank() OVER  (PARTITION BY  m.kdce ORDER BY m.nmp) np FROM w_kts.mo
m;
-----------------------------------
--  Changed view v_per_sogl_inf  --
-----------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_PER_SOGL_INF AS
SELECT

  ps.*,
  pc.rn AS RN_KADR,
  pc.FIO,
  pc.mp,
  guid
FROM
  W_KTSG.V_PER_SOGL ps
  LEFT OUTER JOIN (
                 SELECT GUID, RN FROM W_AD.V_SUBJECT_OF_AUDIT UNION ALL
                 SELECT w_ad.to_numberguid('bbd905a633b9ae48aee3d06d58f3f519'), -1 FROM dual UNION ALL
                 SELECT w_ad.to_numberguid('c3f7d5c648d9274f83b0cc4be1d952bd'), -2 FROM dual UNION ALL
                 SELECT 0, -999 FROM dual
                  ) sa ON   sa.GUID = ps.rn_sotr_avt
  LEFT OUTER JOIN(
                 SELECT RN, FIO, MP FROM W_KADR.V_PERSON_MP_CURRENT_S UNION ALL
                 SELECT -1, 'бюро БНХ', '140' FROM dual UNION ALL
                 SELECT -2, 'МБ 118 отдела', '118' FROM dual  UNION ALL
                 SELECT -999, 'Автоматическая загрузка', '140' FROM dual
                 ) pc ON pc.rn = sa.RN;
-------------------------------------
--  Changed view v_ust_components  --
-------------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_UST_COMPONENTS AS
SELECT


/* 02.05.06 Бельтюков Н.В.
   Информация о установках компонент
*/
  io.OBOZN1 AS OBOZN_CH,
  io.VID_ISPOB AS VID_ISPOB_CH,
  io.VID_NAIM AS VID_NAIM_CH,
  io.TIP_ISPOB AS TIP_ISPOB_CH,
  io.TIP_NAIM AS TIP_NAIM_CH,

  /*извлечем информацию об установке компоненты*/
  uc.*,

  /* найдем индикаторы: "явл. технол. вар.", "есть комп.", "шифр принадежности из БД ММВ" */
  NVL((SELECT '1' FROM W_KTSG.V_TV_F tv WHERE tv.RN_ISPOB = uc.RN_ISPOB_CH AND ROWNUM = 1), '0') AS IND_IS_TV,
  (SELECT tv.RN FROM W_KTSG.V_TV_F tv WHERE tv.RN_ISPOB = uc.RN_ISPOB_CH AND ROWNUM = 1) AS RN_TV_CH,
  NVL((SELECT tv.IND_NALCOMP FROM W_KTSG.V_TV_F tv WHERE tv.RN_ISPOB = uc.RN_ISPOB_CH AND ROWNUM = 1), '0') AS IND_HAS_COMP,
  F_GET_TV_SPR(
               io.VID_ISPOB,
               io.TIP_ISPOB,
               NVL((SELECT tv.IND_NALCOMP FROM W_KTSG.V_TV_F tv WHERE tv.RN_ISPOB = uc.RN_ISPOB_CH AND ROWNUM = 1), '0')) AS SPR
FROM
  V_ISP_OB_INF io,
  W_KTSG.V_UST_COMP_F uc
WHERE
  uc.RN_ISPOB_CH = io.rn

--Иначе фигню показывать будет
  --AND
--  uc.T_DIS IS NULL




/*
\* 02.05.06 Бельтюков Н.В.
   Информация о установках компонент
*\
  io.OBOZN1 AS OBOZN_CH,
  io.VID_ISPOB AS VID_ISPOB_CH,
  io.VID_NAIM AS VID_NAIM_CH,
  io.TIP_ISPOB AS TIP_ISPOB_CH,
  io.TIP_NAIM AS TIP_NAIM_CH,

  \*извлечем информацию об установке компоненты*\
  uc.*,

  \* найдем индикаторы: "явл. технол. вар.", "есть комп.", "шифр принадежности из БД ММВ" *\
  NVL((SELECT '1' FROM W_KTSG.V_TV_F tv WHERE tv.RN_ISPOB = uc.RN_ISPOB_CH AND ROWNUM = 1), '0') AS IND_IS_TV,
  (SELECT tv.RN FROM W_KTSG.V_TV_F tv WHERE tv.RN_ISPOB = uc.RN_ISPOB_CH AND ROWNUM = 1) AS RN_TV_CH,
  NVL((SELECT tv.IND_NALCOMP FROM W_KTSG.V_TV_F tv WHERE tv.RN_ISPOB = uc.RN_ISPOB_CH AND ROWNUM = 1), '0') AS IND_HAS_COMP,
  F_GET_TV_SPR(
               io.VID_ISPOB,
               io.TIP_ISPOB,
               NVL((SELECT tv.IND_NALCOMP FROM W_KTSG.V_TV_F tv WHERE tv.RN_ISPOB = uc.RN_ISPOB_CH AND ROWNUM = 1), '0')) AS SPR
FROM
  V_ISP_OB_INF io,
  W_KTSG.V_UST_COMP_F uc
WHERE
  uc.RN_ISPOB_CH = io.rn AND
  uc.T_DIS IS NULL

*/;
--------------------------------------
--  Changed view v_ust_components0  --
--------------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_UST_COMPONENTS0 AS
SELECT
/* 03.05.06 Бельтюков Н.В.
   Установки компонент с утвержденными состояниями
*/
  uc.*
FROM
  V_UST_COMPONENTS uc
WHERE
  uc.t_var = 0
  and nvl(uc.t_dis,0)=0;
----------------------------------
--  Changed view v_mmk0_tv_inf  --
----------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_MMK0_TV_INF AS
SELECT
/* 15.06.2006 Бельтюков Н.В. Информация утвержденная о тех. варианте для отчета
   15.07.2009 Бельтюков Н.В. Добавил индикатор объекта, информацию об утвержденном и разрабатываемом извещении
*/
  io.obozn,
  io.vid_naim,
  io.tip_naim,
  io.rn_draw AS IND_DRAW,
  tv.*,
  (SELECT COUNT(*) FROM v_ust_components0 tc WHERE tc.rn_tv = tv.RN AND ROWNUM = 1) AS IND_SOSTAV,
  (CASE WHEN (SELECT COUNT(*) FROM w_ktsg.tb_izm_tv itv join w_ktsg.tb_per_sogl ps ON itv.rn_persogl=ps.RN AND
          ps.IND_STEXIST='У' AND ps.rn_typedoc=w_osnov.f_getdoctype('ПС') WHERE itv.rn_tv=tv.rn AND itv.pornom_tv>=0 AND ROWNUM=1)>0 THEN 'ММК' ELSE 'ММВ' END)
           as IND_OBJ,
   ps0.FIO AS FIO,
   ps0.nomizm,
   (SELECT ps_utv.nomizm FROM w_ktsg.tb_per_sogl ps_utv WHERE ps_utv.rn = (SELECT MAX(ps.rn) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv it WHERE ps.rn = it.rn_persogl AND it.rn_tv = tv.RN AND ps.ind_stexist IN ('У','Н'))) AS NOMIZM_UTV,
   (SELECT ps_utv.osnovanie FROM w_ktsg.tb_per_sogl ps_utv WHERE ps_utv.rn = (SELECT MAX(ps.rn) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv it WHERE ps.rn = it.rn_persogl AND it.rn_tv = tv.RN AND ps.ind_stexist IN ('У','Н'))) AS osnovanie_UTV,
   (SELECT to_char(trunc(ps_utv.dt_izmstexist)) FROM w_ktsg.tb_per_sogl ps_utv WHERE ps_utv.rn = (SELECT MAX(ps.rn) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv it WHERE ps.rn = it.rn_persogl AND it.rn_tv = tv.RN AND ps.ind_stexist IN ('У','Н'))) AS DATE_UTV,
   (SELECT ps_razr.nomizm FROM w_ktsg.tb_per_sogl ps_razr WHERE ps_razr.rn = (SELECT MAX(ps.rn) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv it WHERE ps.rn = it.rn_persogl AND it.rn_tv = tv.RN AND ps.ind_stexist IN ('Р'))) AS NOMIZM_RAZR,
   (SELECT to_char(trunc(ps_razr.dt_izmstexist)) FROM w_ktsg.tb_per_sogl ps_razr WHERE ps_razr.rn = (SELECT MAX(ps.rn) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv it WHERE ps.rn = it.rn_persogl AND it.rn_tv = tv.RN AND ps.ind_stexist IN ('Р'))) AS DATE_RAZR
FROM
  v_tv0 tv,
  v_isp_ob0_inf io,
  w_ktsg.tb_izm_tv it0,
  v_per_sogl_inf ps0
WHERE
  tv.RN_ISPOB = io.rn AND
  tv.RN = it0.rn_tv AND
  it0.pornom_tv = (SELECT MIN(PORNOM_TV) FROM w_ktsg.tb_izm_tv it WHERE it.rn_tv = tv.RN) AND
  it0.rn_persogl = ps0.rn;
---------------------------------
--  Changed view v_mmk0_t_zag  --
---------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_MMK0_T_ZAG AS
SELECT
/* 19.06.2006 Бельтюков Николай
   Информация утвержденная о заготовке 
*/ 
  io.obozn,
  io.vid_naim,
  io.tip_naim,
  tz.*, 
  ei.kornaim,
  tz.VIDZAG || ' (' || vz.naim_vid || ')' AS VIDZAG_NAME
FROM  
  v_t_zag0 tz,
  v_isp_ob0_inf io,
  v_ei ei,
  W_VIDZAG.TB_VID_ZAG vz
WHERE  
  tz.RN_ISPOB_ZAG = io.rn AND
  tz.RN_EI = ei.rn AND
  tz.VIDZAG = vz.id_vid (+);
---------------------
--  New view v_mn  --
---------------------
create or replace view w_mmkt.v_mn as
select "KDCE","NN","EZ","NRM","CHVDCE","KDIZ","VIZ","VZ","RZ"
    from tb_mn;

----------------------
--  New view v_mo2  --
----------------------
create or replace view w_mmkt.v_mo2 as
select "KDCE","NMP","CEX","VO","TD"
    from tb_mo;

------------------------------
--  Changed view v_obr_inf  --
------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_OBR_INF AS
SELECT 
/* 18.05.06 Бельтюков Н.В.
   Информация об образцах с дополнительной информацией
*/ 
  o.*,
  ROUND(o.TEHNKOL, 4) AS TEHNKOL_R,  
  ROUND(o.MAXPART, 4) AS MAXPART_R,
  ioo.OBOZN AS OBOZN_TV_OBR,
  tvo.vi AS VI_TV_OBR,
  tvp.rn AS RN_TV_PROTECT,
  iop.OBOZN AS OBOZN_TV_PROTECT,
  pm.RN_PODR,
  pm.RN_VO,
  p.kornaim || ' ' || v.kornaim AS POZMO 
FROM 
  W_KTSG.V_OBR_F o,
  W_KTSG.V_TV_F tvo,
  W_KTSG.V_TV_F tvp,
  W_KTSG.V_ISP_OB_F ioo,
  W_KTSG.V_ISP_OB_F iop,
  W_KTSG.V_POZ_MO_F pm,
  W_MP.V_PODR p,
  W_VO.V_VO v
WHERE
  o.RN_TV_OBR = tvo.rn AND
  tvo.rn_ispob = ioo.rn AND
  o.ARID_POZMO = pm.arid AND
  pm.rn_tv = tvp.rn AND 
  tvp.rn_ispob = iop.rn AND
  pm.RN_PODR = p.rn AND 
  pm.RN_VO = v.rn AND
  o.T_DIS IS NULL;
-------------------------------
--  Changed view v_obr_inf0  --
-------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_OBR_INF0 AS
SELECT
/* 18.05.06 Бельтюков Н.В.
   Информация об образцах с утвержденными состояниями
*/
  o.*
FROM 
  V_OBR_INF o
WHERE 
  o.T_VAR = 0
WITH READ ONLY;
-----------------------------------
--  Changed view v_obr_inf_last  --
-----------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_OBR_INF_LAST AS
SELECT  
/* 18.05.06 Бельтюков Н.В.
   Информация об образцах с последними состояниями
*/  
  o1.*
FROM 
  V_OBR_INF o1
WHERE 
  o1.ARID = (SELECT MAX(ARID) FROM V_OBR_INF o2 
                 WHERE o2.rn_tv_izg =  o1.rn_tv_izg AND
                       o2.RN_TV_OBR = o1.RN_TV_OBR);
---------------------
--  New view v_oo  --
---------------------
create or replace view w_mmkt.v_oo as
select "KDCE","DCE","VI","SPR","NAIM_DCE","DCE_S"
    from tb_oo;

--------------------------------
--  Changed view v_o_osn_inf  --
--------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_O_OSN_INF AS
SELECT 
  io.obozn,
  io.vid_naim,
  io.tip_naim,
  tv.*,
  --(SELECT COUNT(*) FROM v_t_components0 tc WHERE tc.rn_tv_kuda = tv.RN AND ROWNUM = 1) AS IND_SOSTAV 
  (SELECT 0 FROM dual) AS IND_SOSTAV 
FROM 
  v_tv0 tv,
  v_isp_ob0_inf io
WHERE
  tv.RN_ISPOB = io.rn AND
  io.obozn = '15Я209.01.01.027';
-----------------------------
--  Changed view v_o_tzag  --
-----------------------------
create or replace view w_mmkt.v_o_tzag as
select 
  io.obozn,
  io.vid_naim,
  io.tip_naim,
  tz.*, 
  ei.kornaim
from 
  v_t_zag0 tz,
  v_isp_ob0_inf io,
  v_ei ei
where 
  tz.RN_ISPOB_ZAG = io.rn AND
  tz.RN_EI = ei.rn AND
  rn_tv = 399062;
----------------------------------------
--  Changed view v_per_sogl_inf_test  --
----------------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_PER_SOGL_INF_TEST AS
SELECT

  ps.*,
  pc.rn AS RN_KADR,
  pc.FIO,
  pc.mp,
  guid
FROM
  W_KTSG.V_PER_SOGL ps
  LEFT OUTER JOIN (
                 SELECT GUID, RN FROM W_AD.V_SUBJECT_OF_AUDIT UNION ALL
                 SELECT w_ad.to_numberguid('bbd905a633b9ae48aee3d06d58f3f519'), -1 FROM dual UNION ALL
                 SELECT w_ad.to_numberguid('c3f7d5c648d9274f83b0cc4be1d952bd'), -2 FROM dual UNION ALL
                 SELECT 0, -999 FROM dual
                  ) sa ON   sa.GUID = ps.rn_sotr_avt
  LEFT OUTER JOIN(
                 SELECT RN, FIO, MP FROM W_KADR.V_PERSON_MP_CURRENT_S UNION ALL
                 SELECT -1, 'бюро БНХ', '140' FROM dual UNION ALL
                 SELECT -2, 'МБ 118 отдела', '118' FROM dual  UNION ALL
                 SELECT -999, 'Автоматическая загрузка', '140' FROM dual
                 ) pc ON pc.rn = sa.RN;
----------------------------------------
--  Changed function f_get_mo_vhodim  --
----------------------------------------
create or replace function w_mmkt.F_GET_MO_VHODIM
(
p_RN_ISP in NUMBER,
p_RN_PS in number default 0,
p_Date in date default to_date('01.01.9999')
) 
return varchar2 is
Result varchar2(4000);
/*
  Функция показывает все входимости у ДСЕ кроме мусорных
  для разрабатываемого ПС выдается входимость с учетом его изменений 

19_10_09
  (не показываются входимости так же в те ДСЕ которые с учетом 
  изменений по данному ПС становятся мусорными!!!!)

  Если перечень не указан или утвержден то только по V0
*/
TYP_DOC number; --1 - Разработка 0 утв
TMP_PK_Values date;
TMP_VHOD NUMBER;
begin
        begin
        Select case when (a.ind_stexist='Р' or a.ind_stexist='С') then 1 else 0 end
        into TYP_DOC
        from w_ktsg.tb_per_sogl a
        where a.rn = p_rn_ps;
        exception when No_data_found then typ_doc:=0; --Документ не найден значит по утвержденному состоянию будет информация!!!
        end;
Result := ' ';
TMP_PK_Values:=W_KTSG.PK_VALUES.CURDATE;

W_KTSG.PK_VALUES.Set_CURDATE(p_Date);

If TYP_DOC=1 then
For SP_CEH in
(
SELECT DISTINCT kornaim, TYP
FROM(


SELECT DISTINCT pp.kornaim , 0 AS TYP
FROM 
(
SELECT DISTINCT
u1.rn_podr , iok.RN_ISPOB, u1.rn_tv
FROM
(SELECT --+ star
u.RN_TV, pm.RN_PODR
FROM 
(select  ust.RN_POZMO,ust.RN_TV FROM w_ktsg.v01_ust_comp_s_ps ust WHERE ust.RN_ISPOB_CH = p_RN_ISP AND ust.rn = p_RN_PS) u 
INNER JOIN  w_ktsg.v01_poz_mo_s_ps pm  ON (pm.rn = p_RN_PS AND pm.RN_POZMO = u.rn_pozmo AND pm.RN_TV = u.rn_tv) 
) u1
, w_ktsg.tb_tv tv
,w_ktsg.v0_isp_ob_s iok
WHERE tv.rn = u1.rn_tv AND iok.RN_ISPOB = tv.rn_ispob AND iok.TIP_ISPOB<>'М'
) spm
, w_mp.v_podr PP
WHERE pp.rn = spm.rn_podr
AND ( 
(F_GET_MO_existsVHODIM(spm.RN_ISPOB , p_RN_PS)>0 AND EXISTS(SELECT NULL FROM w_ktsg.tb_izm_tv itv WHERE itv.rn_tv = spm.rn_tv AND itv.rn_persogl = p_rn_ps))
OR 
NOT EXISTS(SELECT NULL FROM w_ktsg.tb_izm_tv itv WHERE itv.rn_tv = spm.rn_tv AND itv.rn_persogl = p_rn_ps)
)
--Как заготовка
UNION ALL

SELECT DISTINCT w_ktsg.f_get_CEH_POL (spz.rn_tv ) AS Kornaim,1 AS TYP
FROM 
(
SELECT z.RN_TV, iz.RN_ISPOB 
FROM w_ktsg.v01_t_zag_s_ps  z, w_ktsg.tb_tv tvz  , w_ktsg.v0_isp_ob_s iz
WHERE z.RN_ISPOB_ZAG = p_RN_ISP AND z.rn = p_RN_PS AND tvz.rn = z.RN_TV AND iz.RN_ISPOB = tvz.rn_ispob AND iz.TIP_ISPOB<>'М'
) spz
WHERE F_GET_MO_existsVHODIM(spz.RN_ISPOB , p_RN_PS)>0 

UNION ALL
--Как образец

SELECT mp.kornaim , 0 AS TYP
FROM
(
SELECT DISTINCT o.RN_PODR_ISP, ioo.RN_ISPOB
FROM w_ktsg.tb_tv tvo, w_ktsg.v01_obr_s_ps o,
w_ktsg.tb_tv tvoo  , w_ktsg.v0_isp_ob_s ioo
WHERE tvo.rn_ispob = p_RN_ISP AND o.RN_TV_OBR = tvo.rn AND o.rn = p_RN_PS
AND tvoo.rn = o.RN_TV_IZG AND ioo.RN_ISPOB = tvoo.rn_ispob AND ioo.TIP_ISPOB<>'М'
)spo, w_mp.tb_podr mp
WHERE F_GET_MO_existsVHODIM(spo.RN_ISPOB , p_RN_PS)>0 AND mp.rn = spo.RN_PODR_ISP


) ORDER BY TYP

/*from w_ktsg.tb_ust_comp_s u1, w_ktsg.tb_audi ua, 
w_ktsg.tb_poz_mo_s P1, w_ktsg.tb_audi PA, 
w_ktsg.tb_tv tv, w_ktsg.v0_isp_ob_s iok
*/
/*where u1.rn_ispob_ch = p_RN_ISP
and ua.att_arid = u1.att_arid
and ua.att_arver = 0 
and ua.att_arstart<=to_date('01.01.9999') and ua.att_arend>to_date('01.01.9999')
and ua.att_var = w_ktsg.f_get_maxv1_TUST_PS(u1.rn_tv ,u1.rn_pozmo ,p_RN_ISP , p_RN_PS)

and p1.rn_pozmo = u1.rn_pozmo
and pa.att_arid = p1.att_arid
and pa.att_arver = 0 
and pa.att_arstart<=to_date('01.01.9999') and pa.att_arend>to_date('01.01.9999')
and pa.att_var = w_ktsg.f_get_maxv1_POZMO_S_PS(p1.rn_pozmo,p_RN_PS)
and pp.rn = p1.rn_podr
AND tv.rn = u1.rn_tv AND iok.RN_ISPOB = tv.rn_ispob AND iok.TIP_ISPOB<>'М'*/
)
Loop
IF sp_ceh.typ= 0 THEN
--Состав
   IF Instr(Result,'Подразделения получатели ДСЕ')>0 THEN
        Result:=Result || ';  ' || sp_ceh.kornaim;
   ELSE
        Result:='Подразделения получатели ДСЕ '   || sp_ceh.kornaim;
   END IF;
ELSE
--заготовка 
   IF Instr(Result,'Подразделения получают ДСЕ как заготовку')>0 THEN
        Result:=Result || ';  ' || sp_ceh.kornaim;
   ELSE
        Result:=Result || '   ' || 'Подразделения получают ДСЕ как заготовку '   || sp_ceh.kornaim;
   END IF;
END IF;

/*If Result = ' ' then 

  Result:=Result || sp_ceh.kornaim; 
else
Result:=Result || ';  ' || sp_ceh.kornaim;
end if;*/
End Loop;

Else
--Перечень утвержден - берем только V0
For SP_CEH in
(
select distinct pp0.kornaim
from w_ktsg.v0_ust_comp_s u0, 
w_ktsg.v0_poz_mo_s P0, w_mp.v_podr PP0,
w_ktsg.tb_tv tv, w_ktsg.v0_isp_ob_s iok
where u0.rn_ispob_ch = p_RN_ISP
and p0.rn_pozmo = u0.rn_pozmo
and pp0.rn = p0.rn_podr
AND tv.rn = u0.rn_tv AND iok.RN_ISPOB = tv.rn_ispob AND iok.TIP_ISPOB<>'М'
)
Loop
If Result = ' ' then 
  Result:=Result || sp_ceh.kornaim; 
else
Result:=Result || ';  ' || sp_ceh.kornaim;
end if;
End Loop;


end if;


W_KTSG.PK_VALUES.Set_CURDATE(TMP_PK_Values);
If Result = ' ' THEN
--Если в состоянии V0 есть получатели - но выдать что Входимость данным документом анулирована
BEGIN
SELECT SUM(num)
INTO  TMP_VHOD
FROM
(
SELECT count(a.att_ARID) num
FROM w_ktsg.v0_ust_comp_s a, w_ktsg.tb_tv tv, w_ktsg.v0_isp_ob_s isp
WHERE a.RN_ISPOB_CH = p_RN_ISP  
AND a.RN_TV<>494707 --НАличие вхождения в товар не рассматриваем!!!!
AND tv.rn = a.RN_TV AND isp.RN_ISPOB = tv.rn_ispob AND isp.TIP_ISPOB<>'М' AND rownum<2

UNION ALL
SELECT COUNT(*) num
FROM w_ktsg.v0_t_zag_s z, w_ktsg.tb_tv tv, w_ktsg.v0_isp_ob_s isp
WHERE z.RN_ISPOB_ZAG = p_RN_ISP AND z.RN_TV<>494707
AND tv.rn = z.RN_TV AND isp.RN_ISPOB = tv.rn_ispob AND isp.TIP_ISPOB<>'М' AND rownum<2

UNION ALL
SELECT COUNT(*) num
FROM w_ktsg.tb_tv tvo, w_ktsg.v0_obr_s o, w_ktsg.tb_tv tv, w_ktsg.v0_isp_ob_s isp
WHERE tvo.rn_ispob = p_RN_ISP AND o.RN_TV_OBR = tvo.rn AND o.RN_TV_IZG<>494707
AND tv.rn = o.RN_TV_IZG AND isp.RN_ISPOB = tv.rn_ispob AND isp.TIP_ISPOB<>'М' AND rownum<2
);


EXCEPTION WHEN no_data_found THEN
TMP_VHOD:=0;
END;
IF TMP_VHOD = 0 THEN return('Нет получателей');
ELSE
--возможно нет применяемости по документу где-то выше а не совсем нету
--Если есть тупая применяемость в не мусорную ДСЕ - то Должно отписатся: существующие применяемости и сама ДСЕ больше не ИСПОЛЬЗУЕТСЯ
return('Применяемость аннулирована по текущему документу, ДСЕ больше не используется');
END IF;

else
--return(trim('Подразделения получатели ДСЕ  '||Result));
return(Result);
end if;

  
END;
/
---------------------------------
--  Changed type t_rep_izm_ps  --
---------------------------------
create or replace type w_mmkt.T_REP_IZM_PS as object
(--Изместьев А.А. 4.09.2007

--ИспОб
ISP_RN            number,            --  РН объекта
ISP_OBOZN_B varchar2(255),    --Обозначение было
ISP_OBOZN_S varchar2(255),    --Обозначение Стало
ISP_TIP_B        char(1),              --Тип объекта было
ISP_TIP_S        char(1),              --Тип объекта Стало
ISP_VID            number,            --Вид Иса Объекта
ISP_VID_TXT     varchar2(255),         --Вид ИспОб ТЕкст
ISP_IZG            char(1),              --Индикатор "может изотавливатся"


--ТехВар
TV_RN             number,                --РН ТВ объекта
TV_VI             Varchar2(30),          --Вариант изготовления
TV_IZG            char(1),                  --Изготавливаемый       
TV_IND            char(1),                  --Индикатор наличия комплектующих
TV_DOLY_B         number,                   --Доля было
TV_DOLY_S         number,                   --Доля Cтало
TV_NAIM_B           varchar2(255),         --Наименование ТВ было
TV_NAIM_S           varchar2(255),         --Наименование ТВ cтало
TV_MASSA_B          number,              --Масса ТВ было
TV_MASSA_S          number,              --Масса ТВ Стало
TV_NOTE_B          varchar2(2000),       --Примечание было
TV_NOTE_S          varchar2(2000),       --Примечание Стало

--Заготовка
ZAG_ARID_B           Number,               --Арид заготовки было
ZAG_ARID_S           Number,               --Арид заготовки Cтало
ZAG_RN_TV                    Number,               --РН ТехВар для которого заготовка
ZAG_RN_ISP_B               number,               --ЕТ объекта заготовки Было
ZAG_RN_ISP_S               number,               --ЕТ объекта заготовки стало
ZAG_OBOZN_B                varchar2(255),        --Обозначение заготовки Было
ZAG_OBOZN_S                varchar2(255),        --Обозначение заготовки Было
ZAG_ISPVID_B                 varchar2(30),       --Вид исп об заготовки было
ZAG_ISPVID_S                 varchar2(30),       --Вид исп об заготовки Сьало
ZAR_ISP_RNVID_B            number,               --РН вида объекта заготовки Было
ZAR_ISP_RNVID_S            number,               --РН вида объекта заготовки Стало
ZAG_RN_EI_B                   number,               --РН ед измерения Было
ZAG_RN_EI_S                   number,               --РН ед измерения Стало
ZAG_EI_B                         varchar2(30),        --Ед измерения Было
ZAG_EI_S                         varchar2(30),        --Ед измерения Стало
ZAG_NORMRAZ_B            number,               --Норма расхода Было       
ZAG_NORMRAZ_S            number,               --Норма расхода Стало
ZAG_VID_ZAG_B               varchar2(30),        --Вид   заготовки было (КОД)
ZAG_VID_ZAG_S               varchar2(30),        --Вид   заготовки СТАЛО (КОД)
ZAG_VID_STR_B               varchar2(100),        --Вид   заготовки ТЕКСТ было 
ZAG_VID_STR_S               varchar2(100),        --Вид   заготовки ТЕКСТ СТАЛО 
ZAG_KOLD_B                      number,                --Кол Дет из заг было
ZAG_KOLD_S                      number,                --Кол Дет из заг Стало
ZAG_VES_B                      number,                --Вес заготовки БЫЛО
ZAG_VES_S                      number,                --Вес заготовки СТАЛО
ZAG_DL_B                      number,                --Геометрия Длина БЫЛО
ZAG_DL_S                      number,                --Геометрия Длина Стало
ZAG_SH_B                      number,                --Геометрия Ширина БЫЛО
ZAG_SH_S                      number,                --Геометрия Ширина СТало
ZAG_NOTE_B                varchar2(2000),        --Примечание заготовки Было
ZAG_NOTE_S                varchar2(2000)        --Примечание заготовки Стало

/*     RN_GL number, --РН_ТВ Головной сборки на которую идет раскомплектовка
     ISP_GL varchar2(255), --Обозначение Головы
     
     RN_TV_CH number, --РН_ТВ ЧТО
     OBOZN_CH varchar2(255), --Обозначение ЧТО
     NAIM_CH varchar2(255), --Наименование техварианта ЧТО
     VI_CH varchar2(30), --Вар изгот. ЧТО
     MASS_CH number, --Масса ЧТО
     VID_CH varchar(255), --Вид исполнения ЧТО
     DOL_CH number, --Доля ЧТО
     
     ZAG_OBOZN varchar2(255), --Обозначение заготовки
     ZAGI_VID varchar2(255), --ВИД объекта заготовки
     ZAGI_TYP char(1), --Тип объекта заготовки
     ZAG_L number, 
     ZAG_W number,
     ZAG_VES number,
     ZAG_NRAS number,
     ZAG_NUMD number,
     ZAG_VID varchar2(100), --ВИд Заготовки
     ZAG_EI varchar2(30) , --Ед изм заг (Текст)
     ZAG_NOTE Varchar(2000), --Примечание по заготовке
     
     NUM_SB number , --Вхождение в сборку констр. ИТОГО
     NUM_AP number, --Вхождение в сборку Техн. ИТОГО
     RN_TV_K number, --Вхождение куда
     OBOZN_K varchar2(250), --Обозначение куда
     IS_LEV number, --Если левое вхождение а не в сборку
     RN_MO_K number, -- ПОЗ_МО вхождения в куда 
     
     TYP_MMK number, --ДЛя Дсе ЧТО тип карты ( 0 - Новая, 1 - Идущая, 2 - измененная, 3 - Идущая ММВ(ММК) , 4 - В разработке)
     NUM_SBU number, --Кол-во в сборку на уровень констр.
     
Is_OBR number, -- Если образец
OBOZN_OBIZG varchar2(255), --с каким ДСЕ изготавливается
OBR_MAXP number, --Образец максимальная партия
OBR_TK number, --Образец техн количество
CEH_ISP varchar2(3), --Цех испытатель
CEH_INIT varchar2(3), -- цех инициатор
POR_SORT number, --Порядок сортировки (Сборка или нет 1-й уровень)
POR_VID number --Порядок сортировки (Вид объекта -2-й уровень
*/-- придется подправить текст так чтоб было нормально по убыванию, 3-й уровень Обозначение ЧТО)


     
)
/
---------------------------------
--  Changed type t_rep_izm_tv  --
---------------------------------
create or replace type w_mmkt.T_REP_IZM_TV as object
(--Изместьев А.А. 4.09.2007
     DOLY number, --Доля варианта
     TV_NAIM varchar2(255), --Наименование ТВ
     RN_TV number, --РН_ТВ ЧТО
     VI varchar2(30), --Вар изгот. ЧТО
     MASS number, --Масса ЧТО
     TVNOTE varchar2(2000), --Тв Примечание
     ind_izg Char(1), --Индикатор может ли изготавливатся
     ind_nalcomp Char(1) --Индикатор наличия комплектующих
    
)
/
----------------------------------
--  Changed type t_rep_izm_zag  --
----------------------------------
create or replace type w_mmkt.T_REP_IZM_ZAG as object
(--Изместьев А.А. 4.09.2007
     RN_ISPOB_ZAG number, --РН ИСП ЗАГОТОВКИ
     RN_VID_ISPOB_ZAG varchar2(255), --РН ВИД ИСП ОБ ЗАГОТОВКИ
     RN_EI number, --РН Ед Из
     NORMRASH number, --НОРМА РАСХОДА
     VIDZAG varchar2(2), --Вид заготовки
     KOLDETZAG number, -- кол-во деталей из заготовки
     VESZAG Number, -- Вес заготовки
     GEOMR_DL Number, --
     GEOMR_SH number, 
     att_ARID number,
     TZAGNOTE varchar2(2000)
)
/
------------------------------------
--  Changed type t_tb_rep_izm_ps  --
------------------------------------
create or replace type w_mmkt.T_TB_REP_IZM_PS is Table of t_rep_izm_ps
--Изместьев А.А. 4.09.07
/
------------------------------
--  Changed type t_izm_isp  --
------------------------------
create or replace type w_mmkt.T_IZM_ISP as object
(--Изместьев А.А. 4.09.2007
ISP_RN            number,            --  РН объекта
ISP_OBOZN_B varchar2(255),    --Обозначение было
ISP_OBOZN_S varchar2(255),    --Обозначение Стало
ISP_TIP_B        char(1),              --Тип объекта было
ISP_TIP_S        char(1),              --Тип объекта Стало
ISP_VID            number,            --Вид Исп Объекта код
ISP_VID_TXT     varchar2(255),         --Вид ИспОб ТЕкст
ISP_IZG            char(1),              --Индикатор "может изотавливатся"
ISP_ARID_B number,
ISP_ARID_S number
)
/
---------------------------------
--  Changed type t_tb_izm_isp  --
---------------------------------
create or replace type w_mmkt.T_TB_IZM_ISP is Table of T_IZM_ISP
--Изместьев А.А. 4.09.07
/
-----------------------------
--  Changed type t_izm_tv  --
-----------------------------
create or replace type w_mmkt.T_IZM_TV as object
(--Изместьев А.А. 4.09.2007
TV_ARID_B           Number,               --Арид ТВ было
TV_ARID_S           Number,               --Арид ТВ Cтало
TV_RN_TV                    Number,               --РН ТехВар 
TV_DOLY_B               number,               --Доли варианта Было
TV_DOLY_S               number,               --Доли варианта Стало
TV_NAIM_B                varchar2(255),        --НАименованриеТВ Было
TV_NAIM_S                varchar2(255),        --НАименованриеТВ Было
TV_MASSA_B                   number,               --Масса  Было
TV_MASSA_S                   number,               --Масса Стало
TV_NOTE_B                varchar2(2000),        --Примечание TV Было
TV_NOTE_S                varchar2(2000),      --Примечание TV Стало
TV_RN_ISPOB         Number, -- РН исп объекта
TV_VI                      varchar2(30), -- (Вариант изготовления) ТВ     
--TV_IND_IZG                 char(1),         --Индикатор изготовления объекта  = 1 поетому нгхер не нужен
TV_IND_NALCOMP         char(1),               --Индикатор наличия комплектующих - ПОЛНОЕ ФУФЛО по своей сущьности
TV_IS_SOST_B               number, --индикатор наличия состава 1 - есть 0 - нету
TV_IS_SOST_S               number --индикатор наличия состава 1 - есть 0 - нету

)
/
--------------------------------
--  Changed type t_tb_izm_tv  --
--------------------------------
create or replace type w_mmkt.T_TB_IZM_TV is Table of T_IZM_TV
--Изместьев А.А. 4.09.07
/
------------------------------
--  Changed type t_izm_zag  --
------------------------------
create or replace type w_mmkt.T_IZM_ZAG as object
(--Изместьев А.А. 4.09.2007
ZAG_ARID_B           Number,               --Арид заготовки было
ZAG_ARID_S           Number,               --Арид заготовки Cтало
ZAG_RN_TV                    Number,               --РН ТехВар для которого заготовка
ZAG_RN_ISP_B               number,               --ЕТ объекта заготовки Было
ZAG_RN_ISP_S               number,               --ЕТ объекта заготовки стало
ZAG_OBOZN_B                varchar2(255),        --Обозначение заготовки Было
ZAG_OBOZN_S                varchar2(255),        --Обозначение заготовки Было
ZAG_ISPVID_B                 varchar2(255),       --Вид исп об заготовки было
ZAG_ISPVID_S                 varchar2(255),       --Вид исп об заготовки Сьало
ZAR_ISP_RNVID_B            number,               --РН вида объекта заготовки Было
ZAR_ISP_RNVID_S            number,               --РН вида объекта заготовки Стало
ZAG_RN_EI_B                   number,               --РН ед измерения Было
ZAG_RN_EI_S                   number,               --РН ед измерения Стало
ZAG_EI_B                         varchar2(30),        --Ед измерения Было
ZAG_EI_S                         varchar2(30),        --Ед измерения Стало
ZAG_NORMRAZ_B            number,               --Норма расхода Было       
ZAG_NORMRAZ_S            number,               --Норма расхода Стало
ZAG_VID_ZAG_B               varchar2(30),        --Вид   заготовки было (КОД)
ZAG_VID_ZAG_S               varchar2(30),        --Вид   заготовки СТАЛО (КОД)
ZAG_VID_STR_B               varchar2(100),        --Вид   заготовки ТЕКСТ было 
ZAG_VID_STR_S               varchar2(100),        --Вид   заготовки ТЕКСТ СТАЛО 
ZAG_KOLD_B                      number,                --Кол Дет из заг было
ZAG_KOLD_S                      number,                --Кол Дет из заг Стало
ZAG_VES_B                      number,                --Вес заготовки БЫЛО
ZAG_VES_S                      number,                --Вес заготовки СТАЛО
ZAG_DL_B                      number,                --Геометрия Длина БЫЛО
ZAG_DL_S                      number,                --Геометрия Длина Стало
ZAG_SH_B                      number,                --Геометрия Ширина БЫЛО
ZAG_SH_S                      number,                --Геометрия Ширина СТало
ZAG_NOTE_B                varchar2(2000),        --Примечание заготовки Было
ZAG_NOTE_S                varchar2(2000)        --Примечание заготовки Стало
)
/
---------------------------------
--  Changed type t_tb_izm_zag  --
---------------------------------
create or replace type w_mmkt.T_TB_IZM_ZAG is Table of T_IZM_ZAG
--Изместьев А.А. 4.09.07
/
-------------------------------
--  Changed type t_col_sost  --
-------------------------------
create or replace type w_mmkt.T_COL_SOST as object
(--Изместьев А.А. 14.03.2007
     NUM_SB number , --Вхождение в сборку констр.
     RN_MO_K number, --Вхождение куда (ПОЗ_МО - переделано из поля)
     OBOZN_K varchar2(250), --Обозначение куда
     PODR varchar2(30), --подразделение
     VO varchar2(30) --Видобработки
)
/
-------------------------------
--  Changed type t_mat_norm  --
-------------------------------
create or replace type w_mmkt.T_Mat_Norm as object
(
 Kol Number,
 kdce_ch Number,
 ap Number,
 cex number,
 tv_ch number,
 ez number,
 ind number,
 urov number,
 golova number,
 PozMo number
)
/
-----------------------------------
--  Changed type t_mat_norm_set  --
-----------------------------------
create or replace type w_mmkt.T_Mat_norm_SET is Table of T_Mat_norm
/
--------------------------------
--  Changed type t_rep_struc  --
--------------------------------
create or replace type w_mmkt.T_REP_STRUC as object
(--Изместьев А.А. 14.03.2007
     RN_GL number, --РН_ТВ Головной сборки на которую идет раскомплектовка
     ISP_GL varchar2(255), --Обозначение Головы
     
     RN_TV_CH number, --РН_ТВ ЧТО
     OBOZN_CH varchar2(255), --Обозначение ЧТО
     NAIM_CH varchar2(255), --Наименование техварианта ЧТО
     VI_CH varchar2(30), --Вар изгот. ЧТО
     MASS_CH number, --Масса ЧТО
     VID_CH varchar(255), --Вид исполнения ЧТО
     DOL_CH number, --Доля ЧТО
     
     ZAG_OBOZN varchar2(255), --Обозначение заготовки
     ZAGI_VID varchar2(255), --ВИД объекта заготовки
     ZAGI_TYP char(1), --Тип объекта заготовки
     ZAG_L number, 
     ZAG_W number,
     ZAG_VES number,
     ZAG_NRAS number,
     ZAG_NUMD number,
     ZAG_VID varchar2(100), --ВИд Заготовки
     ZAG_EI varchar2(30) , --Ед изм заг (Текст)
     ZAG_NOTE Varchar(2000), --Примечание по заготовке
     
     NUM_SB number , --Вхождение в сборку констр. ИТОГО
     NUM_AP number, --Вхождение в сборку Техн. ИТОГО
     RN_TV_K number, --Вхождение куда
     OBOZN_K varchar2(250), --Обозначение куда
     IS_LEV number, --Если левое вхождение а не в сборку
     RN_MO_K number, -- ПОЗ_МО вхождения в куда 
     
     TYP_MMK number, --ДЛя Дсе ЧТО тип карты ( 0 - Новая, 1 - Идущая, 2 - измененная, 3 - Идущая ММВ(ММК) , 4 - В разработке)
--     TYP_MMK_STR varchar2(255),
--     SHPR char(1),
     NUM_SBU number, --Кол-во в сборку на уровень констр.
     
     
Is_OBR number, -- Если образец
OBOZN_OBIZG varchar2(255), --с каким ДСЕ изготавливается
OBR_MAXP number, --Образец максимальная партия
OBR_TK number, --Образец техн количество
CEH_ISP varchar2(3), --Цех испытатель
CEH_INIT varchar2(3), -- цех инициатор
POR_SORT number, --Порядок сортировки (Сборка или нет 1-й уровень)
POR_VID number --Порядок сортировки (Вид объекта -2-й уровень
-- придется подправить текст так чтоб было нормально по убыванию, 3-й уровень Обозначение ЧТО)


     
)
/
----------------------------------
--  Changed type t_tb_col_sost  --
----------------------------------
create or replace type w_mmkt.t_Tb_COL_SOST is Table of T_COL_SOST
--Изместьев А.А. 13.03.07
/
----------------------------------
--  Changed type t_tb_rep_stuc  --
----------------------------------
create or replace type w_mmkt.t_Tb_REP_STUC is Table of t_rep_struc
--Изместьев А.А. 13.03.07
/
------------------------------------------
--  Changed type t_build_tree_test2401  --
------------------------------------------
create or replace type w_mmkt.T_build_tree_test2401 as object
(
Kol Number,
kdce_ch Number,
rn_podr number,
tv_ch number,
ez number,
ind number,
urov number,
rn_pozmo number,
kdce_k number,
tv_k number,
doly_ch number,
att_arid number
)
/
----------------------------------------------
--  Changed type t_build_tree_set_test2401  --
----------------------------------------------
create or replace type w_mmkt.T_build_tree_SET_test2401 is Table of T_build_tree_test2401
/
--------------------------------
--  Changed type t_rasc_elem  --
--------------------------------
create or replace type w_mmkt.T_RASC_ELEM as object
(
  -- Author  : BRULEV
  -- Created : 10.11.2006 17:16:55
  -- Purpose : 
  
     rnisp_k NUMBER,
     rntv_k NUMBER,
     rnisp_c NUMBER,
     rntv_c NUMBER,
     kol NUMBER,
     urov NUMBER(2)
)
/
------------------------------
--  Changed type t_rasc_nl  --
------------------------------
create or replace type w_mmkt.
t_RASC_NL as  TABLE OF t_rasc_elem;
/
----------------------------------
--  Changed type t_node_izm_el  --
----------------------------------
create or replace type w_mmkt.T_NODE_IZM_EL as object
(
  att_auth NUMBER
)
/
-------------------------------
--  Changed type t_node_izm  --
-------------------------------
create or replace type w_mmkt.T_NODE_IZM as
-- Тип изменений которые элементу предшествовали 
TABLE OF T_NODE_IZM_EL;
/
-------------------------------
--  Changed type t_res_elem  --
-------------------------------
create or replace type w_mmkt.T_RES_ELEM as object
(
     rnisp_k NUMBER,
     rntv_k NUMBER,
     rnisp_c NUMBER,
     rntv_c NUMBER,
     oldkol NUMBER,
     kol NUMBER,
     urov NUMBER(2),
     dstart DATE,
     dend DATE,
     rn_prich NUMBER,
     deltakol NUMBER,
     ardis CHAR(1),
     izms t_node_izm
)
/
-----------------------------
--  Changed type t_res_nl  --
-----------------------------
create or replace type w_mmkt.
t_RES_NL as  TABLE OF t_res_elem;
/
---------------------------------
--  Changed view v_t_zag0_inf  --
---------------------------------
create or replace view w_mmkt.v_t_zag0_inf as
select 
/* 26.02.06 Бельтюков Н.В.
   Информация о технол. заготовке и используемом объекте и ед. измерения
*/ 
  io.obozn,
  io.vid_naim,
  io.tip_naim,
  tz.*, 
  ei.kornaim
from 
  v_t_zag0 tz,
  v_isp_ob0_inf io,
  v_ei ei
where 
  tz.RN_ISPOB_ZAG = io.rn AND
  tz.RN_EI = ei.rn;
--------------------------------
--  Changed view v_t_zag_inf  --
--------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_T_ZAG_INF AS
SELECT
/* 08.08.06 Бельтюков Н.В.
   Информация о заготовке с дополнительной информацией
*/
  tz.*,
  vz.naim_vid
FROM
  W_KTSG.V_T_ZAG_F tz,
  W_VIDZAG.TB_VID_ZAG vz
WHERE
 -- tz.T_DIS is NULL AND
  tz.VIDZAG = vz.id_vid (+)
WITH READ ONLY;
---------------------------------
--  Changed view v_t_zag_inf0  --
---------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_T_ZAG_INF0 AS
SELECT
/* 08.08.06 Бельтюков Н.В.
   Технологические заготовки с утвержденными состояниями
*/
  tz.*
FROM
  V_T_ZAG_INF tz
WHERE
  tz.t_var = 0

and nvl(tz.t_dis,0)=0;
---------------------------------
--  Changed view v_t_zag_last  --
---------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_T_ZAG_LAST AS
SELECT  
/* 16.06.05 Бельтюков Н.В.
   технологические заготовки с последними состояниями
*/  
  tz1.* 
FROM 
  w_ktsg.v_t_zag_f tz1
WHERE 
  tz1.ARID = (SELECT MAX(ARID) FROM w_ktsg.v_t_zag_f tz2 
             WHERE tz2.RN_TV = tz1.RN_TV) AND
  tz1.T_DIS IS NULL;
------------------------------------------
--  Changed view v_ust_components_last  --
------------------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_UST_COMPONENTS_LAST AS
SELECT
/* 04.05.06 Бельтюков Н.В.
   Установки компонент с последними состояниями
*/
  uc1.*
FROM
  V_UST_COMPONENTS uc1
WHERE
  uc1.ARID = (SELECT MAX(ARID) FROM V_UST_COMPONENTS uc2
             WHERE uc2.rn_tv = uc1.rn_tv AND
                   uc2.RN_ISPOB_CH = uc1.RN_ISPOB_CH)
and nvl(uc1.t_dis,0)=0;
----------------------------------------------
--  Changed view v_ust_components_last_del  --
----------------------------------------------
CREATE OR REPLACE VIEW W_MMKT.V_UST_COMPONENTS_LAST_DEL AS
SELECT
/* 04.05.06 Бельтюков Н.В.
   Установки компонент с последними состояниями
*/
  uc1.*
FROM
  V_UST_COMPONENTS uc1
WHERE
  uc1.ARID = (SELECT MAX(ARID) FROM V_UST_COMPONENTS uc2
             WHERE uc2.rn_tv = uc1.rn_tv AND
                   uc2.RN_ISPOB_CH = uc1.RN_ISPOB_CH)
and nvl(uc1.t_dis,0)=0;
-------------------------
--  Changed view v_vo  --
-------------------------
CREATE OR REPLACE VIEW W_MMKT.V_VO AS
SELECT 
/* 17.02.05 Бельтюков Н.В.
   Виды обработки с наименованиями
   Удалены "левые" записи
*/  
  vo.*,
  von.naim
FROM  
  w_vo.tb_vo vo,
  w_vo.tb_vo_naim von
WHERE 
  vo.rn = von.rn (+) AND
  vo.ukazpr = 0;
-------------------------------
--  Changed type t_find_mmk  --
-------------------------------
create or replace type w_mmkt.T_FIND_MMK as object
(
OBOZN Varchar2(255),
PACK_OBOZN varchar2(255),
TIP_ISPOB char(1),
VID_ISPOB varchar2(30) ,
VID_NAIM varchar2(255),
ind_nalcomp char(1),
VI varchar2(30),
IND_SOSTAV number,
ATT_ARID NUMBER,
RN_TV NUMBER,
DOLY NUMBER,
TVNAIM VARCHAR2(255),
TVMASSA NUMBER,
OBJTYPE NUMBER,
TVNOTE VARCHAR2(2000),
SPR number
)
/
------------------------------------
--  Changed type t_find_mmk_tabl  --
------------------------------------
create or replace type w_mmkt.T_FIND_MMK_tabl is Table of T_FIND_MMK
/
----------------------------------------------
--  New function f_get_mo_to_str_izm_mmk_b  --
----------------------------------------------
create or replace function w_mmkt.F_GET_MO_TO_STR_IZM_MMK_B
(
p_sid IN NUMBER,
p_RN_TV in NUMBER
) 
return varchar2 is
Result varchar2(1024);
--Функция преобразует маршрут изменения ММК БЫЛО в строку (без ТД)!!!!
begin

RESULT:='';
FOR sp_mo IN(
SELECT a.podr_b||a.vo_b AS MO
FROM tb_sp_izm_mo a
WHERE a.sid = p_sid AND a.rn_tv = p_RN_TV AND NOT (a.podr_b IS NULL)
ORDER BY a.pornom
)
LOOP
RESULT:=RESULT||sp_mo.mo;
END LOOP;

  return(Result);
END;
/

----------------------------------------------
--  New function f_get_mo_to_str_izm_mmk_s  --
----------------------------------------------
create or replace function w_mmkt.F_GET_MO_TO_STR_IZM_MMK_S
(
p_sid IN NUMBER,
p_RN_TV in NUMBER
) 
return varchar2 is
Result varchar2(1024);
--Функция преобразует маршрут изменения ММК СТАЛО в строку (без ТД)!!!!
begin

RESULT:='';
FOR sp_mo IN(
SELECT a.podr_s||a.vo_s AS MO
FROM tb_sp_izm_mo a
WHERE a.sid = p_sid AND a.rn_tv = p_RN_TV AND NOT (a.podr_s IS NULL)
ORDER BY a.pornom
)
LOOP
RESULT:=RESULT||sp_mo.mo;
END LOOP;

  return(Result);
END;
/

-------------------------------------------
--  Changed function f_mmk_raskomp_kalc  --
-------------------------------------------
create or replace function w_mmkt.F_MMK_RASKOMP_KALC
(pObj Number,pdata date,p_part number)return w_mmk_raskomp.T_Mat_Norm_Set PIPELINED as
--13.10.2009 Брылев С.В.
-- Если есть раскомплектовка в таблице раскомплектовок то берет ее,
-- Если нет - записывает туда, потом выдает из таблицы
   vRN NUMBER;
BEGIN
   BEGIN
   SELECT t.rn INTO vRN FROM w_kalc.tb_for_rask t
   WHERE t.rn_tv=pObj AND t.part=p_part AND t.data_actual=pdata;
   EXCEPTION
       WHEN NO_DATA_FOUND THEN
          -- Раскомплектовываем
          p_raskomp_new(pObj,
                      pdata,
                      p_part);
          SELECT t.rn INTO vRN FROM w_kalc.tb_for_rask t
          WHERE t.rn_tv=pObj AND t.part=p_part AND t.data_actual=pdata;
   END;
   FOR c IN (SELECT  cast( MULTISET(SELECT kol,kol_vz, kdce_ch, ap,ap_vz, cex, tv_ch, ez, ind, urov,
                     golova, pozmo, NULL AS rn_vo, vid_zag AS vidzag, pornom FROM w_kalc.tb_raskomp t WHERE t.rn_rask=vRN) as  w_mmk_raskomp.t_mat_norm_set) AS dt  FROM dual ) LOOP
         IF c.dt.count > 0 THEN
            FOR i IN c.dt.FIRST .. c.dt.LAST LOOP
               PIPE ROW(c.dt(i));
            END LOOP;
         END IF;
   END LOOP;
   RETURN;
END;
/
------------------------------
--  New function f_mo_str0  --
------------------------------
CREATE OR REPLACE FUNCTION W_MMKT.F_MO_STR0(P_RN IN INTEGER,p_zexsb IN INTEGER DEFAULT 1) RETURN VARCHAR2
DETERMINISTIC
IS
       -- 20.11.2009 Брылев С.В. по материализованным представлениям
      -- Функция выдает маршрут (цехвоцехво) по RN
      -- 17.06.2008 Бельтюков Н.В. В строку маршрута добавлены цеха сборщики
      CURSOR s1 IS
         SELECT t.PORNOM, t.kpodr AS kornaim, lower(t.kvo) vobr
           FROM w_ktsg.mv_poz_mo t
          WHERE t.RN_TV = P_RN
          ORDER BY t.PORNOM;

      RS1 s1%ROWTYPE;
      s   VARCHAR2(1024);
      f   BOOLEAN; -- показывает, есть ли отрицательные позиции в маршруте
      i   PLS_INTEGER; -- номер (по счету) отрицательной позиции
      y   PLS_INTEGER; -- номер (по счету) положительной позиции
      
      v_SBOR_CEHS VARCHAR2(1024);
      cur DATE;
   BEGIN      
      f := FALSE;
      i := 0;
      y := 0;
      OPEN s1;
      LOOP
         FETCH s1
            INTO rs1;
         EXIT WHEN s1%NOTFOUND;
         IF rs1.pornom < 0 THEN
            f := TRUE;
            IF i = 0 THEN
               s := s || '{' || rs1.kornaim || rs1.vobr || ' ';
               i := 1;
            ELSE
               s := s || rs1.kornaim || rs1.vobr || ' ';
            END IF;
         ELSE
            IF f = FALSE THEN
               s := s || rs1.kornaim || rs1.vobr || ' ';
            ELSE
               IF y = 0 THEN
                  s := substr(s, 1, length(s) - 1) || '} ' || rs1.kornaim ||
                       rs1.vobr || ' ';
                  y := 1;
               ELSE
                  s := s || rs1.kornaim || rs1.vobr || ' ';
               END IF;
            END IF;
         END IF;
      END LOOP;
      CLOSE s1;
      IF i = 1 AND y = 0 THEN
         s := substr(s, 1, length(s) - 1) || '} ';
      END IF;     
      IF p_zexsb =1 THEN      
        -- Добавим цеха сборщики 
        -- цикл по записям цехов сборщиков
        FOR i IN (
            SELECT /*+RULE*/ DISTINCT pm.kpodr AS ceh
            FROM w_ktsg.tb_tv tv_ch 
            INNER JOIN w_ktsg.mv_ust_comp uc ON uc.RN_ISPOB_CH=tv_ch.RN_ISPOB
            INNER JOIN w_ktsg.mv_poz_mo pm ON pm.rn = uc.rn_pozmo             
            WHERE tv_ch.RN = P_RN
            ) LOOP
            -- составим строку цехов сборщиков
            v_SBOR_CEHS := v_SBOR_CEHS || i.ceh || ',';   
        END LOOP;
        --удалим конечную ','
        v_SBOR_CEHS := rtrim(v_SBOR_CEHS, ',');
        
        IF v_SBOR_CEHS IS NOT NULL THEN
           --добавим цеха сборщики к строке маршрута
           s:= s || '(' || v_SBOR_CEHS || ')';
        END IF; 
      END IF;      
      RETURN(s);
   END;
/

--------------------------------
--  Changed type t_mv_tv_inf  --
--------------------------------
create or replace type w_mmkt.t_mv_tv_inf as object
(
  -- Author  : BRULEV
  -- Created : 07.10.2009 11:28:42
  -- Purpose : Для материализованного представления
  mo_str VARCHAR2(1024),
  trud_str VARCHAR2(1024),
  trud_str_tip VARCHAR2(1024)
)
/
------------------------------------
--  Changed type t_mv_tv_inf_set  --
------------------------------------
create or replace type w_mmkt.t_mv_tv_inf_set as TABLE OF t_mv_tv_inf;
/
-------------------------------------
--  New function f_mv_tv_inf_str0  --
-------------------------------------
create or replace function w_mmkt.F_MV_TV_INF_STR0(P_RN IN NUMBER) RETURN t_mv_tv_inf_set
PIPELINED
DETERMINISTIC
IS
vRec t_mv_tv_inf:=t_mv_tv_inf('','','');
-- 07.10.2009 Брылев С.В. чтоб все выдавать за один проход по маршруту
-- Функция выдает цеха с трудом  по RN с учетом тетрадных норм
      s VARCHAR2(1024) := '';
      cur DATE;      
   BEGIN
      FOR c1 IN (SELECT DISTINCT decode(p.tip,0,t.kpodr,t.kpodr || 'T') vobr,
                                 p.tip,
                                 (SELECT COUNT(*)
                                    FROM w_ktsg.mv_poz_mo mo
                                   WHERE mo.rn_tv = p_rn
                                     AND mo.rn_podr = t.rn_podr) an
                   FROM w_ktsg.mv_poz_mo_tr t                   
                   JOIN w_otk.mv_posloper p ON t.att_arid = p.ARID_POZ_MO_S
                   JOIN w_otk.mv_oper o ON p.att_ARID = o.ARID_POSLOPER_S
                  WHERE t.RN_TV = P_RN
                  ORDER BY 1) LOOP
         IF c1.an = 0 THEN
            IF c1.tip=0 THEN
               vRec.trud_str := vRec.trud_str || '(' || c1.vobr || ') ';
            END IF;
            vRec.trud_str_tip := vRec.trud_str_tip || '(' || c1.vobr || ') ';
            --s:=s || c1.vobr || ' ';
         ELSE
            IF c1.tip=0 THEN
               vRec.trud_str := vRec.trud_str || c1.vobr || ' ';
            END IF;
            vRec.trud_str_tip := vRec.trud_str_tip || c1.vobr || ' ';
         END IF;

      END LOOP;
      PIPE ROW(vRec);
      RETURN ;
end F_MV_TV_INF_STR0;
/

---------------------------------
--  Changed type t_node_td_el  --
---------------------------------
create or replace type w_mmkt.T_NODE_TD_EL as object
(
  RN_PODR_INITTD      NUMBER, --РН подразделения инициатора ТД
  arid_td         NUMBER,   -- арид добавки
  att_arstart     DATE,   -- Дата начала действия состояния
  att_arend      DATE,   -- Дата конца действия состояния
  att_auth        NUMBER, -- Изменение по которому изменилось состояние
  att_arver       NUMBER, -- Версия по которой изменилось состояние
  tehndob         NUMBER --Техдобавка
)
/
------------------------------
--  Changed type t_node_td  --
------------------------------
create or replace type w_mmkt.T_NODE_TD as
-- Состояния добавки внутри интервала записи маршрута
TABLE OF T_NODE_TD_EL;
/
---------------------------------
--  Changed type t_node_mo_el  --
---------------------------------
create or replace type w_mmkt.T_NODE_MO_EL as object
(
  rn_pozmo      NUMBER, --РН позиции
  arid_mo         NUMBER,   -- арид позиции
  att_arstart     DATE,   -- Дата начала действия состояния
  farid              NUMBER,   -- Первый арид изменения
  earid              number,   -- Первый арид следующего изменения
  att_arend      DATE,   -- Дата конца действия состояния
  att_auth        NUMBER, -- Изменение по которому изменилось состояние
  att_arver       NUMBER, -- Версия по которой изменилось состояние
  att_ardis       CHAR(1),   -- Признак аннулирования
  tds                t_node_td -- Состояния ТД
)
/
------------------------------
--  Changed type t_node_mo  --
------------------------------
create or replace type w_mmkt.T_NODE_MO as
-- Состояния маршрута внутри интервала записи входимости ТВ
TABLE OF T_NODE_MO_EL;
/
----------------------------------
--  Changed type t_res_intv_el  --
----------------------------------
create or replace type w_mmkt.T_RES_INTV_el as object
(
     dstart VARCHAR2(19),    -- Дата начала интервала
     farid    number,/*, -- первый арид изменения
     arid_k   number, -- арид куда
     att_arid number, -- арид что
     rnisp_k NUMBER, -- исп объект куда
     rntv_k NUMBER, -- тв куда*/
     rnisp_c NUMBER, -- исп объект что
     ez NUMBER, -- rn единицы измерения
     rn_pozmo NUMBER, -- rn единицы измерения     
     rntv_c NUMBER,  -- тв что     
     ap NUMBER, -- полная применяемость
/*     oldkol NUMBER,  --кол-во было до изменения
     kol NUMBER,     -- кол-во с учетом изменения
     ak NUMBER,      -- конструкторская применяемость     
     urov NUMBER(2), -- уровень на котором встречается
     dend DATE,*/      -- конец интервала
     ind CHAR(1)/*,    -- индикатор (1 - установка, 2 - заготовка, 3 - образец)
     rn_prich NUMBER, -- ид. изменения - сквозной для дельты
     deltakol NUMBER, -- разница между кол-ом было и стало
     ardis CHAR(1),   -- признак аннулирования
--     izms t_node_izm, -- список изменений которые уже встречались с этой же даты
     key NUMBER, -- Уникальный номер вхождения что куда среди всех что куда в дереве с учетом вышестоящих входимостей
     arid_zo NUMBER, -- Арид защищаемого объекта - только для образцов
     ind_new CHAR(1), -- Признак нового состояния
     att_auth1 NUMBER, -- Изменения без продолжения вниз по дереву - только у тех у которых изменилось
     golova NUMBER, -- RN_TV на который ведем расчет - изделие
     ind_dts CHAR(1), -- Признак что с той же даты два изменения по ветке: 0 - нету, 1 - есть

     ind_mo INTEGER -- Признак существования интервалов из за МО*/
--     mo_states t_node_mo, -- Список состояний маршрута внутри интервала записи входимости ТВ
--     mo_intv t_node_mo -- Интервалы на которые необходимо разбить входимость, чтоб учесть изменения МО и ТД
)
/
------------------------------
--  Changed type t_res_int  --
------------------------------
create or replace type w_mmkt.
t_RES_int as  TABLE OF t_res_intv_el;
/
--------------------------------
--  Changed type t_res_elem2  --
--------------------------------
create or replace type w_mmkt.T_RES_ELEM2 as object
(
     arid_k   number, -- арид куда
     att_arid number, -- арид что
     farid    number, -- первый арид изменения
     rnisp_k NUMBER, -- исп объект куда
     rntv_k NUMBER, -- тв куда
     rnisp_c NUMBER, -- исп объект что
     rntv_c NUMBER,  -- тв что
     oldkol NUMBER,  --кол-во было до изменения
     kol NUMBER,     -- кол-во с учетом изменения
     ak NUMBER,      -- конструкторская применяемость     
     urov NUMBER(2), -- уровень на котором встречается
     dstart DATE,    -- начало интервала
     dend DATE,      -- конец интервала
     ind CHAR(1),    -- индикатор (1 - установка, 2 - заготовка, 3 - образец)
     rn_prich NUMBER, -- ид. изменения - сквозной для дельты
     deltakol NUMBER, -- разница между кол-ом было и стало
     ardis CHAR(1),   -- признак аннулирования
     izms t_node_izm, -- список изменений которые уже встречались с этой же даты
     key NUMBER, -- Уникальный номер вхождения что куда среди всех что куда в дереве с учетом вышестоящих входимостей
     arid_zo NUMBER, -- Арид защищаемого объекта - только для образцов
     ind_new CHAR(1), -- Признак нового состояния
     att_auth1 NUMBER, -- Изменения без продолжения вниз по дереву - только у тех у которых изменилось
     golova NUMBER, -- RN_TV на который ведем расчет - изделие
     ind_dts CHAR(1), -- Признак что с той же даты два изменения по ветке: 0 - нету, 1 - есть
     ez NUMBER, -- rn единицы измерения
     ind_mo INTEGER -- Признак существования интервалов из за МО
)
/
------------------------------
--  Changed type t_res_nl2  --
------------------------------
create or replace type w_mmkt.
t_RES_NL2 as  TABLE OF t_res_elem2;
/
--------------------------------
--  Changed type t_res_elem3  --
--------------------------------
create or replace type w_mmkt.T_RES_ELEM3 as object
(
     arid_k   number, -- арид куда
     att_arid number, -- арид что
     farid    number, -- первый арид изменения
     rnisp_k NUMBER, -- исп объект куда
     rntv_k NUMBER, -- тв куда
     rnisp_c NUMBER, -- исп объект что
     rntv_c NUMBER,  -- тв что
     --oldkol NUMBER,  --кол-во было до изменения
     kol NUMBER,     -- кол-во с учетом изменения
     --ak NUMBER,      -- конструкторская применяемость     
     urov NUMBER(2), -- уровень на котором встречается
     dstart DATE,    -- начало интервала
     dend DATE,      -- конец интервала
     earid number,   -- Первый арид изменения след состояния
     ind CHAR(1),    -- индикатор (1 - установка, 2 - заготовка, 3 - образец)
     rn_prich NUMBER, -- ид. изменения - сквозной для дельты
     --deltakol NUMBER, -- разница между кол-ом было и стало
     ardis CHAR(1),   -- признак аннулирования
     --zms t_node_izm, -- список изменений которые уже встречались с этой же даты
     key NUMBER(8), -- Уникальный номер вхождения что куда среди всех что куда в дереве с учетом вышестоящих входимостей
     arid_zo NUMBER, -- Арид защищаемого объекта - только для образцов
     ind_new CHAR(1), -- Признак нового состояния
     att_auth1 NUMBER, -- Изменения без продолжения вниз по дереву - только у тех у которых изменилось
     golova NUMBER, -- RN_TV на который ведем расчет - изделие
     ind_dts CHAR(1), -- Признак что с той же даты два изменения по ветке: 0 - нету, 1 - есть
     ez NUMBER(3), -- rn единицы измерения
     ind_mo INTEGER, -- Признак существования интервалов из за МО
     mo_states t_node_mo, -- Список состояний маршрута внутри интервала записи входимости ТВ
     mo_intv t_node_mo, -- Интервалы на которые необходимо разбить входимость, чтоб учесть изменения МО и ТД
     flag number(1) -- Какой то флаг по единицам измерения - чтоб по разному считать техдобавку - округлять при Шт до целого, при 
     -- др. не округлять
)
/
------------------------------
--  Changed type t_res_nl3  --
------------------------------
create or replace type w_mmkt.
t_RES_NL3 as  TABLE OF t_res_elem3;
/
---------------------------------
--  Changed type t_rrasc_elem  --
---------------------------------
create or replace type w_mmkt.T_RRASC_ELEM as object
(
     farid    number, -- первый арид изменения
     rnisp_k NUMBER, -- исп объект куда
     rntv_k NUMBER, -- тв куда
     rnisp_c NUMBER, -- исп объект что
     rntv_c NUMBER,  -- тв что
     urov NUMBER(2), -- уровень на котором встречается
     dstart DATE,    -- начало интервала
     dend DATE,      -- конец интервала
     ind CHAR(1),    -- индикатор (1 - установка, 2 - заготовка, 3 - образец)
     rn_prich NUMBER, -- ид. изменения - сквозной для дельты
     ind_dts CHAR(1), -- Признак что с той же даты два изменения по ветке: 0 - нету, 1 - есть     
     golova NUMBER -- RN_TV на который ведем расчет - изделие
)
/
-------------------------------
--  Changed type t_rrasc_nl  --
-------------------------------
create or replace type w_mmkt.
t_RRASC_NL as  TABLE OF t_RRASC_elem;
/
---------------------------
--  Changed type t_test  --
---------------------------
create or replace type w_mmkt.T_TEST as object
(
   Rn number,
     Obozn Varchar2(300),
     vi Varchar2(2)
)
/
-------------------------------
--  Changed type t_test_set  --
-------------------------------
CREATE OR REPLACE TYPE W_MMKT.T_TEST_SET AS TABLE OF T_TEST
/
-----------------------------------
--  Changed type t_find_tv_klon  --
-----------------------------------
create or replace type w_mmkt.T_Find_tv_klon as object
(--Иванова Вера 14.02.2007
     Rn number,
     Obozn Varchar2(300),
     vi Varchar2(2),
     TvNaim Varchar2(300),
     m VARCHAR2(500),--МО 
     tr VARCHAR2(300),
     Nom_num varchar2(200),
     z varchar2(300),
     doly varchar2(50),
     geomr_dl number,
     geomr_sh number,
     ind_komp number,
     rn_ispob number,
     kol number,
     ap number,--
     ez varchar2(10),
     --Заглядова, 19.10.07
     vid_Isp_ob VARCHAR2(30)   
)
/
---------------------------------------
--  Changed type t_find_tv_klon_set  --
---------------------------------------
create or replace type w_mmkt.t_find_tv_klon_set is Table of t_find_tv_klon
--Иванова Вера 14.02.2007
/
--------------------------------
--  Changed type t_old_obr_s  --
--------------------------------
create or replace type w_mmkt.T_OLD_OBR_S as object
(--Изместьев А.А. 24.07.2009
--Типа для запоминания старого состояния в Образцах, при изменении МО
RN_TV_OBR NUMBER, --Рн_ТВ образца
RN_TV_IZG NUMBER,
ARID_POZMO NUMBER,
RN_PODR_ISP NUMBER,
RN_PODR_INITTD NUMBER,
TEHNKOL NUMBER,
MAXPART NUMBER,
INFOBRNOTE VARCHAR2(2000),
OBJTYPE NUMBER,
att_ARID NUMBER

     
)
/
-------------------------------
--  Changed type t_old_td_s  --
-------------------------------
create or replace type w_mmkt.T_OLD_TD_S as object
(--Изместьев А.А. 24.07.2009
--Типа для запоминания старого состояния в техдобавках, при изменении МО
RN_PODR_INITTD NUMBER,
TEHNDOB NUMBER,
TEHNKOL NUMBER,
MAXPART NUMBER,
MINPART NUMBER,
RN_PODR_ISP NUMBER,
IND_SADKA CHAR(1),
TEHNDOBNOTE VARCHAR2(2000),
OBJTYPE NUMBER,
ARID_POZMO NUMBER,
att_ARID NUMBER
    
)
/
-----------------------------------
--  Changed type t_tb_old_obr_s  --
-----------------------------------
create or replace type w_mmkt.T_TB_OLD_OBR_S is Table of T_OLD_OBR_S
/
----------------------------------
--  Changed type t_tb_old_td_s  --
----------------------------------
create or replace type w_mmkt.T_TB_OLD_TD_S is Table of T_OLD_TD_S
/
--------------------------------
--  Changed type t_delta_izv  --
--------------------------------
create or replace type w_mmkt.t_delta_izv as object
(
    num      integer,
    numosn VARCHAR2(30),
    rn_prich number,
    zex      varchar2(255),
    typ      char(1),
    nomizm   varchar2(30),
    rn_podr  number(3),
    kornaim  varchar2(3),
    dtsd     number,
    dtpv_f   number,
    dt_f     number,
    rn_osn   NUMBER
)
/
---------------------------------
--  Changed type tb_delta_izv  --
---------------------------------
create or replace type w_mmkt.tb_delta_izv

  is table of t_delta_izv;
/
--------------------------------
--  Changed package pk_delta  --
--------------------------------
CREATE OR REPLACE PACKAGE W_MMKT.PK_DELTA IS

  -- Author  : BRULEV
  -- Created : 19.09.2008 11:13:50
  -- Purpose :

  -- Public type declarations
  TYPE curtyp IS REF CURSOR;
  /*type t_delta_izv is record(
    num      integer,
    numosn NUMBER,
    rn_prich number,
    zex      varchar2(255),
    typ      char(1),
    nomizm   w_ktsg.tb_per_sogl.nomizm%type,
    rn_podr  number(3),
    kornaim  varchar2(3),
    dtsd     number,
    dtpv_f   number,
    dt_f     number);
  type tb_delta_izv is table of t_delta_izv;*/
  --*************************************************************
    --Дельта разрезе цехов
  PROCEDURE p_delta_zex(p_rntv   IN NUMBER,
                        p_dstart IN date,
                        p_dend   in date,
                        p_pz IN VARCHAR2,                        
                        p_delta  OUT curtyp);
  --*************************************************************
  --Дельта в разрезе извещений и технических отделов
  FUNCTION f_delta_izv(
                         p_rntv IN NUMBER, 
                         p_dstart IN date, 
                         p_dend in DATE,
                         p_pz IN VARCHAR2,                         
                         p_rnpodr IN NUMBER DEFAULT NULL)
    return tb_delta_izv    pipelined;
  --*************************************************************  
  --Дельта в разрезе извещений, технических отделов и цехов
  FUNCTION f_delta_izvtotzex(
                         p_rntv IN NUMBER, 
                         p_dstart IN date, 
                         p_dend in DATE,
                         p_pz IN VARCHAR2,                         
                         p_rnpodr IN NUMBER DEFAULT NULL)
    return tb_delta_izv   pipelined;
  --*************************************************************    
  --Дельта по извещению трудовому в разрезе ДСЕ
    PROCEDURE    p_delta_izvtot(p_rntv IN NUMBER,
                         p_dstart IN date,
                         p_dend in date,
                         p_pz in varchar2,                         
                         p_rnprich in number,
                         p_delta OUT curtyp
);
  --*************************************************************    
  --Дельта по извещению маршрутному в разрезе цехов
  PROCEDURE    p_delta_izvzex(p_rntv IN NUMBER,                        
                         p_dstart IN date,
                         p_dend in date,
                         p_pz in varchar2,                         
                         p_rnprich in number,
                         p_delta OUT curtyp
                         );
  --*************************************************************                             
  --Дельта по извещению маршрутному и по цеху в разрезе ДСЕ
  PROCEDURE    p_delta_izvtom(p_rntv IN NUMBER,
                         p_dstart IN date,
                         p_dend in date,
                         p_pz in varchar2,                         
                         p_rnprich in number,
                         p_rnpodr IN NUMBER,
                         p_delta OUT curtyp
); 
--*************************************************************    
  --Дельта по извещению трудовому в разрезе ДСЕ
    PROCEDURE    p_delta_izvtop(p_rntv IN NUMBER,
                         p_dstart IN date,
                         p_dend in date,
                         p_pz in varchar2,                         
                         p_rnprich in number,
                         p_rnpodr IN NUMBER,
                         p_delta OUT curtyp
);
--*************************************************************    
  --Заполняется таблица плановых цен на материалы
    PROCEDURE    p_zapoln_plcen(p_date IN date
);  
--*************************************************************
  --Дельта по МАТЕРИАЛАМ в разрезе тех.отделов и извещений
  --аналог табул. В-03-31 
  PROCEDURE    p_delta_matizv(p_par in varchar2, 
                              p_value in varchar2,
                              p_tehotd in varchar2,
                              p_dstart IN date,
                              p_dend in date,
                              p_data in date,
                              p_delta OUT curtyp
);                      
END PK_DELTA;
/
-----------------------------------
--  New procedure p_cr_izmps_mo  --
-----------------------------------
create or replace procedure w_mmkt.p_CR_IZMPS_MO(
--Формирование отчета изменения по ПС - формирует ся только МО!!!!
--результат суется в таблицу TB_TMP_IZM_MO

p_NOMPS in varchar2, --Номер документа по которому формировать изменения дя отчета 
p_SID out number --СИД для которого сформирован отчет!!!!
) IS

p_RNPS NUMBER;

t_sid number;
Is_GL number;

TMP_ISP_OBOZN_B varchar2(255);
TMP_ISP_OBOZN_S varchar2(255);
TMP_ISP_TIP_B char(1);
TMP_ISP_TIP_S char(1);
TMP_ISP_VID number;
TMP_ISP_VID_TXT varchar2(30);
TMP_ISP_IZG char(1);
TMP_ISP_VID_KOR VARCHAR2(30);



TMP_TV_DOLY_B number;
TMP_TV_DOLY_S number;
TMP_TV_NAIM_B varchar2(255);
TMP_TV_NAIM_S varchar2(255);
TMP_TV_MASSA_B number;
TMP_TV_MASSA_S number;
TMP_TV_NOTE_B varchar2(4000);
TMP_TV_NOTE_S varchar2(4000);
TMP_TV_INDCOMPL_B CHAR(1);
TMP_TV_INDCOMPL_S CHAR(1);

TMP_ZAG_RN_ISP_B number;
TMP_ZAG_RN_ISP_S number;
TMP_ZAG_OBOZN_B varchar2(255);
TMP_ZAG_OBOZN_S varchar2(255);
TMP_ZAG_EI_B varchar2(30);
TMP_ZAG_EI_S varchar2(30);
TMP_ZAG_NORMRAZ_B number;
TMP_ZAG_NORMRAZ_S number;
TMP_ZAG_VID_ZAG_B varchar2(30);
TMP_ZAG_VID_ZAG_S varchar2(30);
TMP_ZAG_VID_STR_B varchar2(255);
TMP_ZAG_VID_STR_S varchar2(255);
TMP_ZAG_KOLD_B number;
TMP_ZAG_KOLD_S number;
TMP_ZAG_VES_B number;
TMP_ZAG_VES_S number; 
TMP_ZAG_DL_B number;
TMP_ZAG_DL_S number;
TMP_ZAG_SH_B number;
TMP_ZAG_SH_S number;
TMP_ZAG_NOTE_B varchar2(2000);
TMP_ZAG_NOTE_S varchar2(2000);
TMP_ZAG_RN_MAT_B number;
TMP_ZAG_RN_MAT_S number;


TMP_MAT_112_B varchar2(255);
TMP_MAT_112_S varchar2(255);
TMP_MATEI_112_B varchar2(30);
TMP_MATEI_112_S varchar2(30);
TMP_MATNUM_112_B Number;
TMP_MATNUM_112_S Number;
TMP_MATDAT_112_B Date;
TMP_MATDAT_112_S Date;
TMP_MATDATOTP_112_B DATE;
TMP_MATDATOTP_112_S DATE;


TMP_RN_PS number;
TMP_PS_USE varchar2(255);
TMP_IND_NALCOMP char(1);

CURDATE varchar2(30);

p_Is_izm_SOST number;
p_Is_izm_MO number;
p_Is_izm_OBR number;


typ_Doc char(1);
TMP_typ_DCE varchar2(200);

TMP_DAT_F date := trunc(sysdate);
TMP_VHOD varchar2(2000);
TMP_IS_ED_PRIM number;

Num_Vhod NUMBER;

TMPS_typ_dce NUMBER;
TMPS_obozn_s VARCHAR2(255);
TMPS_rn_vid_ispob NUMBER;

IS_TOS NUMBER;

BEGIN
--Получаем длокумент
BEGIN
SELECT a.rn
INTO p_RNPS
FROM w_ktsg.tb_per_sogl a
WHERE a.nomizm=p_NOMPS;
EXCEPTION WHEN no_data_found THEN
p_sid:=-1;
RETURN;
END;

--1-е  получаем SID
 SELECT DISTINCT sid into t_sid from v$mystat;

--Определяем Тип документа
Select p.ind_stexist
into typ_doc
from w_ktsg.tb_per_sogl p
where p.rn = p_RNPS;


--2-e дату формирвоания представлений загоняем на бесконечно большое время!!!!
--Если вызов из интерфейса ММК то поидее тама и должно уже быть


CURDATE:=f_get_srok(p_RNPS);
W_KTSG.PK_VALUES.Set_CURDATE(CURDATE);



W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');

--3-е удаляем старые данные по СИДу - вдруг сидят
Delete from tb_sp_izm_mmk where sid = t_sid;
Delete from TB_SP_IZM_PRIM where sid = t_sid;
Delete from tb_sp_izm_mo where sid = t_sid;
Delete from TB_SP_IZM_VHOD where sid = t_sid;
DELETE FROM TB_TMP_IZM_MO  WHERE NOM_PS = p_NOMPS;

--4-е получаем все ДСЕ затронутые ПСом (Пока тока ТВ - ИспОбы не трогаю)
-- потмо и до испобов доберусь
--вначале получим список - потом 2-м проходом изменения БЫЛО-СТАЛО
For sp_tv in
(
select b.rn as RNTV, b.rn_ispob, b.vi,b.ind_nalcomp, c.rn_vid_ispob
from w_ktsg.tb_izm_tv a, w_ktsg.tb_tv b, w_ktsg.tb_isp_ob c
where 
a.rn_persogl = p_RNPS
and b.rn = a.rn_tv
and c.rn = b.rn_ispob
)
LOOP
--Проверяем на наличие вхождения по перечню куда - нибудь (определим Голова или нет)
--Как состав, как заготовка, как изготавливаемый совместно образец, как защищаемый что-то образец
Is_gl:=1;

insert into tb_sp_izm_mmk
  (sid, rn_isp, rn_tv, vi, rn_ps_use, str_ps_use, typ_dce,  rn_ps,/*typ_izmtv,*/ DAT_FORM/*, STR_VHHOD*/ )
values
  (T_sid, sp_tv.rn_ispob, sp_tv.rntv, sp_tv.vi, p_RNPS, 'По тек. док.', 
  case when Is_gl=0 then 0 when ((is_gl>0) and (sp_tv.ind_nalcomp='0')) then 2 else 1 end
    ,p_RNPS,/* TMP_typ_DCE,*/ TMP_DAT_F/*, TMP_VHOD*/);
    
--Сделаем проверку на наличие записей V1 в составе, МО, Образцах
--Состав
--Разработка или соглас перечень
If typ_Doc = 'Р' or typ_Doc = 'С' then
p_Is_izm_SOST:=0;
p_Is_izm_MO:=0;
p_Is_izm_OBR:=0;
else
p_Is_izm_SOST:=0;
p_Is_izm_MO:=0;
p_Is_izm_OBR:=0;
End if;

--Обновим в таблице данные
update tb_sp_izm_mmk ii
   set ii.if_izm_mo = p_Is_izm_MO, ii.if_izm_vhod = p_Is_izm_SOST, ii.if_izm_obr = p_Is_izm_OBR
where ii.sid = t_sid and ii.rn_tv = sp_tv.rntv;       
end loop;
--Далее можно определить состояние БЫЛО СТАЛО по етим позициям 
--Дотянутые ДСЕ потом НЕ БУДУТ ИМЕТЬ ИЗМЕНЕНИЯ их добавляем проверкой изменения в Заготовке 
--, в составе, в образцах
--так как Или не меняются или сидят в другом ПС - поэтому по ним будет информация только 
--по V1
--Определенные позиции не должны присутсвовать уже в таблице!!!!!!!!!

For sp_izm in
( select izm.rn_isp,izm.rn_tv,izm.vi,izm.typ_dce
from tb_sp_izm_mmk izm
where izm.sid = t_sid
)
Loop
--Определение было стало для ИСПОБА
Select  
ISP_OBOZN_B , ISP_OBOZN_S ,
ISP_TIP_B, ISP_TIP_S,
ISP_VID, ISP_VID_TXT , ISP_IZG  
into 
TMP_ISP_OBOZN_B,TMP_ISP_OBOZN_S,
TMP_ISP_TIP_B,TMP_ISP_TIP_S,
TMP_ISP_VID,TMP_ISP_VID_TXT,TMP_ISP_IZG
from table(f_get_izm_isp( 10,p_RNPS , sp_izm.rn_isp ))  ;

W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');
--Переделаем дату так функция ее меняет на дату ПС
--НАм же желательно бесконечная дата для представлений НЕ ПО ТЕКУЩЕМУ ПС!!!
--Изменения по ТВ
If typ_Doc = 'Р' or typ_doc='С' then
TMP_TV_DOLY_B:=null; TMP_TV_DOLY_S:=null; TMP_TV_NAIM_B:=null;TMP_TV_NAIM_S:=null;
TMP_TV_MASSA_B:=null;TMP_TV_MASSA_S:=null;
TMP_TV_NOTE_B:=null;TMP_TV_NOTE_S:=null;
else
TMP_TV_DOLY_B:=null; TMP_TV_DOLY_S:=null; TMP_TV_NAIM_B:=null;TMP_TV_NAIM_S:=null;
TMP_TV_MASSA_B:=null;TMP_TV_MASSA_S:=null;
TMP_TV_NOTE_B:=null;TMP_TV_NOTE_S:=null;
end if;

TMP_TV_INDCOMPL_B:=NULL;
TMP_TV_INDCOMPL_S:=NULL;
TMP_ISP_VID_KOR:=NULL;


TMP_ZAG_RN_ISP_B:=null;
TMP_ZAG_RN_ISP_S:=null;
TMP_ZAG_OBOZN_B:=null;
TMP_ZAG_OBOZN_S:=null;
TMP_ZAG_EI_B:=null;
TMP_ZAG_EI_S:=null;
TMP_ZAG_NORMRAZ_B :=null;
TMP_ZAG_NORMRAZ_S:=null;
TMP_ZAG_VID_ZAG_B :=null;
TMP_ZAG_VID_ZAG_S :=null;
TMP_ZAG_VID_STR_B :=null;
TMP_ZAG_VID_STR_S :=null;
TMP_ZAG_KOLD_B :=null;
TMP_ZAG_KOLD_S :=null;
TMP_ZAG_VES_B :=null;
TMP_ZAG_VES_S :=null; 
TMP_ZAG_DL_B :=null;
TMP_ZAG_DL_S :=null;
TMP_ZAG_SH_B :=null;
TMP_ZAG_SH_S :=null;
TMP_ZAG_NOTE_B:=null;
TMP_ZAG_NOTE_S :=null;
TMP_ZAG_RN_MAT_B:=null;
TMP_ZAG_RN_MAT_S:=null;
TMP_MAT_112_S:=null;
TMP_MATNUM_112_S:=null;
TMP_MATEI_112_S:=null;
TMP_MATDAT_112_S:=null;
TMP_MAT_112_B:=null;
TMP_MATNUM_112_B:=null;
TMP_MATEI_112_B:=null;
TMP_MATDAT_112_B:=null;
TMP_MATDATOTP_112_B:=NULL;
TMP_MATDATOTP_112_S:=NULL;

--Изменения в составе
--все позиции которые участвуют в изменении нужно добавить в таблицу,
--Если они не по текущему перечню - то смутить изменения
--(Если текущий документ утвержден то берем только утвержденные состояния)
--Если позиции не правятся - то просто состояние стало по ним
--Так же состояние стало идет при Утвержденном перечне!!!!!

--Обновляем данные в таблице - по изменениям
update tb_sp_izm_mmk ii
   set obozn_b = TMP_ISP_OBOZN_B,  obozn_s = TMP_ISP_OBOZN_S,
        name_b = TMP_TV_NAIM_B,  name_s = TMP_TV_NAIM_S,
       spr_b =NULL,-- f_get_tv_spr_new(TMP_ISP_VID_KOR ,TMP_ISP_TIP_B ,TMP_TV_INDCOMPL_B ,sp_izm.rn_tv ),
       spr_s =NULL,-- f_get_tv_spr_new(TMP_ISP_VID_KOR ,TMP_ISP_TIP_S ,TMP_TV_INDCOMPL_S ,sp_izm.rn_tv ),
ii.typ_dce_b = TMP_ISP_TIP_B,
ii.typ_dce_S = TMP_ISP_TIP_S,

--       str_obr_b = v_str_obr_b,
--       str_obr_s = v_str_obr_s,
--       if_izm_mo = v_if_izm_mo,
--       if_izm_vhod = v_if_izm_vhod,
--       if_izm_obr = v_if_izm_obr,
--       if_izm_zag = v_if_izm_zag,
       dce_zag_b = TMP_ZAG_OBOZN_B, dce_zag_s = TMP_ZAG_OBOZN_S,
       ves_dce_b = TMP_TV_MASSA_B,   ves_dce_s = TMP_TV_MASSA_S,
       ves_zag_b = TMP_ZAG_VES_B,     ves_zag_s =TMP_ZAG_VES_S,
       nrm_ras_b = TMP_ZAG_NORMRAZ_B, nrm_ras_s = TMP_ZAG_NORMRAZ_S,
       edizmzag_b = TMP_ZAG_EI_B,  edizmzag_s = TMP_ZAG_EI_S,
       kol_det_b = TMP_ZAG_KOLD_B,  kol_det_s = TMP_ZAG_KOLD_S,
      zdl_b = TMP_ZAG_DL_B, zdl_s = TMP_ZAG_DL_S, zsh_b = TMP_ZAG_SH_B, zsh_s = TMP_ZAG_SH_S,
       vid_zagkod_b = TMP_ZAG_VID_ZAG_B,   vid_zagkod_s = TMP_ZAG_VID_ZAG_S,
       vid_zagstr_b = TMP_ZAG_VID_STR_B,     vid_zagstr_s =TMP_ZAG_VID_STR_S,
       zag_prim_b = TMP_ZAG_NOTE_B,        zag_prim_s = TMP_ZAG_NOTE_S,
       tv_prim_b = TMP_TV_NOTE_B,    tv_prim_s = TMP_TV_NOTE_S,
       tv_doly_b = TMP_TV_DOLY_B,       
       -- is_izg = v_is_izg,
       tv_doly_s = TMP_TV_DOLY_S,
       zrn_b = TMP_ZAG_RN_ISP_B,
       zrn_s = TMP_ZAG_RN_ISP_S,
       ii.mat_b = TMP_MAT_112_B, ii.mat_s = TMP_MAT_112_S, ii.mat_ost_b = TMP_MATNUM_112_B, ii.mat_ost_s = TMP_MATNUM_112_S,
       ii.mat_dat_post_b = TMP_MATDAT_112_B ,ii.mat_dat_post_s = TMP_MATDAT_112_S, ii.mat_ei_b =TMP_MATEI_112_B ,ii.mat_ei_s=TMP_MATEI_112_S,
       ii.mat_otp_b = TMP_MATDATOTP_112_B, ii.mat_otp_s = TMP_MATDATOTP_112_S
 where ii.sid=t_sid and ii.rn_tv = sp_izm.rn_tv ;

end loop;
W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');

--ТЕперь Изменения в МО
For sp_TVAll in
(select im.rn_tv
from tb_sp_izm_mmk im
where im.sid = t_sid
and not im.rn_tv is null
)
Loop
--На каждый ТВ получим Было и стало по маршруту
If typ_Doc = 'Р' or typ_doc='С' then
Insert into tb_sp_izm_mo
Select 
t_sid,sp_tvall.rn_tv,PORNOM ,mp0.kornaim, mp1.kornaim, vo0.kornaim,vo1.kornaim,
PM0.POZMONOTE,PM1.POZMONOTE,
F_GET_TEHNDOB_STRING(td0.att_ARID), F_GET_TEHNDOB_STRING(td1.att_ARID)
from
(
Select distinct rn_pozmo, PORNOM  from (
(Select po1.RN_POZMO, poz.pornom from w_ktsg.v1_poz_mo_s po1, w_ktsg.tb_poz_mo poz where po1.RN_TV = sp_tvall.rn_tv and poz.rn = po1.RN_POZMO
union all
Select po0.RN_POZMO, poz.pornom from w_ktsg.v0_poz_mo_s po0,  w_ktsg.tb_poz_mo poz where po0.RN_TV = sp_tvall.rn_tv  and poz.rn = po0.RN_POZMO
)
                                                )
)PM
Left outer join w_ktsg.v0_poz_mo_s PM0 on (pm0.RN_POZMO = pm.rn_pozmo)
         left outer join w_mp.tb_podr mp0 on (mp0.rn = pm0.RN_PODR)
         left outer join w_vo.tb_vo vo0 on (vo0.rn = pm0.RN_VO)
         left outer join w_ktsg.v0_tehn_dob_s TD0 on (td0.ARID_POZMO=PM0.att_ARID)
Left outer join w_ktsg.v1_poz_mo_s PM1 on (pm1.RN_POZMO = pm.rn_pozmo)
         left outer join w_mp.tb_podr mp1 on (mp1.rn = pm1.RN_PODR)
         left outer join w_vo.tb_vo vo1 on (vo1.rn = pm1.RN_VO)
         left outer join w_ktsg.v1_tehn_dob_s TD1 on (td1.ARID_POZMO=PM1.att_ARID) ;
else

--Insert into tb_sp_izm_mo

--Перебор всех МО для ТВ с изменениями


Insert into tb_sp_izm_mo
select  t_sid,sp_tvall.rn_tv, sm.pornom, mp0.kornaim, mp1.kornaim, vo0.kornaim,vo1.kornaim,
sm.POZMONOTE_b,sm.POZMONOTE_s,
F_GET_TEHNDOB_STRING(td.TD_ARID_B), F_GET_TEHNDOB_STRING(td.TD_ARID_S)
from table(CAST(pk_mmk_izms.F_MO_TV_ALL(p_RNPS ,sp_tvall.rn_tv )   AS t_Tb_izms_mo)  )sm
   left outer join w_mp.tb_podr mp0 on (mp0.rn = sm.RNPODR_b)
        left outer join w_vo.tb_vo vo0 on (vo0.rn = sm.RNVO_b)
   left outer join w_mp.tb_podr mp1 on (mp1.rn = sm.RNPODR_S)
        left outer join w_vo.tb_vo vo1 on (vo1.rn = sm.RNVO_S),
 table(cast(pk_mmk_izms.F_TD_ALL(sp_tvall.rn_tv ,p_RNPS,Sm.ARIDmo_B ,sm.ARIDmo_S ,sm.RN_POZMO ) AS T_TB_IZMS_TD_ALL )  )TD;        
end if;

end loop;

P_SID:=t_sid;


--Заполняем табличку изменения МО
INSERT INTO TB_TMP_IZM_MO mo
(mo.NOM_PS, mo.dce,mo.rn_isp_ob,mo.vi,mo.rn_tv,mo.mo_b,mo.mo_s)
SELECT
p_NOMPS, i.obozn_s,i.rn_isp,i.vi,i.rn_tv, F_GET_MO_TO_STR_IZM_MMK_B(t_sid,i.rn_tv),F_GET_MO_TO_STR_IZM_MMK_S(t_sid,i.rn_tv)
FROM tb_sp_izm_mmk i
WHERE i.sid = t_sid;





COMMIT;
return;
end p_CR_IZMPS_MO;
/

----------------------------------------
--  Changed procedure p_cr_izmps_tmp  --
----------------------------------------
create or replace procedure w_mmkt.p_CR_IZMPS_TMP(
--Формирование отчета изменения по ПС
p_RNPS in number, --РН документа по которому формировать изменения дя отчета 
p_SID out number --СИД для которого сформирован отчет!!!!
) IS
t_sid number;
Is_GL number;

TMP_ISP_OBOZN_B varchar2(255);
TMP_ISP_OBOZN_S varchar2(255);
TMP_ISP_TIP_B char(1);
TMP_ISP_TIP_S char(1);
TMP_ISP_VID number;
TMP_ISP_VID_TXT varchar2(30);
TMP_ISP_IZG char(1);
TMP_ISP_VID_KOR VARCHAR2(30);



TMP_TV_DOLY_B number;
TMP_TV_DOLY_S number;
TMP_TV_NAIM_B varchar2(255);
TMP_TV_NAIM_S varchar2(255);
TMP_TV_MASSA_B number;
TMP_TV_MASSA_S number;
TMP_TV_NOTE_B varchar2(4000);
TMP_TV_NOTE_S varchar2(4000);
TMP_TV_INDCOMPL_B CHAR(1);
TMP_TV_INDCOMPL_S CHAR(1);

TMP_ZAG_RN_ISP_B number;
TMP_ZAG_RN_ISP_S number;
TMP_ZAG_OBOZN_B varchar2(255);
TMP_ZAG_OBOZN_S varchar2(255);
TMP_ZAG_EI_B varchar2(30);
TMP_ZAG_EI_S varchar2(30);
TMP_ZAG_NORMRAZ_B number;
TMP_ZAG_NORMRAZ_S number;
TMP_ZAG_VID_ZAG_B varchar2(30);
TMP_ZAG_VID_ZAG_S varchar2(30);
TMP_ZAG_VID_STR_B varchar2(255);
TMP_ZAG_VID_STR_S varchar2(255);
TMP_ZAG_KOLD_B number;
TMP_ZAG_KOLD_S number;
TMP_ZAG_VES_B number;
TMP_ZAG_VES_S number; 
TMP_ZAG_DL_B number;
TMP_ZAG_DL_S number;
TMP_ZAG_SH_B number;
TMP_ZAG_SH_S number;
TMP_ZAG_NOTE_B varchar2(2000);
TMP_ZAG_NOTE_S varchar2(2000);
TMP_ZAG_RN_MAT_B number;
TMP_ZAG_RN_MAT_S number;


TMP_MAT_112_B varchar2(255);
TMP_MAT_112_S varchar2(255);
TMP_MATEI_112_B varchar2(30);
TMP_MATEI_112_S varchar2(30);
TMP_MATNUM_112_B Number;
TMP_MATNUM_112_S Number;
TMP_MATDAT_112_B Date;
TMP_MATDAT_112_S Date;
TMP_MATDATOTP_112_B DATE;
TMP_MATDATOTP_112_S DATE;


TMP_RN_PS number;
TMP_PS_USE varchar2(255);
TMP_IND_NALCOMP char(1);

CURDATE varchar2(30);

p_Is_izm_SOST number;
p_Is_izm_MO number;
p_Is_izm_OBR number;


typ_Doc char(1);
TMP_typ_DCE varchar2(200);

TMP_DAT_F date := trunc(sysdate);
TMP_VHOD varchar2(2000);
TMP_IS_ED_PRIM number;

Num_Vhod NUMBER;

TMPS_typ_dce NUMBER;
TMPS_obozn_s VARCHAR2(255);
TMPS_rn_vid_ispob NUMBER;

IS_TOS NUMBER;

Begin
--1-е  получаем SID
 SELECT DISTINCT sid into t_sid from v$mystat;

--Определяем Тип документа
Select p.ind_stexist
into typ_doc
from w_ktsg.tb_per_sogl p
where p.rn = p_RNPS;


--2-e дату формирвоания представлений загоняем на бесконечно большое время!!!!
--Если вызов из интерфейса ММК то поидее тама и должно уже быть


CURDATE:=f_get_srok(p_RNPS);
W_KTSG.PK_VALUES.Set_CURDATE(CURDATE);



W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');

--3-е удаляем старые данные по СИДу - вдруг сидят
Delete from tb_sp_izm_mmk where sid = t_sid;
Delete from TB_SP_IZM_PRIM where sid = t_sid;
Delete from tb_sp_izm_mo where sid = t_sid;
Delete from TB_SP_IZM_VHOD where sid = t_sid;
--4-е получаем все ДСЕ затронутые ПСом (Пока тока ТВ - ИспОбы не трогаю)
-- потмо и до испобов доберусь
--вначале получим список - потом 2-м проходом изменения БЫЛО-СТАЛО
For sp_tv in
(
select b.rn as RNTV, b.rn_ispob, b.vi,b.ind_nalcomp, c.rn_vid_ispob
from w_ktsg.tb_izm_tv a, w_ktsg.tb_tv b, w_ktsg.tb_isp_ob c
where 
a.rn_persogl = p_RNPS
and b.rn = a.rn_tv
and c.rn = b.rn_ispob
)
LOOP
--Проверяем на наличие вхождения по перечню куда - нибудь (определим Голова или нет)
--Как состав, как заготовка, как изготавливаемый совместно образец, как защищаемый что-то образец
Select count(*)
into Is_gl
from 
(
select i.rn
from w_ktsg.tb_ust_comp_s u, w_ktsg.tb_audi u1,
 w_ktsg.tb_izm_tv i
where u.RN_ISPOB_CH = sp_tv.rn_ispob
and u1.att_arid = u.att_arid
and (u1.att_arver=0 or (u1.att_arver=1 and u1.att_ardis='1'))
and i.rn_tv = u.RN_TV
and i.rn_persogl = p_RNPS

union all

select i.rn
from w_ktsg.tb_t_zag_s z, w_ktsg.tb_audi z1,
 w_ktsg.tb_izm_tv i
where z.RN_ISPOB_ZAG = sp_tv.rn_ispob
and z1.att_arid = z.att_arid
and (z1.att_arver=0 or (z1.att_arver=1 and z1.att_ardis='1'))
and i.rn_tv = z.rn_tv
and i.rn_persogl = p_RNPS

Union all

select i.rn
from w_ktsg.tb_obr_s o, w_ktsg.tb_audi o1,
 w_ktsg.tb_izm_tv i
where o.rn_tv_obr = sp_tv.rntv
and o1.att_arid = o.att_arid
and (o1.att_arver=0 or (o1.att_arver=1 and o1.att_ardis='1'))
and i.rn_tv = o.rn_tv_izg
and i.rn_persogl = p_RNPS

Union all

select i.rn
from  w_ktsg.tb_izm_tv i, w_ktsg.tb_poz_mo_s p , w_ktsg.tb_audi p1, 
w_ktsg.tb_obr_s o2
where  i.rn_persogl = p_RNPS
and p.rn_tv = i.rn_tv
and p1.att_arid = p.att_arid
and (p1.att_arver=0 or (p1.att_arver=1 and p1.att_ardis='1'))
and o2.arid_pozmo = p.att_arid
and o2.rn_tv_obr = sp_tv.rntv
);

--Получаем входимость
--select f_get_mo_vhodim(sp_tv.rn_ispob,p_RNPS )
--into TMP_VHOD from dual;

--select F_Get_TYPDCE(sp_tv.rntv ,sp_tv.rn_ispob ,p_RNPS )
--into TMP_typ_DCE
--from dual;



insert into tb_sp_izm_mmk
  (sid, rn_isp, rn_tv, vi, rn_ps_use, str_ps_use, typ_dce,  rn_ps,/*typ_izmtv,*/ DAT_FORM/*, STR_VHHOD*/ )
values
  (T_sid, sp_tv.rn_ispob, sp_tv.rntv, sp_tv.vi, p_RNPS, 'По тек. док.', 
  case when Is_gl=0 then 0 when ((is_gl>0) and (sp_tv.ind_nalcomp='0')) then 2 else 1 end
    ,p_RNPS,/* TMP_typ_DCE,*/ TMP_DAT_F/*, TMP_VHOD*/);
    
--Сделаем проверку на наличие записей V1 в составе, МО, Образцах
--Состав
--Разработка или соглас перечень
If typ_Doc = 'Р' or typ_Doc = 'С' then

Select count(*)
into p_Is_izm_SOST
from w_ktsg.tb_ust_comp_s uu, w_ktsg.tb_audi ua
where uu.rn_tv = sp_tv.rntv
and ua.att_arid = uu.att_arid
and ua.att_var = 1
and ua.att_auth = p_RNPS;

--МО
Select count(*)
into p_Is_izm_MO
from w_ktsg.tb_poz_mo_s mm, w_ktsg.tb_audi ma
where mm.rn_tv = sp_tv.rntv
and ma.att_arid = mm.att_arid
and ma.att_var = 1
and ma.att_auth = p_RNPS;

IF p_Is_izm_MO = 0 THEN
SELECT  COUNT(*)
INTO p_Is_izm_MO
FROM w_ktsg.v1_poz_mo_s mm, w_ktsg.tb_tehn_dob_s td, w_ktsg.tb_audi ta
WHERE mm.RN_TV = sp_tv.rntv AND td.arid_pozmo = mm.att_ARID AND ta.att_arid = td.att_arid
and ta.att_var = 1
and ta.att_auth = p_RNPS;
END IF;




--Образцы
Select count(*)
into p_Is_izm_OBR
from w_ktsg.tb_obr_s oo , w_ktsg.tb_audi oa
where oo.rn_tv_izg = sp_tv.rntv
and oa.att_arid = oo.att_arid
and oa.att_var = 1
and oa.att_auth = p_RNPS;

else
--Утвержденный!!

--Состав
Select count(*)
into p_Is_izm_SOST
from table(pk_mmk_izms.F_SOSTAV(sp_tv.rntv ,p_RNPS )) WHERE not(rn_pozmo IS NULL) ;

--МО
Select count(*)
into p_Is_izm_MO
from table(pk_mmk_izms.F_MO(sp_tv.rntv ,p_RNPS ))WHERE not(rn_pozmo IS NULL) ;

IF p_Is_izm_MO = 0 THEN
Select count(*)
into p_Is_izm_MO
from table(pk_mmk_izms.F_TD(sp_tv.rntv ,p_RNPS ));
END IF;

--Образцы
Select count(*)
into p_Is_izm_OBR
from table(pk_mmk_izms.F_OBR(sp_tv.rntv ,p_RNPS ))WHERE not(rn_tv_obr IS NULL);
End if;

--Обновим в таблице данные
update tb_sp_izm_mmk ii
   set ii.if_izm_mo = p_Is_izm_MO, ii.if_izm_vhod = p_Is_izm_SOST, ii.if_izm_obr = p_Is_izm_OBR
where ii.sid = t_sid and ii.rn_tv = sp_tv.rntv;       
    
    
end loop;
--Далее можно определить состояние БЫЛО СТАЛО по етим позициям 
--Дотянутые ДСЕ потом НЕ БУДУТ ИМЕТЬ ИЗМЕНЕНИЯ их добавляем проверкой изменения в Заготовке 
--, в составе, в образцах
--так как Или не меняются или сидят в другом ПС - поэтому по ним будет информация только 
--по V1
--Определенные позиции не должны присутсвовать уже в таблице!!!!!!!!!

For sp_izm in
( select izm.rn_isp,izm.rn_tv,izm.vi,izm.typ_dce
from tb_sp_izm_mmk izm
where izm.sid = t_sid
)
Loop
--Определение было стало для ИСПОБА
Select  
ISP_OBOZN_B , ISP_OBOZN_S ,
ISP_TIP_B, ISP_TIP_S,
ISP_VID, ISP_VID_TXT , ISP_IZG  
into 
TMP_ISP_OBOZN_B,TMP_ISP_OBOZN_S,
TMP_ISP_TIP_B,TMP_ISP_TIP_S,
TMP_ISP_VID,TMP_ISP_VID_TXT,TMP_ISP_IZG
from table(f_get_izm_isp( 10,p_RNPS , sp_izm.rn_isp ))  ;

W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');
--Переделаем дату так функция ее меняет на дату ПС
--НАм же желательно бесконечная дата для представлений НЕ ПО ТЕКУЩЕМУ ПС!!!
--Изменения по ТВ
If typ_Doc = 'Р' or typ_doc='С' then
Begin
Select
TV_DOLY_B , TV_DOLY_S , TV_NAIM_B, TV_NAIM_S , TV_MASSA_B, TV_MASSA_S ,
TV_NOTE_B, TV_NOTE_S 
into 
TMP_TV_DOLY_B, TMP_TV_DOLY_S, TMP_TV_NAIM_B,TMP_TV_NAIM_S,
TMP_TV_MASSA_B,TMP_TV_MASSA_S,
TMP_TV_NOTE_B,TMP_TV_NOTE_S
from table(f_get_izm_tv(10 , p_RNPS , sp_izm.rn_tv,1 ));

exception when no_data_found then --Нету ТВ хотя есть РНТВ - гоним Нулы
TMP_TV_DOLY_B:=null; TMP_TV_DOLY_S:=null; TMP_TV_NAIM_B:=null;TMP_TV_NAIM_S:=null;
TMP_TV_MASSA_B:=null;TMP_TV_MASSA_S:=null;
TMP_TV_NOTE_B:=null;TMP_TV_NOTE_S:=null;
end;
else
--Утв
Begin
Select  IT.TV_DOLY_B, it.TV_DOLY_S, IT.TV_NAIM_B, IT.TV_NAIM_S, 
           IT.TV_MASSA_B, IT.TV_MASSA_S, IT.TV_NOTE_B, IT.TV_NOTE_S
into
TMP_TV_DOLY_B, TMP_TV_DOLY_S, TMP_TV_NAIM_B,TMP_TV_NAIM_S,
TMP_TV_MASSA_B,TMP_TV_MASSA_S,
TMP_TV_NOTE_B,TMP_TV_NOTE_S
from table(pk_mmk_izms.F_TV (sp_izm.rn_tv,p_RNPS)) IT;


exception when no_data_found then 
--Нету изменений проверим на наличие существующей заг, если есть то было и стало одинаково
Begin
select Tv0.DOLY,Tv0.DOLY, tv0.TVNAIM,tv0.TVNAIM,
          tv0.TVMASSA,tv0.TVMASSA,
          tv0.TVNOTE,tv0.TVNOTE
into 
TMP_TV_DOLY_B, TMP_TV_DOLY_S, TMP_TV_NAIM_B,TMP_TV_NAIM_S,
TMP_TV_MASSA_B,TMP_TV_MASSA_S,
TMP_TV_NOTE_B,TMP_TV_NOTE_S
from
w_ktsg.v0_tv_s TV0 
where tv0.RN_TV = sp_izm.rn_tv;



exception when no_data_found then --Нету ТВ хотя есть РНТВ Гоним Нулы
TMP_TV_DOLY_B:=null; TMP_TV_DOLY_S:=null; TMP_TV_NAIM_B:=null;TMP_TV_NAIM_S:=null;
TMP_TV_MASSA_B:=null;TMP_TV_MASSA_S:=null;
TMP_TV_NOTE_B:=null;TMP_TV_NOTE_S:=null;
end;
end;
end if;

BEGIN
SELECT tv0.ind_nalcomp,tv0.ind_nalcomp, vo.kornaim
INTO TMP_TV_INDCOMPL_B, TMP_TV_INDCOMPL_S, TMP_ISP_VID_KOR
FROM w_ktsg.tb_tv tv0, w_ktsg.tb_isp_ob io, w_ktsg.tb_vid_isp_ob vo
WHERE tv0.RN = sp_izm.rn_tv AND io.rn = tv0.rn_ispob AND vo.rn = io.rn_vid_ispob;

EXCEPTION WHEN no_data_found THEN
TMP_TV_INDCOMPL_B:=NULL;
TMP_TV_INDCOMPL_S:=NULL;
TMP_ISP_VID_KOR:=NULL;
END;



--Изменения по Заготовке
Begin
TMP_MAT_112_B:=null;
TMP_MATNUM_112_B:=null;
TMP_MATEI_112_B:=null;
TMP_MATDAT_112_B:=null;
TMP_MATDATOTP_112_S:=NULL;
TMP_MATDATOTP_112_B:=NULL;

TMP_MAT_112_S:=null;
TMP_MATNUM_112_S:=null;
TMP_MATEI_112_S:=null;
TMP_MATDAT_112_S:=null;
If typ_Doc = 'Р' or typ_doc='С' then
--РАзработка
Select 
ZAG_RN_ISP_B, ZAG_RN_ISP_S, 
ZAG_OBOZN_B , ZAG_OBOZN_S , 
ZAG_EI_B , ZAG_EI_S ,
ZAG_NORMRAZ_B , ZAG_NORMRAZ_S , 
ZAG_VID_ZAG_B ,ZAG_VID_ZAG_S, ZAG_VID_STR_B , ZAG_VID_STR_S ,

ZAG_KOLD_B , ZAG_KOLD_S ,ZAG_VES_B , ZAG_VES_S, 
ZAG_DL_B , ZAG_DL_S ,  ZAG_SH_B , ZAG_SH_S ,
ZAG_NOTE_B , ZAG_NOTE_S       
into
TMP_ZAG_RN_ISP_B,TMP_ZAG_RN_ISP_S,TMP_ZAG_OBOZN_B,
TMP_ZAG_OBOZN_S,TMP_ZAG_EI_B,TMP_ZAG_EI_S ,
TMP_ZAG_NORMRAZ_B,TMP_ZAG_NORMRAZ_S,
TMP_ZAG_VID_ZAG_B ,TMP_ZAG_VID_ZAG_S ,TMP_ZAG_VID_STR_B ,
TMP_ZAG_VID_STR_S , TMP_ZAG_KOLD_B ,TMP_ZAG_KOLD_S ,
TMP_ZAG_VES_B ,TMP_ZAG_VES_S, TMP_ZAG_DL_B ,
TMP_ZAG_DL_S ,TMP_ZAG_SH_B , TMP_ZAG_SH_S ,
TMP_ZAG_NOTE_B ,TMP_ZAG_NOTE_S 
from  Table(f_get_izm_zag(10,p_RNPS,sp_izm.rn_tv,1 )) ;
Else
--Утв
--Утвержденный ПС
Begin
select 
IZ.RN_ISPOB_ZAG_B , IZ.RN_ISPOB_ZAG_S ,izob.OBOZN, izoS.OBOZN,
EZB.KORNAIM, EZS.KORNAIM,
IZ.NORMRASH_B,  IZ.NORMRASH_S ,  IZ.VIDZAG_B,  IZ.VIDZAG_S ,
vzb.naim_vid, vzS.naim_vid, 
 IZ.KOLDETZAG_B, IZ.KOLDETZAG_S,  IZ.VESZAG_B , IZ.VESZAG_S ,
 IZ.GEOMR_DL_B,  IZ.GEOMR_DL_S,  IZ.GEOMR_SH_B ,  IZ.GEOMR_SH_S,
 IZ.TZAGNOTE_B, IZ.TZAGNOTE_S
into 
TMP_ZAG_RN_ISP_B,TMP_ZAG_RN_ISP_S,TMP_ZAG_OBOZN_B, TMP_ZAG_OBOZN_S,
TMP_ZAG_EI_B, TMP_ZAG_EI_S ,
TMP_ZAG_NORMRAZ_B,TMP_ZAG_NORMRAZ_S, TMP_ZAG_VID_ZAG_B ,TMP_ZAG_VID_ZAG_S ,

TMP_ZAG_VID_STR_B , TMP_ZAG_VID_STR_S , 

 TMP_ZAG_KOLD_B ,TMP_ZAG_KOLD_S , TMP_ZAG_VES_B ,TMP_ZAG_VES_S, 
 TMP_ZAG_DL_B , TMP_ZAG_DL_S ,TMP_ZAG_SH_B , TMP_ZAG_SH_S ,
TMP_ZAG_NOTE_B ,TMP_ZAG_NOTE_S 
from table(pk_mmk_izms.F_ZAG(sp_izm.rn_tv  ,p_RNPS )) IZ
left outer join w_ktsg.v0_isp_ob_s izob  on (izob.RN_ISPOB = iz.RN_ISPOB_ZAG_B)
left outer join w_ktsg.v0_isp_ob_s izoS  on (izoS.RN_ISPOB = iz.RN_ISPOB_ZAG_S)
left outer join w_ei.tb_ei EZB on (ezb.rn = IZ.RN_EI_B)
left outer join w_ei.tb_ei EZS on (ezs.rn = IZ.RN_EI_S)
left outer join W_VIDZAG.TB_VID_ZAG VZB on (vzb.id_vid = IZ.VIDZAG_B)
left outer join W_VIDZAG.TB_VID_ZAG VZS on (vzS.id_vid = IZ.VIDZAG_S);
Exception when no_data_found then
--Нету изменений по заготовке - ищем существующую
Select z0.RN_ISPOB_ZAG,z0.RN_ISPOB_ZAG, izob.OBOZN,izob.OBOZN,
ezb.kornaim,ezb.kornaim, 
z0.NORMRASH,z0.NORMRASH,z0.VIDZAG,z0.VIDZAG,
vzb.naim_vid,vzb.naim_vid,
z0.KOLDETZAG,z0.KOLDETZAG, z0.VESZAG,z0.VESZAG, 
z0.GEOMR_DL,z0.GEOMR_DL, z0.GEOMR_SH,z0.GEOMR_SH,
z0.TZAGNOTE,z0.TZAGNOTE
into
TMP_ZAG_RN_ISP_B,TMP_ZAG_RN_ISP_S,TMP_ZAG_OBOZN_B, TMP_ZAG_OBOZN_S,
TMP_ZAG_EI_B, TMP_ZAG_EI_S ,
TMP_ZAG_NORMRAZ_B,TMP_ZAG_NORMRAZ_S, TMP_ZAG_VID_ZAG_B ,TMP_ZAG_VID_ZAG_S ,
TMP_ZAG_VID_STR_B , TMP_ZAG_VID_STR_S , 
TMP_ZAG_KOLD_B ,TMP_ZAG_KOLD_S , TMP_ZAG_VES_B ,TMP_ZAG_VES_S, 
TMP_ZAG_DL_B , TMP_ZAG_DL_S ,TMP_ZAG_SH_B , TMP_ZAG_SH_S ,
TMP_ZAG_NOTE_B ,TMP_ZAG_NOTE_S 
from
W_ktsg.V0_t_Zag_s  Z0
left outer join w_ktsg.v0_isp_ob_s izob  on (izob.RN_ISPOB = z0.RN_ISPOB_ZAG)
left outer join w_ei.tb_ei EZB on (ezb.rn = z0.RN_EI)
left outer join W_VIDZAG.TB_VID_ZAG VZB on (vzb.id_vid = z0.VIDZAG)
where z0.RN_TV = sp_izm.rn_tv;
end;
end if;

If nvl(TMP_ZAG_RN_ISP_B,0)>0 or nvl(TMP_ZAG_RN_ISP_S,0)>0 then
Begin
select w_ktsg.tb_isp_ob.rn_mat
into TMP_ZAG_RN_MAT_B
from w_ktsg.tb_isp_ob 
where w_ktsg.tb_isp_ob.rn = TMP_ZAG_RN_ISP_B;
exception when no_data_found then TMP_ZAG_RN_MAT_B:=null;
end;

Begin
select w_ktsg.tb_isp_ob.rn_mat
into TMP_ZAG_RN_MAT_S
from w_ktsg.tb_isp_ob 
where w_ktsg.tb_isp_ob.rn = TMP_ZAG_RN_ISP_S;
exception when no_data_found then TMP_ZAG_RN_MAT_S:=null;
end;


if nvl(TMP_ZAG_RN_MAT_B,0)>0 then
Begin
select '('||m.nn||')' || m1.name_full, 
t.ost,m.unit,trunc(t.last_pr)   as DAT_POS, trunc(t.last_pr_ceh)
into TMP_MAT_112_B,TMP_MATNUM_112_B,TMP_MATEI_112_B,TMP_MATDAT_112_B,TMP_MATDATOTP_112_B
from 
v_SELECT_MAT m1
LEFT OUTER JOIN w_sprmat.tb_mat_spr m ON (m.rn = m1.RN)
left outer join w_move_mat.tb_for_mmkt t ON (t.rn = m.rn)
--w_sprmat.vw_mat_spr_ex_with_oldnn t on (t.RN = m.rn)
where 
m1.rn = TMP_ZAG_RN_MAT_B and rownum<2;
exception when no_data_found then
TMP_MAT_112_B:=null;
TMP_MATNUM_112_B:=null;
TMP_MATEI_112_B:=null;
TMP_MATDAT_112_B:=null;
TMP_MATDATOTP_112_B:=NULL;
end;
end if;

if nvl(TMP_ZAG_RN_MAT_S,0)>0 then
Begin
select '('||m.nn||')' || m1.name_full, 
t.ost,m.UNIT, trunc(t.last_pr)   as DAT_POS, trunc(t.last_pr_ceh)
into TMP_MAT_112_S,TMP_MATNUM_112_S,TMP_MATEI_112_S,TMP_MATDAT_112_S,TMP_MATDATOTP_112_S
from 
v_SELECT_MAT m1
LEFT OUTER JOIN w_sprmat.tb_mat_spr m ON (m.rn = m1.RN)
left outer JOIN w_move_mat.tb_for_mmkt t ON (t.rn = m.rn)
--left outer join w_sprmat.vw_mat_spr_ex_with_oldnn t on (t.RN = m.rn)
where 
m1.rn = TMP_ZAG_RN_MAT_S and rownum<2;
exception when no_data_found then
TMP_MAT_112_S:=null;
TMP_MATNUM_112_S:=null;
TMP_MATEI_112_S:=null;
TMP_MATDAT_112_S:=null;
TMP_MATDATOTP_112_S:=NULL;
end;
end if;

end if;








exception when no_data_found then 
TMP_ZAG_RN_ISP_B:=null;
TMP_ZAG_RN_ISP_S:=null;
TMP_ZAG_OBOZN_B:=null;
TMP_ZAG_OBOZN_S:=null;
TMP_ZAG_EI_B:=null;
TMP_ZAG_EI_S:=null;
TMP_ZAG_NORMRAZ_B :=null;
TMP_ZAG_NORMRAZ_S:=null;
TMP_ZAG_VID_ZAG_B :=null;
TMP_ZAG_VID_ZAG_S :=null;
TMP_ZAG_VID_STR_B :=null;
TMP_ZAG_VID_STR_S :=null;
TMP_ZAG_KOLD_B :=null;
TMP_ZAG_KOLD_S :=null;
TMP_ZAG_VES_B :=null;
TMP_ZAG_VES_S :=null; 
TMP_ZAG_DL_B :=null;
TMP_ZAG_DL_S :=null;
TMP_ZAG_SH_B :=null;
TMP_ZAG_SH_S :=null;
TMP_ZAG_NOTE_B:=null;
TMP_ZAG_NOTE_S :=null;
TMP_ZAG_RN_MAT_B:=null;
TMP_ZAG_RN_MAT_S:=null;
TMP_MAT_112_S:=null;
TMP_MATNUM_112_S:=null;
TMP_MATEI_112_S:=null;
TMP_MATDAT_112_S:=null;
TMP_MAT_112_B:=null;
TMP_MATNUM_112_B:=null;
TMP_MATEI_112_B:=null;
TMP_MATDAT_112_B:=null;
TMP_MATDATOTP_112_B:=NULL;
TMP_MATDATOTP_112_S:=NULL;
end;
--Изменения в составе
--все позиции которые участвуют в изменении нужно добавить в таблицу,
--Если они не по текущему перечню - то смутить изменения
--(Если текущий документ утвержден то берем только утвержденные состояния)
--Если позиции не правятся - то просто состояние стало по ним
--Так же состояние стало идет при Утвержденном перечне!!!!!

--Состав
If typ_Doc = 'Р' or typ_doc='С' then
--РАзр
For SP_SOST in
(

Select Uii.rn_ispob_ch , tvu.rn,tvu.vi
from
( Select distinct iu.rn_ispob_ch From
(
(
select u1.KOL,u1.IND1_VARIANT,u1.IND2_NEUST,u1.USTCOMPNOTE,u1.RN_ISPOB_CH, p1.RN_PODR,p1.RN_VO, u1.RN_EI_UST
from w_ktsg.v1r_ust_comp_s u1, w_ktsg.v1_poz_mo_s p1
where u1.RN_TV = sp_izm.rn_tv and p1.RN_POZMO = u1.RN_POZMO
Minus
select u0.KOL,u0.IND1_VARIANT,u0.IND2_NEUST,u0.USTCOMPNOTE,u0.RN_ISPOB_CH, p0.RN_PODR,p0.RN_VO, u0.RN_EI_UST
from w_ktsg.v0_ust_comp_s u0, w_ktsg.v0_poz_mo_s p0
where u0.RN_TV = sp_izm.rn_tv and p0.RN_POZMO = u0.RN_POZMO
)
Union all
(
select u00.KOL,u00.IND1_VARIANT,u00.IND2_NEUST,u00.USTCOMPNOTE,u00.RN_ISPOB_CH, p00.RN_PODR,p00.RN_VO,u00.RN_EI_UST
from w_ktsg.v0_ust_comp_s u00, w_ktsg.v0_poz_mo_s p00
where u00.RN_TV = sp_izm.rn_tv and p00.RN_POZMO = u00.RN_POZMO
Minus
select u11.KOL,u11.IND1_VARIANT,u11.IND2_NEUST,u11.USTCOMPNOTE,u11.RN_ISPOB_CH, p11.RN_PODR,p11.RN_VO,u11.RN_EI_UST
from w_ktsg.v1r_ust_comp_s u11, w_ktsg.v1_poz_mo_s p11
where u11.RN_TV = sp_izm.rn_tv and p11.RN_POZMO = u11.RN_POZMO
) 
)IU )Uii
left outer join  w_ktsg.tb_tv tvu on (tvu.rn_ispob = uii.rn_ispob_ch)
where not exists (select im.sid from  tb_sp_izm_mmk im where im.rn_isp = uii.rn_ispob_ch and im.sid=t_sid)
)
Loop
--Заносим в таблицу - потмо изменения по ним если есть достанем
insert into tb_sp_izm_mmk
(sid,rn_isp,  Rn_ps , rn_tv,vi, typ_dce)
values(t_sid,sp_sost.rn_ispob_ch,  p_RNPS, nvl(sp_sost.rn,0),nvl(sp_sost.vi,'00'), -1); --Тип ДСЕ = -1 дял следующего прохода для определения изменений!!!
End Loop;
Else
--Утв
For SP_SOST in
(
Select  Distinct ui.RN_ISPOB_CH, ut.rn, ut.vi 
from table(pk_mmk_izms.F_SOSTAV_MO(sp_izm.rn_tv ,p_RNPS )) UI
left outer join w_ktsg.tb_tv UT on (UT.RN_ISPOB = ui.RN_ISPOB_CH )
left outer join w_ktsg.tb_tv_s UTS on (uts.rn_tv = ut.rn)
where not (exists (select im.sid from  tb_sp_izm_mmk im where im.rn_isp = ui.RN_ISPOB_CH  and im.sid=t_sid))
and (not (not (ut.rn is null ) and (uts.att_arid is null )))
)
Loop
insert into tb_sp_izm_mmk
(sid,rn_isp,  Rn_ps , rn_tv,vi, typ_dce)
values(t_sid, sp_sost.rn_ispob_ch,  p_RNPS,  nvl(sp_sost.rn,0), nvl(sp_sost.vi,'00'),     -1); --Тип ДСЕ = -1 дял следующего прохода для определения изменений!!!
End loop;

--Заносим в таблицу применяемости изменения в составе!!!!
W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');

Insert into tb_sp_izm_prim
Select
t_sid, nvl(tv.rn,0), UI.RN_ISPOB_CH, 0, sp_izm.rn_tv,sp_izm.rn_isp,TMP_ISP_OBOZN_S ,
UI.kol_b,UI.kol_S,eib.kornaim,eis.kornaim,
pb.kornaim,ps.kornaim, null,null, 
vb.kornaim,vs.kornaim,  UI.USTCOMPNOTE_b,UI.USTCOMPNOTE_S, null,null,null,null,null,null
from table(CAST(pk_mmk_izms.F_SOSTAV_MO(sp_izm.rn_tv ,p_RNPS ) AS T_TB_IZMS_UST )) UI
 left outer join w_ktsg.tb_tv tv on (tv.rn_ispob = UI.RN_ISPOB_CH)
     left outer join w_ei.tb_ei eib ON (eib.rn = UI.RN_EI_UST_b)
     left outer join w_ei.tb_ei eis ON (eis.rn = UI.RN_EI_UST_s)
left outer join w_MP.Tb_Podr PB ON (pb.rn = UI.RNPODR_B)
left outer join w_MP.Tb_Podr PS ON (ps.rn = UI.RNPODR_S)
    left outer join w_vo.tb_vo vB ON (vb.rn = UI.RNVO_B)
    left outer join w_vo.tb_vo vS ON (vs.rn = UI.RNVO_S)
;


End if;



--Теперь вставляем ДСЕ которые сидят как заготовки
--Если идет смена ДСЕ не материала в заготовке то 
If typ_Doc = 'Р' or typ_doc='С' then
--РАзр
For SP_ZAG in
(
Select distinct RN_ISPOB_ZAG, rn,vi
from
(
(select z1.RN_ISPOB_ZAG, nvl(zt1.rn,0) AS RN,nvl(zt1.vi,'XX') AS vi
from w_ktsg.v1r_t_zag_s Z1
LEFT OUTER JOIN w_ktsg.tb_tv zt1 ON (zt1.rn_ispob = z1.RN_ISPOB_ZAG), 
w_ktsg.tb_isp_ob zi1, w_ktsg.v0_isp_ob_s zio
where z1.RN_TV = sp_izm.rn_tv and zi1.rn = z1.RN_ISPOB_ZAG  /*AND zi1.rn_vid_ispob <> 1005*/ AND zio.RN_ISPOB = z1.RN_ISPOB_ZAG
--AND zio.TIP_ISPOB<>'П' --and zi1.rn_mat is null
Minus
select z0.RN_ISPOB_ZAG, nvl(zt0.rn,0) AS RN , nvl(zt0.vi,'XX') AS vi
from w_ktsg.v0_t_zag_s Z0
LEFT OUTER JOIN w_ktsg.tb_tv zt0 ON (zt0.rn_ispob = z0.RN_ISPOB_ZAG)
, w_ktsg.tb_isp_ob zi0, w_ktsg.v0_isp_ob_s zio0
where z0.RN_TV = sp_izm.rn_tv  and zi0.rn = z0.RN_ISPOB_ZAG /*and zi0.rn_vid_ispob<>1005*/ AND zio0.RN_ISPOB = z0.RN_ISPOB_ZAG --AND zio0.TIP_ISPOB<>'П'
)
Union all
(select z00.RN_ISPOB_ZAG, nvl(zt00.rn,0) AS RN, nvl(zt00.vi,'XX') AS VI
from w_ktsg.v0_t_zag_s Z00 
LEFT OUTER JOIN w_ktsg.tb_tv zt00 ON (zt00.rn_ispob = z00.RN_ISPOB_ZAG)
, w_ktsg.tb_isp_ob zi00, w_ktsg.v0_isp_ob_s zio00
where z00.RN_TV = sp_izm.rn_tv  and zi00.rn = z00.RN_ISPOB_ZAG --and zi00.rn_mat is null
/*AND zi00.rn_vid_ispob<>1005*/ AND zio00.RN_ISPOB = z00.RN_ISPOB_ZAG --AND zio00.TIP_ISPOB<>'П'
Minus
select z11.RN_ISPOB_ZAG, nvl(zt11.rn,0) AS RN, nvl(zt11.vi,'XX') AS VI
from w_ktsg.v1r_t_zag_s Z11
LEFT OUTER JOIN  w_ktsg.tb_tv zt11 ON (zt11.rn_ispob = z11.RN_ISPOB_ZAG)
, w_ktsg.tb_isp_ob zi11, w_ktsg.v0_isp_ob_s zio11
where z11.RN_TV = sp_izm.rn_tv  and zi11.rn = z11.RN_ISPOB_ZAG 
/*AND zi11.rn_vid_ispob<>1005*/ AND zio11.RN_ISPOB = z11.RN_ISPOB_ZAG --AND zio11.TIP_ISPOB<>'П'
)
) 
where not exists (select im.sid from  tb_sp_izm_mmk im where im.rn_isp =RN_ISPOB_ZAG  and im.sid=t_sid)
)
Loop
insert into tb_sp_izm_mmk
(sid,rn_isp,  Rn_ps , rn_tv,vi, typ_dce)
values(t_sid,sp_zag.rn_ispob_zag,  p_RNPS, sp_zag.rn,sp_zag.vi, -1); --Тип ДСЕ = -1 дял следующего прохода для определения изменений!!!
End loop;
--Утв
else
For SP_ZAG in
(
Select QQ.RN_ISPOB_ZAG_B, nvl(qtv.vi,'XX') AS VI, nvl(qtv.rn,0) AS RN
from
(
  Select RN_ISPOB_ZAG_B  from table(pk_mmk_izms.F_ZAG(sp_izm.rn_tv ,p_RNPS  ))  
  minus
  Select RN_ISPOB_ZAG_S  from table(pk_mmk_izms.F_ZAG(sp_izm.rn_tv ,p_RNPS  ))
Union all
  Select RN_ISPOB_ZAG_S  from table(pk_mmk_izms.F_ZAG(sp_izm.rn_tv ,p_RNPS  ))  
  minus
  Select RN_ISPOB_ZAG_B  from table(pk_mmk_izms.F_ZAG(sp_izm.rn_tv ,p_RNPS  ))
) QQ, w_ktsg.tb_tv qtv, w_ktsg.tb_isp_ob qis
where qtv.rn_ispob = QQ.RN_ISPOB_ZAG_B and qis.rn = QQ.RN_ISPOB_ZAG_B --and qis.rn_mat is null
and not exists (select im.sid from  tb_sp_izm_mmk im where im.rn_isp =QQ.RN_ISPOB_ZAG_B  and im.sid=t_sid)
)
Loop
insert into tb_sp_izm_mmk
(sid,rn_isp,  Rn_ps , rn_tv,vi, typ_dce)
values(t_sid,sp_zag.RN_ISPOB_ZAG_B,  p_RNPS, sp_zag.rn,sp_zag.vi, -1); --Тип ДСЕ = -1 дял следующего прохода для определения изменений!!!
end loop;

--Теперь по заготовке вставка в изменение применяемости
--Select from table(pk_mmk_izms.F_ZAG(sp_izm.rn_tv ,p_RNPS  ))
--from 
--Пока заготовку пропускаем
end if;

--Теперь Образцы, вывелись или введись или изменились!!!!
If typ_Doc = 'Р' or typ_doc='С' then
For SP_OBR in
(
Select distinct rn_ispob, RN_tv_obr as RN, VI
from
(
(Select o1.RN_TV_OBR,o1.RN_TV_IZG, o1.RN_PODR_ISP,o1.RN_PODR_INITTD,o1.TEHNKOL,o1.MAXPART,o1.INFOBRNOTE,
otv1.rn_ispob,otv1.vi,mo1.rn_vo,mo1.rn_podr
from w_ktsg.v1r_obr_s o1, w_ktsg.tb_tv otv1, w_ktsg.tb_poz_mo_s mo1
where o1.RN_TV_IZG = sp_izm.rn_tv and otv1.rn = o1.RN_TV_OBR and mo1.att_arid = o1.ARID_POZMO
Minus
Select o0.RN_TV_OBR,o0.RN_TV_IZG, o0.RN_PODR_ISP,o0.RN_PODR_INITTD,o0.TEHNKOL,o0.MAXPART,o0.INFOBRNOTE,
otv0.rn_ispob,otv0.vi,mo0.rn_vo,mo0.rn_podr
from w_ktsg.v0_obr_s o0, w_ktsg.tb_tv otv0, w_ktsg.tb_poz_mo_s mo0
where o0.RN_TV_IZG = sp_izm.rn_tv and otv0.rn = o0.RN_TV_OBR and mo0.att_arid = o0.ARID_POZMO
)
Union all
(Select o00.RN_TV_OBR,o00.RN_TV_IZG, o00.RN_PODR_ISP,o00.RN_PODR_INITTD,o00.TEHNKOL,o00.MAXPART,o00.INFOBRNOTE,
otv00.rn_ispob,otv00.vi,mo00.rn_vo,mo00.rn_podr
from w_ktsg.v0_obr_s o00, w_ktsg.tb_tv otv00, w_ktsg.tb_poz_mo_s mo00
where o00.RN_TV_IZG = sp_izm.rn_tv and otv00.rn = o00.RN_TV_OBR and mo00.att_arid = o00.ARID_POZMO
Minus
Select o11.RN_TV_OBR,o11.RN_TV_IZG, o11.RN_PODR_ISP,o11.RN_PODR_INITTD,o11.TEHNKOL,o11.MAXPART,o11.INFOBRNOTE,
otv11.rn_ispob,otv11.vi,mo11.rn_vo,mo11.rn_podr
from w_ktsg.v1r_obr_s o11, w_ktsg.tb_tv otv11, w_ktsg.tb_poz_mo_s mo11
where o11.RN_TV_IZG = sp_izm.rn_tv and otv11.rn = o11.RN_TV_OBR and mo11.att_arid = o11.ARID_POZMO
)
Union all
(Select ob1.RN_TV_OBR,ob1.RN_TV_IZG, ob1.RN_PODR_ISP,ob1.RN_PODR_INITTD,ob1.TEHNKOL,ob1.MAXPART,ob1.INFOBRNOTE,
tv1.rn_ispob,tv1.vi,p1.RN_VO, p1.RN_PODR
from w_ktsg.v1_poz_mo_s p1, w_ktsg.v1r_obr_s ob1, w_ktsg.tb_tv tv1
where p1.RN_TV = sp_izm.rn_tv and ob1.ARID_POZMO = p1.att_ARID and tv1.rn = ob1.RN_TV_OBR
Minus
Select ob0.RN_TV_OBR,ob0.RN_TV_IZG, ob0.RN_PODR_ISP,ob0.RN_PODR_INITTD,ob0.TEHNKOL,ob0.MAXPART,ob0.INFOBRNOTE,
tv0.rn_ispob, tv0.vi,p0.RN_VO, p0.RN_PODR
from w_ktsg.v0_poz_mo_s p0, w_ktsg.v0_obr_s ob0, w_ktsg.tb_tv tv0
where p0.RN_TV = sp_izm.rn_tv and ob0.ARID_POZMO = p0.att_ARID and tv0.rn = ob0.RN_TV_OBR
)
Union all
(Select ob00.RN_TV_OBR,ob00.RN_TV_IZG, ob00.RN_PODR_ISP,ob00.RN_PODR_INITTD,ob00.TEHNKOL,ob00.MAXPART,ob00.INFOBRNOTE,
tv00.rn_ispob,tv00.vi,p00.RN_VO, p00.RN_PODR
from w_ktsg.v0_poz_mo_s p00, w_ktsg.v0_obr_s ob00, w_ktsg.tb_tv tv00
where p00.RN_TV = sp_izm.rn_tv and ob00.ARID_POZMO = p00.att_ARID and tv00.rn = ob00.RN_TV_OBR
Minus
Select ob11.RN_TV_OBR,ob11.RN_TV_IZG, ob11.RN_PODR_ISP,ob11.RN_PODR_INITTD,ob11.TEHNKOL,ob11.MAXPART,ob11.INFOBRNOTE,
tv11.rn_ispob,tv11.vi,p11.RN_VO, p11.RN_PODR
from w_ktsg.v1_poz_mo_s p11, w_ktsg.v1r_obr_s ob11, w_ktsg.tb_tv tv11
where p11.RN_TV = sp_izm.rn_tv and ob11.ARID_POZMO = p11.att_ARID and tv11.rn = ob11.RN_TV_OBR
)
) OBR
where not exists (select im.sid from  tb_sp_izm_mmk im where im.rn_isp =Obr.rn_ispob  and im.sid=t_sid) 
)
Loop
insert into tb_sp_izm_mmk
           (sid,  rn_isp,                  Rn_ps ,     rn_tv,      vi, typ_dce)
values(t_sid,sp_obr.rn_ispob , p_RNPS, sp_obr.rn,sp_obr.vi, -1); --Тип ДСЕ = -1 дял следующего прохода для определения изменений!!!

End loop;
else
--Утв
For SP_OBR in
(
select distinct iobr.RN_TV_OBR as RN, otv.rn_ispob, otv.vi
from table (pk_mmk_izms.F_OBR(sp_izm.rn_tv,p_RNPS ) )iobr
 left outer join w_ktsg.tb_tv otv on (otv.rn = iobr.RN_TV_OBR)
where not exists (select im.sid from  tb_sp_izm_mmk im where im.rn_isp =otv.rn_ispob  and im.sid=t_sid) 
)
Loop
insert into tb_sp_izm_mmk
           (sid,  rn_isp,                  Rn_ps ,     rn_tv,      vi, typ_dce)
values(t_sid,sp_obr.rn_ispob , p_RNPS, sp_obr.rn,sp_obr.vi, -1); --Тип ДСЕ = -1 дял следующего прохода для определения изменений!!!
end loop;
--Вставка в таблицу применяемости


Insert into tb_sp_izm_prim
Select --+ First_Rows
t_sid, iobr.RN_TV_OBR, otv.rn_ispob, 2, sp_izm.rn_tv,sp_izm.rn_isp, TMP_ISP_OBOZN_S,
iobr.TEHNKOL_b,iobr.TEHNKOL_S, null, null,  pz.kornaim,pz.kornaim, --iz.OBOZN, iz.OBOZN,
(SELECT iz1.OBOZN FROM w_ktsg.v0_isp_ob_s iz1 WHERE iz1.RN_ISPOB = tvz.rn_ispob),
(SELECT iz1.OBOZN FROM w_ktsg.v0_isp_ob_s iz1 WHERE iz1.RN_ISPOB = tvz.rn_ispob),

vz.kornaim,vz.kornaim,
iobr.INFOBRNOTE_b,iobr.INFOBRNOTE_S, iobr.MAXPART_b,iobr.MAXPART_s,
pib.kornaim,pis.kornaim, pisb.kornaim,piss.kornaim
from table(CAST (pk_mmk_izms.F_OBR(sp_izm.rn_tv,p_RNPS )  AS T_TB_IZMS_OBR )  ) iobr
 LEFT OUTER JOIN w_mp.tb_podr PIB ON (pib.rn = iobr.RN_PODR_INITTD_B)
 LEFT OUTER JOIN w_mp.tb_podr PIS ON (pis.rn = iobr.RN_PODR_INITTD_S)
 LEFT OUTER JOIN w_mp.tb_podr PISB ON (pisb.rn = iobr.RN_PODR_ISP_B)
 LEFT OUTER JOIN w_mp.tb_podr PISS ON (piss.rn = iobr.RN_PODR_ISP_S)
 LEFT OUTER JOIN w_mp.tb_podr PZ ON (pz.rn = iobr.rn_podr)
 LEFT OUTER JOIN w_vo.tb_vo vz ON (vz.rn = iobr.rn_vo),
 w_ktsg.tb_tv otv , w_ktsg.tb_poz_mo_s MOS, w_ktsg.tb_tv tvz--, w_ktsg.v0_isp_ob_s iz
where otv.rn = iobr.RN_TV_OBR 
    and MOS.ATT_ARID = iobr.ARID_POZMO
    and tvz.rn = mos.rn_tv;-- and iz.RN_ISPOB = tvz.rn_ispob;
end if;

--Обновляем данные в таблице - по изменениям
update tb_sp_izm_mmk ii
   set obozn_b = TMP_ISP_OBOZN_B,  obozn_s = TMP_ISP_OBOZN_S,
        name_b = TMP_TV_NAIM_B,  name_s = TMP_TV_NAIM_S,
       spr_b = f_get_tv_spr_new(TMP_ISP_VID_KOR ,TMP_ISP_TIP_B ,TMP_TV_INDCOMPL_B ,sp_izm.rn_tv ),
       spr_s = f_get_tv_spr_new(TMP_ISP_VID_KOR ,TMP_ISP_TIP_S ,TMP_TV_INDCOMPL_S ,sp_izm.rn_tv ),
ii.typ_dce_b = TMP_ISP_TIP_B,
ii.typ_dce_S = TMP_ISP_TIP_S,

--       str_obr_b = v_str_obr_b,
--       str_obr_s = v_str_obr_s,
--       if_izm_mo = v_if_izm_mo,
--       if_izm_vhod = v_if_izm_vhod,
--       if_izm_obr = v_if_izm_obr,
--       if_izm_zag = v_if_izm_zag,
       dce_zag_b = TMP_ZAG_OBOZN_B, dce_zag_s = TMP_ZAG_OBOZN_S,
       ves_dce_b = TMP_TV_MASSA_B,   ves_dce_s = TMP_TV_MASSA_S,
       ves_zag_b = TMP_ZAG_VES_B,     ves_zag_s =TMP_ZAG_VES_S,
       nrm_ras_b = TMP_ZAG_NORMRAZ_B, nrm_ras_s = TMP_ZAG_NORMRAZ_S,
       edizmzag_b = TMP_ZAG_EI_B,  edizmzag_s = TMP_ZAG_EI_S,
       kol_det_b = TMP_ZAG_KOLD_B,  kol_det_s = TMP_ZAG_KOLD_S,
      zdl_b = TMP_ZAG_DL_B, zdl_s = TMP_ZAG_DL_S, zsh_b = TMP_ZAG_SH_B, zsh_s = TMP_ZAG_SH_S,
       vid_zagkod_b = TMP_ZAG_VID_ZAG_B,   vid_zagkod_s = TMP_ZAG_VID_ZAG_S,
       vid_zagstr_b = TMP_ZAG_VID_STR_B,     vid_zagstr_s =TMP_ZAG_VID_STR_S,
       zag_prim_b = TMP_ZAG_NOTE_B,        zag_prim_s = TMP_ZAG_NOTE_S,
       tv_prim_b = TMP_TV_NOTE_B,    tv_prim_s = TMP_TV_NOTE_S,
       tv_doly_b = TMP_TV_DOLY_B,       
       -- is_izg = v_is_izg,
       tv_doly_s = TMP_TV_DOLY_S,
       zrn_b = TMP_ZAG_RN_ISP_B,
       zrn_s = TMP_ZAG_RN_ISP_S,
       ii.mat_b = TMP_MAT_112_B, ii.mat_s = TMP_MAT_112_S, ii.mat_ost_b = TMP_MATNUM_112_B, ii.mat_ost_s = TMP_MATNUM_112_S,
       ii.mat_dat_post_b = TMP_MATDAT_112_B ,ii.mat_dat_post_s = TMP_MATDAT_112_S, ii.mat_ei_b =TMP_MATEI_112_B ,ii.mat_ei_s=TMP_MATEI_112_S,
       ii.mat_otp_b = TMP_MATDATOTP_112_B, ii.mat_otp_s = TMP_MATDATOTP_112_S
 where ii.sid=t_sid and ii.rn_tv = sp_izm.rn_tv ;

W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');
end loop;

--Теперь проход по добавленным ДСЕ (Тип = -1)
--Всовываем изменения если изменений не было то вставляем в СТАЛО
For sp_dob in
( select izm.rn_isp,izm.rn_tv,izm.vi,izm.typ_dce
from tb_sp_izm_mmk izm
where izm.sid = t_sid and izm.typ_dce = -1
)
Loop
TMP_RN_PS:=null;
TMP_PS_USE :=null;

If typ_Doc = 'Р' or typ_doc='С' then
Begin
Select ps.rn, ps.nomizm  
into 
TMP_RN_PS, TMP_PS_USE
from w_ktsg.tb_izm_tv itv, w_ktsg.tb_per_sogl ps
where itv.rn_tv = sp_dob.rn_tv and ps.rn = itv.rn_persogl and ps.ind_stexist in ('Р', 'С');
TMP_PS_USE:='разр. в док. '||TMP_PS_USE;

exception when no_data_found then
TMP_RN_PS:=null;
TMP_PS_USE:=null;
end;
else
TMP_RN_PS:=null;
TMP_PS_USE:=null;
end if;



--Определение было стало для ИСПОБА
--Поидее нать делать от ПС если он есть в котором затронуто
If typ_Doc = 'Р' or typ_doc='С' then
Select  
ISP_OBOZN_B , ISP_OBOZN_S ,
ISP_TIP_B, ISP_TIP_S,
ISP_VID, ISP_VID_TXT , ISP_IZG  
into 
TMP_ISP_OBOZN_B,TMP_ISP_OBOZN_S,
TMP_ISP_TIP_B,TMP_ISP_TIP_S,
TMP_ISP_VID,TMP_ISP_VID_TXT,TMP_ISP_IZG
from table(f_get_izm_isp( 10,TMP_RN_PS , sp_dob.rn_isp ))  ;
else
Select  
ISP_OBOZN_B , ISP_OBOZN_S ,
ISP_TIP_B, ISP_TIP_S,
ISP_VID, ISP_VID_TXT , ISP_IZG  
into 
TMP_ISP_OBOZN_B,TMP_ISP_OBOZN_S,
TMP_ISP_TIP_B,TMP_ISP_TIP_S,
TMP_ISP_VID,TMP_ISP_VID_TXT,TMP_ISP_IZG
from table(f_get_izm_isp( 10,-1 , sp_dob.rn_isp ))  ;
end if;



TMP_TV_DOLY_B:=null; TMP_TV_DOLY_S:=null; TMP_TV_NAIM_B:=null;TMP_TV_NAIM_S:=null;
TMP_TV_MASSA_B:=null;TMP_TV_MASSA_S:=null;
TMP_TV_NOTE_B:=null;TMP_TV_NOTE_S:=null;

TMP_ZAG_RN_ISP_B:=null;
TMP_ZAG_RN_ISP_S:=null;
TMP_ZAG_OBOZN_B:=null;
TMP_ZAG_OBOZN_S:=null;
TMP_ZAG_EI_B:=null;
TMP_ZAG_EI_S:=null;
TMP_ZAG_NORMRAZ_B :=null;
TMP_ZAG_NORMRAZ_S:=null;
TMP_ZAG_VID_ZAG_B :=null;
TMP_ZAG_VID_ZAG_S :=null;
TMP_ZAG_VID_STR_B :=null;
TMP_ZAG_VID_STR_S :=null;
TMP_ZAG_KOLD_B :=null;
TMP_ZAG_KOLD_S :=null;
TMP_ZAG_VES_B :=null;
TMP_ZAG_VES_S :=null; 
TMP_ZAG_DL_B :=null;
TMP_ZAG_DL_S :=null;
TMP_ZAG_SH_B :=null;
TMP_ZAG_SH_S :=null;
TMP_ZAG_NOTE_B:=null;
TMP_ZAG_NOTE_S :=null;
TMP_MAT_112_B:=null;
TMP_MATNUM_112_B:=null;
TMP_MATEI_112_B:=null;
TMP_MATDAT_112_B:=null;
TMP_MAT_112_S:=null;
TMP_MATNUM_112_S:=null;
TMP_MATEI_112_S:=null;
TMP_MATDAT_112_S:=null;
TMP_MATDATOTP_112_B:=NULL;
TMP_MATDATOTP_112_S:=NULL;

W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');

--Переделаем дату так функция ее меняет на дату ПС
--НАм же желательно бесконечная дата для представлений НЕ ПО ТЕКУЩЕМУ ПС!!!
--Изменения по ТВ
If sp_dob.rn_tv>0 then
--dbms_output.put_line(sp_dob.rn_tv);

If typ_Doc = 'Р' or typ_doc='С' then
begin
Select
TV_DOLY_B , TV_DOLY_S , TV_NAIM_B, TV_NAIM_S , TV_MASSA_B, TV_MASSA_S ,
TV_NOTE_B, TV_NOTE_S 
into 
TMP_TV_DOLY_B, TMP_TV_DOLY_S, TMP_TV_NAIM_B,TMP_TV_NAIM_S,
TMP_TV_MASSA_B,TMP_TV_MASSA_S,
TMP_TV_NOTE_B,TMP_TV_NOTE_S
from table(f_get_izm_tv(10 , TMP_RN_PS , sp_Dob.rn_tv ));
exception when no_data_found then
TMP_TV_DOLY_B:=null;TMP_TV_DOLY_S :=null; TMP_TV_NAIM_B:=null;
 TMP_TV_NAIM_S :=null; TMP_TV_MASSA_B:=null; TMP_TV_MASSA_S :=null;
TMP_TV_NOTE_B:=null; TMP_TV_NOTE_S :=null;
end;
else
begin
Select
t0.DOLY,t0.DOLY, t0.TVNAIM, t0.TVNAIM, t0.TVMASSA,t0.TVMASSA,
t0.TVNOTE,t0.TVNOTE
into
TMP_TV_DOLY_B, TMP_TV_DOLY_S, TMP_TV_NAIM_B,TMP_TV_NAIM_S,
TMP_TV_MASSA_B,TMP_TV_MASSA_S,
TMP_TV_NOTE_B,TMP_TV_NOTE_S
from w_ktsg.v0_tv_s t0
where t0.RN_TV = sp_Dob.rn_tv;
exception when no_data_found then
TMP_TV_DOLY_B:=null;TMP_TV_DOLY_S :=null; TMP_TV_NAIM_B:=null;
 TMP_TV_NAIM_S :=null; TMP_TV_MASSA_B:=null; TMP_TV_MASSA_S :=null;
TMP_TV_NOTE_B:=null; TMP_TV_NOTE_S :=null;
end;
End if;

--Изменения по Заготовке
Begin

If typ_Doc = 'Р' or typ_doc='С' then
Select 
ZAG_RN_ISP_B, ZAG_RN_ISP_S, 
ZAG_OBOZN_B , ZAG_OBOZN_S , 
ZAG_EI_B , ZAG_EI_S ,
ZAG_NORMRAZ_B , ZAG_NORMRAZ_S , 
ZAG_VID_ZAG_B ,ZAG_VID_ZAG_S, ZAG_VID_STR_B , ZAG_VID_STR_S ,

ZAG_KOLD_B , ZAG_KOLD_S ,ZAG_VES_B , ZAG_VES_S, 
ZAG_DL_B , ZAG_DL_S ,  ZAG_SH_B , ZAG_SH_S ,
ZAG_NOTE_B , ZAG_NOTE_S       
into
TMP_ZAG_RN_ISP_B,TMP_ZAG_RN_ISP_S,TMP_ZAG_OBOZN_B,
TMP_ZAG_OBOZN_S
,TMP_ZAG_EI_B,TMP_ZAG_EI_S ,
TMP_ZAG_NORMRAZ_B,TMP_ZAG_NORMRAZ_S,
TMP_ZAG_VID_ZAG_B ,TMP_ZAG_VID_ZAG_S ,TMP_ZAG_VID_STR_B ,
TMP_ZAG_VID_STR_S , TMP_ZAG_KOLD_B ,TMP_ZAG_KOLD_S ,
TMP_ZAG_VES_B ,TMP_ZAG_VES_S, TMP_ZAG_DL_B ,
TMP_ZAG_DL_S ,TMP_ZAG_SH_B , TMP_ZAG_SH_S ,
TMP_ZAG_NOTE_B ,TMP_ZAG_NOTE_S 
from  Table(f_get_izm_zag(10,TMP_RN_PS,sp_Dob.rn_tv, 1 )) ;
else

--Утв
--Утвержденный ПС
Begin
select 
IZ.RN_ISPOB_ZAG_B , IZ.RN_ISPOB_ZAG_S ,izob.OBOZN, izoS.OBOZN,
EZB.KORNAIM, EZS.KORNAIM,
IZ.NORMRASH_B,  IZ.NORMRASH_S ,  IZ.VIDZAG_B,  IZ.VIDZAG_S ,
vzb.naim_vid, vzS.naim_vid, 
 IZ.KOLDETZAG_B, IZ.KOLDETZAG_S,  IZ.VESZAG_B , IZ.VESZAG_S ,
 IZ.GEOMR_DL_B,  IZ.GEOMR_DL_S,  IZ.GEOMR_SH_B ,  IZ.GEOMR_SH_S,
 IZ.TZAGNOTE_B, IZ.TZAGNOTE_S
into 
TMP_ZAG_RN_ISP_B,TMP_ZAG_RN_ISP_S,TMP_ZAG_OBOZN_B, TMP_ZAG_OBOZN_S,
TMP_ZAG_EI_B, TMP_ZAG_EI_S ,
TMP_ZAG_NORMRAZ_B,TMP_ZAG_NORMRAZ_S, TMP_ZAG_VID_ZAG_B ,TMP_ZAG_VID_ZAG_S ,

TMP_ZAG_VID_STR_B , TMP_ZAG_VID_STR_S , 

 TMP_ZAG_KOLD_B ,TMP_ZAG_KOLD_S , TMP_ZAG_VES_B ,TMP_ZAG_VES_S, 
 TMP_ZAG_DL_B , TMP_ZAG_DL_S ,TMP_ZAG_SH_B , TMP_ZAG_SH_S ,
TMP_ZAG_NOTE_B ,TMP_ZAG_NOTE_S 
from table(pk_mmk_izms.F_ZAG(sp_Dob.rn_tv  ,p_RNPS )) IZ
left outer join w_ktsg.v0_isp_ob_s izob  on (izob.RN_ISPOB = iz.RN_ISPOB_ZAG_B)
left outer join w_ktsg.v0_isp_ob_s izoS  on (izoS.RN_ISPOB = iz.RN_ISPOB_ZAG_S)
left outer join w_ei.tb_ei EZB on (ezb.rn = IZ.RN_EI_B)
left outer join w_ei.tb_ei EZS on (ezs.rn = IZ.RN_EI_S)
left outer join W_VIDZAG.TB_VID_ZAG VZB on (vzb.id_vid = IZ.VIDZAG_B)
left outer join W_VIDZAG.TB_VID_ZAG VZS on (vzS.id_vid = IZ.VIDZAG_S);
Exception when no_data_found then
--Нету изменений по заготовке - ищем существующую
Select z0.RN_ISPOB_ZAG,z0.RN_ISPOB_ZAG, izob.OBOZN,izob.OBOZN,
ezb.kornaim,ezb.kornaim, 
z0.NORMRASH,z0.NORMRASH,z0.VIDZAG,z0.VIDZAG,
vzb.naim_vid,vzb.naim_vid,
z0.KOLDETZAG,z0.KOLDETZAG, z0.VESZAG,z0.VESZAG, 
z0.GEOMR_DL,z0.GEOMR_DL, z0.GEOMR_SH,z0.GEOMR_SH,
z0.TZAGNOTE,z0.TZAGNOTE
into
TMP_ZAG_RN_ISP_B,TMP_ZAG_RN_ISP_S,TMP_ZAG_OBOZN_B, TMP_ZAG_OBOZN_S,
TMP_ZAG_EI_B, TMP_ZAG_EI_S ,
TMP_ZAG_NORMRAZ_B,TMP_ZAG_NORMRAZ_S, TMP_ZAG_VID_ZAG_B ,TMP_ZAG_VID_ZAG_S ,
TMP_ZAG_VID_STR_B , TMP_ZAG_VID_STR_S , 
TMP_ZAG_KOLD_B ,TMP_ZAG_KOLD_S , TMP_ZAG_VES_B ,TMP_ZAG_VES_S, 
TMP_ZAG_DL_B , TMP_ZAG_DL_S ,TMP_ZAG_SH_B , TMP_ZAG_SH_S ,
TMP_ZAG_NOTE_B ,TMP_ZAG_NOTE_S 
from
W_ktsg.V0_t_Zag_s  Z0
left outer join w_ktsg.v0_isp_ob_s izob  on (izob.RN_ISPOB = z0.RN_ISPOB_ZAG)
left outer join w_ei.tb_ei EZB on (ezb.rn = z0.RN_EI)
left outer join W_VIDZAG.TB_VID_ZAG VZB on (vzb.id_vid = z0.VIDZAG)
where z0.RN_TV = sp_Dob.rn_tv;
end;
end if;



If nvl(TMP_ZAG_RN_ISP_B,0)>0 or nvl(TMP_ZAG_RN_ISP_S,0)>0 then
Begin
select w_ktsg.tb_isp_ob.rn_mat
into TMP_ZAG_RN_MAT_B
from w_ktsg.tb_isp_ob 
where w_ktsg.tb_isp_ob.rn = TMP_ZAG_RN_ISP_B;
exception when no_data_found then TMP_ZAG_RN_MAT_B:=null;
end;

Begin
select w_ktsg.tb_isp_ob.rn_mat
into TMP_ZAG_RN_MAT_S
from w_ktsg.tb_isp_ob 
where w_ktsg.tb_isp_ob.rn = TMP_ZAG_RN_ISP_S;
exception when no_data_found then TMP_ZAG_RN_MAT_S:=null;
end;


if nvl(TMP_ZAG_RN_MAT_B,0)>0 then
Begin
select '('||m.nn||')' || m1.name_full, 
t.ost,m.UNIT, trunc(t.last_pr)   as DAT_POS, trunc(t.last_pr_ceh)
into TMP_MAT_112_B,TMP_MATNUM_112_B,TMP_MATEI_112_B,TMP_MATDAT_112_B, TMP_MATDATOTP_112_B
from 
v_SELECT_MAT m1
LEFT OUTER JOIN w_sprmat.tb_mat_spr m ON (m.rn = m1.RN)
left outer JOIN w_move_mat.tb_for_mmkt t ON (t.rn = m.rn)
--left outer join w_sprmat.vw_mat_spr_ex_with_oldnn t on (t.RN = m.rn)
where 
m1.rn = TMP_ZAG_RN_MAT_B and rownum<2;
exception when no_data_found then
TMP_MAT_112_B:=null;
TMP_MATNUM_112_B:=null;
TMP_MATEI_112_B:=null;
TMP_MATDAT_112_B:=null;
TMP_MATDATOTP_112_B:=NULL;
end;
end if;

if nvl(TMP_ZAG_RN_MAT_S,0)>0 then
Begin
select '('||m.nn||')' || m1.name_full, 
t.ost,m.UNIT, trunc(t.last_pr)   as DAT_POS, trunc(t.last_pr_ceh)
into TMP_MAT_112_S,TMP_MATNUM_112_S,TMP_MATEI_112_S,TMP_MATDAT_112_S,TMP_MATDATOTP_112_S
from 
v_SELECT_MAT m1
LEFT OUTER JOIN w_sprmat.tb_mat_spr m ON (m.rn = m1.RN)
--left outer join w_sprmat.vw_mat_spr_ex_with_oldnn t on (t.RN = m.rn)
left outer JOIN w_move_mat.tb_for_mmkt t ON (t.rn = m.rn)
where 
m1.rn = TMP_ZAG_RN_MAT_S and rownum<2;
exception when no_data_found then
TMP_MAT_112_S:=null;
TMP_MATNUM_112_S:=null;
TMP_MATEI_112_S:=null;
TMP_MATDAT_112_S:=null;
TMP_MATDATOTP_112_S:=NULL;
end;
end if;

End if;

exception when no_data_found then 
TMP_ZAG_RN_ISP_B:=null;
TMP_ZAG_RN_ISP_S:=null;
TMP_ZAG_OBOZN_B:=null;
TMP_ZAG_OBOZN_S:=null;
TMP_ZAG_EI_B:=null;
TMP_ZAG_EI_S:=null;
TMP_ZAG_NORMRAZ_B :=null;
TMP_ZAG_NORMRAZ_S:=null;
TMP_ZAG_VID_ZAG_B :=null;
TMP_ZAG_VID_ZAG_S :=null;
TMP_ZAG_VID_STR_B :=null;
TMP_ZAG_VID_STR_S :=null;
TMP_ZAG_KOLD_B :=null;
TMP_ZAG_KOLD_S :=null;
TMP_ZAG_VES_B :=null;
TMP_ZAG_VES_S :=null; 
TMP_ZAG_DL_B :=null;
TMP_ZAG_DL_S :=null;
TMP_ZAG_SH_B :=null;
TMP_ZAG_SH_S :=null;
TMP_ZAG_NOTE_B:=null;
TMP_ZAG_NOTE_S :=null;
TMP_MAT_112_B:=null;
TMP_MATNUM_112_B:=null;
TMP_MATEI_112_B:=null;
TMP_MATDAT_112_B:=null;
TMP_MAT_112_S:=null;
TMP_MATNUM_112_S:=null;
TMP_MATEI_112_S:=null;
TMP_MATDAT_112_S:=null;
TMP_MATDATOTP_112_S:=NULL;
TMP_MATDATOTP_112_B:=NULL;
end;
End if;

TMP_IND_NALCOMP:=null;
BEGIN
select tv.ind_nalcomp
into TMP_IND_NALCOMP
from w_ktsg.tb_tv tv
where tv.rn = sp_Dob.rn_tv;
EXCEPTION WHEN no_data_found THEN NULL;
END;

--select F_Get_TYPDCE(sp_dob.rn_tv ,sp_dob.rn_isp ,p_RNPS )
--into TMP_typ_DCE
--from dual;

--Получаем входимость
--select f_get_mo_vhodim(sp_dob.rn_isp,p_RNPS )
--into TMP_VHOD from dual;

BEGIN
SELECT tv0.ind_nalcomp,tv0.ind_nalcomp, vo.kornaim
INTO TMP_TV_INDCOMPL_B, TMP_TV_INDCOMPL_S, TMP_ISP_VID_KOR
FROM w_ktsg.tb_tv tv0, w_ktsg.tb_isp_ob io, w_ktsg.tb_vid_isp_ob vo
WHERE tv0.RN = sp_dob.rn_tv AND io.rn = tv0.rn_ispob AND vo.rn = io.rn_vid_ispob;

EXCEPTION WHEN no_data_found THEN
TMP_TV_INDCOMPL_B:=NULL;
TMP_TV_INDCOMPL_S:=NULL;
TMP_ISP_VID_KOR:=NULL;
END;


IF nvl(TMP_RN_PS,0)=0 THEN
--Если ни в каком документе не сидит - то делаем Было и стало одинаковое
TMP_ZAG_OBOZN_S:=TMP_ZAG_OBOZN_B;
TMP_TV_MASSA_S:=TMP_TV_MASSA_B;
TMP_ZAG_VES_S:=TMP_ZAG_VES_B;
TMP_ZAG_NORMRAZ_S:=TMP_ZAG_NORMRAZ_B;
TMP_ZAG_EI_S:=TMP_ZAG_EI_B;
TMP_ZAG_KOLD_S:=TMP_ZAG_KOLD_B;
TMP_ZAG_DL_S:=TMP_ZAG_DL_B;
TMP_ZAG_SH_S:=TMP_ZAG_SH_B;
TMP_ZAG_VID_ZAG_S:=TMP_ZAG_VID_ZAG_B;
TMP_ZAG_VID_STR_S:=TMP_ZAG_VID_STR_B;
TMP_ZAG_NOTE_S:=TMP_ZAG_NOTE_B;
TMP_TV_NOTE_S:=TMP_TV_NOTE_B;
TMP_ZAG_RN_ISP_S:=TMP_ZAG_RN_ISP_B;
TMP_MAT_112_S:=TMP_MAT_112_B;
TMP_MATNUM_112_S:=TMP_MATNUM_112_B;
TMP_MATDAT_112_S:=TMP_MATDAT_112_B;
TMP_MATEI_112_S:=TMP_MATEI_112_B;
TMP_MATDATOTP_112_S:=TMP_MATDATOTP_112_B;

END IF;


update tb_sp_izm_mmk ii
   set obozn_b = TMP_ISP_OBOZN_B,  obozn_s = TMP_ISP_OBOZN_S,
        name_b = TMP_TV_NAIM_B,  name_s = TMP_TV_NAIM_S,
       spr_b = f_get_tv_spr_new(TMP_ISP_VID_KOR ,TMP_ISP_TIP_B ,TMP_TV_INDCOMPL_B ,sp_dob.rn_tv ),
       spr_s = f_get_tv_spr_new(TMP_ISP_VID_KOR ,TMP_ISP_TIP_S ,TMP_TV_INDCOMPL_S ,sp_dob.rn_tv),--       str_obr_b = v_str_obr_b,
ii.typ_dce_b = TMP_ISP_TIP_B,
ii.typ_dce_S = TMP_ISP_TIP_S,       
--       str_obr_s = v_str_obr_s,
--       if_izm_mo = v_if_izm_mo,
--       if_izm_vhod = v_if_izm_vhod,
--       if_izm_obr = v_if_izm_obr,
--       if_izm_zag = v_if_izm_zag,
       dce_zag_b = TMP_ZAG_OBOZN_B, dce_zag_s = TMP_ZAG_OBOZN_S,
       ves_dce_b = TMP_TV_MASSA_B,   ves_dce_s = TMP_TV_MASSA_S,
       ves_zag_b = TMP_ZAG_VES_B,     ves_zag_s =TMP_ZAG_VES_S,
       nrm_ras_b = TMP_ZAG_NORMRAZ_B, nrm_ras_s = TMP_ZAG_NORMRAZ_S,
       edizmzag_b = TMP_ZAG_EI_B,  edizmzag_s = TMP_ZAG_EI_S,
       kol_det_b = TMP_ZAG_KOLD_B,  kol_det_s = TMP_ZAG_KOLD_S,
      zdl_b = TMP_ZAG_DL_B, zdl_s = TMP_ZAG_DL_S, zsh_b = TMP_ZAG_SH_B, zsh_s = TMP_ZAG_SH_S,
       vid_zagkod_b = TMP_ZAG_VID_ZAG_B,   vid_zagkod_s = TMP_ZAG_VID_ZAG_S,
       vid_zagstr_b = TMP_ZAG_VID_STR_B,     vid_zagstr_s =TMP_ZAG_VID_STR_S,
       zag_prim_b = TMP_ZAG_NOTE_B,        zag_prim_s = TMP_ZAG_NOTE_S,
       tv_prim_b = TMP_TV_NOTE_B,    tv_prim_s = TMP_TV_NOTE_S,
       tv_doly_b = TMP_TV_DOLY_B,       
       -- is_izg = v_is_izg,
       tv_doly_s = TMP_TV_DOLY_S,
       zrn_b = TMP_ZAG_RN_ISP_B,
       zrn_s = TMP_ZAG_RN_ISP_S,
       ii.rn_ps_use = TMP_RN_PS,
       ii.str_ps_use = TMP_PS_USE,
       ii.typ_dce = case when TMP_IND_NALCOMP='0' then 2 else 1 end,
       ii.mat_b = TMP_MAT_112_B, ii.mat_s = TMP_MAT_112_S, ii.mat_ost_b = TMP_MATNUM_112_B, ii.mat_ost_s = TMP_MATNUM_112_S,
       ii.mat_dat_post_b = TMP_MATDAT_112_B ,ii.mat_dat_post_s = TMP_MATDAT_112_S, ii.mat_ei_b =TMP_MATEI_112_B ,ii.mat_ei_s=TMP_MATEI_112_S,
ii.DAT_FORM = TMP_DAT_F, /*ii.STR_VHHOD = TMP_VHOD,*/ /*ii.typ_izmtv = TMP_typ_DCE,*/
ii.mat_otp_s=TMP_MATDATOTP_112_S, ii.mat_otp_b = TMP_MATDATOTP_112_B
       
 where ii.sid=t_sid and ii.rn_tv = sp_Dob.rn_tv and ii.rn_isp = sp_dob.rn_isp ;

End loop;
-- теперь полный перебор всех ДСЕ и смотрим у них изменение в применяемости
--Если голова - то заполняем таблицу Входимости полную
--Так же заполняем таблицу по изменению маршрута
W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');
For sp_all in
(select im.rn_isp,im.rn_tv
from tb_sp_izm_mmk im
where im.sid = t_sid
and im.typ_dce<>0
)
Loop
--Определяем для испоба изменения вхождения в ДСЕ по перечню 
--разраб
If typ_Doc = 'Р' or typ_doc='С' then
Insert into TB_SP_IZM_PRIM
Select
t_sid, sp_all.rn_tv, sp_all.rn_isp, 0 , z.rn,z.rn_ispob, i.OBOZN,a.KOL,b.KOL,
ei0.kornaim, ei1.kornaim, mp0.kornaim, mp1.kornaim, null,null,vo0.kornaim,vo1.kornaim,
a.USTCOMPNOTE,b.USTCOMPNOTE,null,null,null,null,null,null
from
(
Select distinct RN_TV from
(
Select u0.RN_TV
from w_ktsg.v0_ust_comp_s u0, w_ktsg.tb_izm_tv it
where u0.RN_ISPOB_CH = sp_all.rn_isp and it.rn_tv = u0.RN_TV and it.rn_persogl = p_RNPS
union all
Select u1.RN_TV
from w_ktsg.v1r_ust_comp_s u1, w_ktsg.tb_izm_tv it1
where u1.RN_ISPOB_CH = sp_all.rn_isp and it1.rn_tv = u1.RN_TV and it1.rn_persogl = p_RNPS
))Q
left outer join w_ktsg.v0_ust_comp_s a on (a.RN_TV = q.rn_tv and a.RN_ISPOB_CH = sp_all.rn_isp)
    left outer join W_ei.Tb_Ei Ei0 on (ei0.rn = a.RN_EI_UST)
    Left outer join w_ktsg.v0_poz_mo_s p0 on (p0.RN_POZMO = a.RN_POZMO)
        left outer join w_mp.tb_podr mp0 on (mp0.rn = p0.RN_PODR)
        left outer join w_vo.tb_vo vo0 on (vo0.rn = p0.RN_VO)
Left outer join w_ktsg.v1r_ust_comp_s b on (b.RN_TV = q.rn_tv and b.RN_ISPOB_CH = sp_all.rn_isp)
    left outer join W_ei.Tb_Ei Ei1 on (ei1.rn = b.RN_EI_UST)
    Left outer join w_ktsg.v1_poz_mo_s p1 on (p1.RN_POZMO = b.RN_POZMO)
        left outer join w_mp.tb_podr mp1 on (mp1.rn = p1.RN_PODR)
        left outer join w_vo.tb_vo vo1 on (vo1.rn = p1.RN_VO)
    , 
w_ktsg.tb_tv z, w_ktsg.v0_isp_ob_s i
where z.rn = q.rn_tv and i.RN_ISPOB = z.rn_ispob
And 
(nvl(a.KOL,0)<>nvl(b.KOL,0) or
nvl(ei0.kornaim,' ')<>nvl(ei1.kornaim,' ') or nvl(mp0.kornaim,' ')<> nvl(mp1.kornaim,' ') or nvl(vo0.kornaim,' ') <> nvl(vo1.kornaim,' ')
OR nvl(a.USTCOMPNOTE,'NULL')<>nvl(b.USTCOMPNOTE,'NULL')
);
else
--Утв
null;
End if;

--Втавка образцов
W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');
If typ_Doc = 'Р' or typ_doc='С' then
If nvl(sp_all.rn_tv,0)>0 then
Insert into TB_SP_IZM_PRIM

Select
t_sid, sp_all.rn_tv, sp_all.rn_isp,  2 , z.rn,z.rn_ispob, i.OBOZN, --Сосвместно изготавливается
a.TEHNKOL,a1.tehnkol,
NULL, NULL, mp0.kornaim, mp1.kornaim, iz.OBOZN, --Защищаемый
null,vo0.kornaim,vo1.kornaim,
a.INFOBRNOTE,a1.INFOBRNOTE,
a.MAXPART,a1.maxpart,
pin0.kornaim,pin1.kornaim,
pis0.kornaim ,pis1.kornaim
from
(
Select distinct RN_TVI, RN_TV_ZCH from
(Select o0.RN_TV_IZG as RN_TVI, mo0.rn_tv as RN_TV_ZCH --, 1 as US --Совместно изготавливается
from w_ktsg.v0_obr_s o0, w_ktsg.tb_izm_tv it, w_ktsg.tb_poz_mo_s mo0
where o0.RN_TV_OBR =sp_all.rn_tv and it.rn_tv = /*o0.RN_TV_OBR*/ o0.RN_TV_IZG and it.rn_persogl = p_RNPS
and mo0.att_arid = o0.ARID_POZMO
union all
Select o1.RN_TV_IZG as RN_TVI, mo1.rn_tv as RN_TV_ZCH--, 1 as US --Совместно изготавливается
from w_ktsg.v1r_obr_s o1, w_ktsg.tb_izm_tv it, w_ktsg.tb_poz_mo_s mo1
where o1.RN_TV_OBR = sp_all.rn_tv and it.rn_tv = o1.RN_TV_IZG/*o1.RN_TV_OBR*/ and it.rn_persogl = p_RNPS
and mo1.att_arid = o1.ARID_POZMO
))Q
left outer join 
( Select aa.RN_TV_OBR,aa.RN_TV_IZG,aa.ARID_POZMO,
             aa.RN_PODR_ISP,aa.RN_PODR_INITTD, aa.TEHNKOL,
             aa.MAXPART,aa.INFOBRNOTE,aaa.rn_tv
From w_ktsg.v0_obr_s aa , w_ktsg.tb_poz_mo_s aaa 
where aaa.att_arid = aa.ARID_POZMO) a on (a.RN_TV_IZG = q.rn_tvi   and a.RN_TV_OBR = sp_all.rn_tv and a.rn_tv = q.RN_TV_ZCH)
    Left outer join w_ktsg.Tb_poz_mo_s p0 on (p0.att_arid = a.arid_pozmo)
        left outer join w_mp.tb_podr mp0 on (mp0.rn = p0.RN_PODR)
        left outer join w_vo.tb_vo vo0 on (vo0.rn = p0.RN_VO)
    left outer join w_mp.tb_podr pis0 on (pis0.rn = a.rn_podr_isp)    
    left outer join w_mp.tb_podr pin0 on (pin0.rn = a.rn_podr_inittd)

left outer join 
( Select aa1.RN_TV_OBR,aa1.RN_TV_IZG,aa1.ARID_POZMO,
             aa1.RN_PODR_ISP,aa1.RN_PODR_INITTD, aa1.TEHNKOL,
             aa1.MAXPART,aa1.INFOBRNOTE,aaa1.rn_tv
From w_ktsg.v1r_obr_s aa1 , w_ktsg.v1r_poz_mo_s aaa1 
where aaa1.att_arid = aa1.ARID_POZMO) a1 on (a1.RN_TV_IZG = q.rn_tvi   and a1.RN_TV_OBR = sp_all.rn_tv and a1.rn_tv = q.RN_TV_ZCH)
    Left outer join w_ktsg.Tb_poz_mo_s p1 on (p1.att_arid = a1.arid_pozmo)
        left outer join w_mp.tb_podr mp1 on (mp1.rn = p1.RN_PODR)
        left outer join w_vo.tb_vo vo1 on (vo1.rn = p1.RN_VO)
    left outer join w_mp.tb_podr pis1 on (pis1.rn = a1.rn_podr_isp)    
    left outer join w_mp.tb_podr pin1 on (pin1.rn = a1.rn_podr_inittd)
, 
w_ktsg.tb_tv z, w_ktsg.v0_isp_ob_s i,
w_ktsg.tb_tv zz, w_ktsg.v0_isp_ob_s iz
where z.rn = q.RN_TVI and i.RN_ISPOB = z.rn_ispob
and zz.rn = q.RN_TV_ZCH and iz.RN_ISPOB = zz.rn_ispob;

End if;
--Для утвержденного не нужно - было ранее
end if;
W_KTSG.PK_VALUES.Set_CURDATE('01.01.9999');
--Вставка изменения в применяемости как заготовки
If typ_Doc = 'Р' or typ_doc='С' THEN
--Берем все TV с заготовками от текущего ДСЕ_ЧТО по вхождению в 0 варианте и в 1
-- причем только те которые сидят в текущем документе

INSERT INTO TB_SP_IZM_PRIM 
(sid, rn_tv, rn_isp, typ_prim, rn_tv_kula, rn_isp_kuda, obozn_kuda, num_sost_b, num_sost_s,
ei_sost_b, ei_sost_s, ceh_sb_b, ceh_sb_s, obozn_zach_b, obozn_zach_s, mo_sb_b, mo_sb_s,
note_b, note_s, max_part_b, max_part_s, ceh_init_b, ceh_init_s, ceh_isp_b, ceh_isp_s)

SELECT --+star
t_sid,sp_all.rn_tv, sp_all.rn_isp,1, tv_k.rn, i_k.RN_ISPOB,i_k.OBOZN, a.NORMRASH, b.NORMRASH,
ei0.kornaim, ei1.kornaim, w_ktsg.f_get_CEH_POL_v0 (tv_k.rn), w_ktsg.f_get_CEH_POL(tv_k.rn ) ,NULL,NULL,NULL,NULL,
NULL,NULL,null,null,null,null,null,null
FROM
(
SELECT DISTINCT zz.RN_TV
FROM
(
SELECT z1.RN_TV
FROM w_ktsg.v1r_t_zag_s z1, w_ktsg.tb_izm_tv zi1 
WHERE z1.RN_ISPOB_ZAG = sp_all.rn_isp AND zi1.rn_tv = z1.RN_TV AND zi1.rn_persogl = p_RNPS
UNION ALL
SELECT z0.RN_TV
FROM w_ktsg.v0_t_zag_s z0, w_ktsg.tb_izm_tv zi0
WHERE z0.RN_ISPOB_ZAG = sp_all.rn_isp AND zi0.rn_tv = z0.RN_TV AND zi0.rn_persogl = p_rnps
) zz
)z
--Прицепляем заготовка было
LEFT OUTER JOIN w_ktsg.v0_t_zag_s a ON (a.RN_TV = z.rn_tv AND a.RN_ISPOB_ZAG = sp_all.rn_isp)
         left outer join W_ei.Tb_Ei Ei0 on (ei0.rn = a.RN_EI)
--Прицепляем заготовка стало
LEFT OUTER JOIN w_ktsg.v1r_t_zag_s b ON (b.RN_TV = z.rn_tv AND b.RN_ISPOB_ZAG = sp_all.rn_isp)
         left outer join W_ei.Tb_Ei Ei1 on (ei1.rn = b.RN_EI)  

,
w_ktsg.tb_tv tv_K, w_ktsg.v0_isp_ob_s i_K
where tv_k.rn = z.RN_TV and i_K.RN_ISPOB = tv_k.rn_ispob
--такж епроверяем на различные данные по норме, ед прим, цеху получателю
AND
(nvl(a.NORMRASH,-1)<>nvl( b.NORMRASH,-1) OR nvl(ei0.kornaim,'ХЗ')<> nvl(ei1.kornaim,'ХЗ') OR
w_ktsg.f_get_CEH_POL (tv_k.rn)<> w_ktsg.f_get_CEH_POL_v0(tv_k.rn )
)
;
END IF;













--Сделаем проверку на наличие записей V1 в составе, МО, Образцах
--Состав
If typ_Doc = 'Р' or typ_doc='С' then
Select count(*)
into p_Is_izm_SOST
from w_ktsg.tb_ust_comp_s uu, w_ktsg.tb_audi ua
where uu.rn_tv = sp_all.rn_tv
and ua.att_arid = uu.att_arid
and ua.att_var = 1
and ua.att_auth = p_RNPS;

--МО
Select count(*)
into p_Is_izm_MO
from w_ktsg.tb_poz_mo_s mm, w_ktsg.tb_audi ma
where mm.rn_tv = sp_all.rn_tv
and ma.att_arid = mm.att_arid
and ma.att_var = 1
and ma.att_auth = p_RNPS;

IF p_Is_izm_MO = 0 THEN
SELECT  COUNT(*)
INTO p_Is_izm_MO
FROM w_ktsg.v1_poz_mo_s mm, w_ktsg.tb_tehn_dob_s td, w_ktsg.tb_audi ta
WHERE mm.RN_TV = sp_all.rn_tv AND td.arid_pozmo = mm.att_ARID AND ta.att_arid = td.att_arid
and ta.att_var = 1
and ta.att_auth = p_RNPS;
END IF;


--Образцы
Select count(*)
into p_Is_izm_OBR
from w_ktsg.tb_obr_s oo , w_ktsg.tb_audi oa
where oo.rn_tv_izg = sp_all.rn_tv
and oa.att_arid = oo.att_arid
and oa.att_var = 1
and oa.att_auth = p_RNPS;
else

--Состав
Select count(*)
into p_Is_izm_SOST
from table(pk_mmk_izms.F_SOSTAV(sp_all.rn_tv ,p_RNPS ));

--МО
Select count(*)
into p_Is_izm_MO
from table(pk_mmk_izms.F_MO(sp_all.rn_tv ,p_RNPS ));

IF p_Is_izm_MO=0 THEN
Select count(*)
into p_Is_izm_MO
from table(pk_mmk_izms.F_td(sp_all.rn_tv ,p_RNPS ));
END IF;


--Образцы
Select count(*)
into p_Is_izm_OBR
from table(pk_mmk_izms.F_OBR(sp_all.rn_tv ,p_RNPS ));
end if;

select F_Get_TYPDCE(sp_all.rn_tv ,sp_all.rn_isp ,p_RNPS )
into TMP_typ_DCE
from dual;




--Обновим в таблице данные
update tb_sp_izm_mmk ii
   set ii.if_izm_mo = p_Is_izm_MO, ii.if_izm_vhod = p_Is_izm_SOST, ii.if_izm_obr = p_Is_izm_OBR,
      ii.typ_izmtv = TMP_typ_DCE
where ii.sid = t_sid and ii.rn_tv = sp_all.rn_tv;   


end loop;


--ТЕперь Изменения в МО
For sp_TVAll in
(select im.rn_tv
from tb_sp_izm_mmk im
where im.sid = t_sid
and not im.rn_tv is null
)
Loop
--На каждый ТВ получим Было и стало по маршруту
If typ_Doc = 'Р' or typ_doc='С' then
Insert into tb_sp_izm_mo
Select 
t_sid,sp_tvall.rn_tv,PORNOM ,mp0.kornaim, mp1.kornaim, vo0.kornaim,vo1.kornaim,
PM0.POZMONOTE,PM1.POZMONOTE,
F_GET_TEHNDOB_STRING(td0.att_ARID), F_GET_TEHNDOB_STRING(td1.att_ARID)
from
(
Select distinct rn_pozmo, PORNOM  from (
(Select po1.RN_POZMO, poz.pornom from w_ktsg.v1_poz_mo_s po1, w_ktsg.tb_poz_mo poz where po1.RN_TV = sp_tvall.rn_tv and poz.rn = po1.RN_POZMO
union all
Select po0.RN_POZMO, poz.pornom from w_ktsg.v0_poz_mo_s po0,  w_ktsg.tb_poz_mo poz where po0.RN_TV = sp_tvall.rn_tv  and poz.rn = po0.RN_POZMO
)
                                                )
)PM
Left outer join w_ktsg.v0_poz_mo_s PM0 on (pm0.RN_POZMO = pm.rn_pozmo)
         left outer join w_mp.tb_podr mp0 on (mp0.rn = pm0.RN_PODR)
         left outer join w_vo.tb_vo vo0 on (vo0.rn = pm0.RN_VO)
         left outer join w_ktsg.v0_tehn_dob_s TD0 on (td0.ARID_POZMO=PM0.att_ARID)
Left outer join w_ktsg.v1_poz_mo_s PM1 on (pm1.RN_POZMO = pm.rn_pozmo)
         left outer join w_mp.tb_podr mp1 on (mp1.rn = pm1.RN_PODR)
         left outer join w_vo.tb_vo vo1 on (vo1.rn = pm1.RN_VO)
         left outer join w_ktsg.v1_tehn_dob_s TD1 on (td1.ARID_POZMO=PM1.att_ARID) ;
else

--Insert into tb_sp_izm_mo

--Перебор всех МО для ТВ с изменениями


Insert into tb_sp_izm_mo
select  t_sid,sp_tvall.rn_tv, sm.pornom, mp0.kornaim, mp1.kornaim, vo0.kornaim,vo1.kornaim,
sm.POZMONOTE_b,sm.POZMONOTE_s,
F_GET_TEHNDOB_STRING(td.TD_ARID_B), F_GET_TEHNDOB_STRING(td.TD_ARID_S)
from table(CAST(pk_mmk_izms.F_MO_TV_ALL(p_RNPS ,sp_tvall.rn_tv )   AS t_Tb_izms_mo)  )sm
   left outer join w_mp.tb_podr mp0 on (mp0.rn = sm.RNPODR_b)
        left outer join w_vo.tb_vo vo0 on (vo0.rn = sm.RNVO_b)
   left outer join w_mp.tb_podr mp1 on (mp1.rn = sm.RNPODR_S)
        left outer join w_vo.tb_vo vo1 on (vo1.rn = sm.RNVO_S),
 table(cast(pk_mmk_izms.F_TD_ALL(sp_tvall.rn_tv ,p_RNPS,Sm.ARIDmo_B ,sm.ARIDmo_S ,sm.RN_POZMO ) AS T_TB_IZMS_TD_ALL )  )TD;        
end if;

end loop;

For sp_TVAll in
(select im.rn_tv, im.rn_isp
from tb_sp_izm_mmk im
where im.sid = t_sid
and not im.rn_tv is null
)
LOOP
--Определим сборка не сборка и перебьем тип ДСЕ заново
--Сортировка в отчете - Сборка/ДЕталь/остальная срань




select count(*)
into TMP_IS_ED_PRIM
from tb_sp_izm_prim pr
where pr.sid = t_sid and pr.rn_tv = sp_tvall.rn_tv and pr.rn_isp=sp_tvall.rn_isp;

IS_gl:=0;
BEGIN
SELECT CASE WHEN tv.ind_nalcomp='1' THEN 1 ELSE 2 END
INTO Is_GL
FROM w_ktsg.tb_tv tv
WHERE tv.rn = sp_tvall.rn_tv;
EXCEPTION WHEN no_data_found THEN 
Is_GL:=3;
END;

Update tb_sp_izm_mmk ii
set ii.is_ed_prim = TMP_IS_ED_PRIM,
ii.typ_dce = IS_gl
where ii.sid = t_sid and ii.rn_isp = sp_tvall.rn_isp and ii.rn_tv = sp_tvall.rn_tv;

end loop;

--В таблице tb_sp_izm_mmk делаем все изменения на то чтобы все строки печатать
--UPDATE tb_sp_izm_mmk a
--SET a.is_sel = 1 WHERE a.sid = t_sid;
P_SID:=t_sid;



--Заполняем таблицу входимостей
--Входимость по V0 !!! 12.10.2009
FOR sp_isp IN 
(SELECT DISTINCT  ii.rn_isp, ii.rn_tv
FROM tb_sp_izm_mmk ii
WHERE ii.sid = t_sid
)
LOOP

If typ_Doc = 'Р' or typ_doc='С' THEN
--Разработка
SELECT COUNT(*)
INTO num_vhod
--FROM w_ktsg.v1r_ust_comp_s u , w_ktsg.tb_tv utv, w_ktsg.v0_isp_ob_s uio
FROM
(SELECT DISTINCT uio.RN_ISPOB
FROM w_ktsg.v0_ust_comp_s u , w_ktsg.tb_tv utv, w_ktsg.v0_isp_ob_s uio
WHERE u.RN_ISPOB_CH = sp_isp.rn_isp
AND u.RN_TV<>494707
AND utv.rn = u.RN_TV
AND uio.RN_ISPOB = utv.rn_ispob
AND uio.TIP_ISPOB<>'М'
AND NOT EXISTS
(
select NULL
from tb_sp_izm_prim a
where a.sid = t_sid
and a.rn_tv = sp_isp.rn_tv
and a.rn_isp = sp_isp.rn_isp
AND a.rn_tv_kula = u.RN_TV and  a.typ_prim = 0
) 
--Дополнительная проверка на то что по данному документу ДСЕ КУДА не должно становится мусором (применяемость анулируется!!)
) oo
WHERE F_GET_MO_existsVHODIM(oo.RN_ISPOB ,p_RNPS )>0
;



IF num_vhod>15 THEN
INSERT INTO tb_sp_izm_vhod v
(v.sid,v.rn_tv_ch,v.tn_isp_ch,v.typ_dce_k,v.obozn_k,v.num_k,v.ei_k,v.sbr_k)
VALUES
(t_sid,sp_isp.rn_tv,sp_isp.rn_isp, NULL, 'Количество входимостей', num_vhod,NULL,NULL);


ELSE

INSERT INTO tb_sp_izm_vhod
SELECT
t_sid,sp_isp.rn_tv,sp_isp.rn_isp, ii.rn_vid_ispob , i.OBOZN,u.KOL,ei.kornaim, pp.kornaim ||'/'||vo.kornaim

--FROM w_ktsg.v1r_ust_comp_s u, w_ktsg.tb_tv tv, w_ktsg.v0_isp_ob_s i, w_ktsg.tb_isp_ob ii,
FROM w_ktsg.v0_ust_comp_s u, w_ktsg.tb_tv tv, w_ktsg.v0_isp_ob_s i, w_ktsg.tb_isp_ob ii,
--w_ei.tb_ei ei, w_ktsg.v1r_poz_mo_s pm,
w_ei.tb_ei ei, w_ktsg.v0_poz_mo_s pm,
w_mp.tb_podr pp, w_vo.tb_vo vo
WHERE u.RN_ISPOB_CH = sp_isp.rn_isp
AND u.RN_TV<>494707
AND NOT EXISTS
(
select NULL
from tb_sp_izm_prim a
where a.sid = t_sid
and a.rn_tv = sp_isp.rn_tv
and a.rn_isp = sp_isp.rn_isp
AND a.rn_tv_kula = u.RN_TV and  a.typ_prim = 0
)
AND tv.rn = u.RN_TV AND i.RN_ISPOB = tv.rn_ispob AND ii.rn = i.RN_ISPOB
AND i.TIP_ISPOB<>'М'
AND ei.rn = u.RN_EI_UST
AND pm.RN_POZMO = u.RN_POZMO 
AND pp.rn = pm.RN_PODR AND vo.rn = pm.RN_VO
AND F_GET_MO_existsVHODIM(i.RN_ISPOB ,p_RNPS )>0
;





END IF;

--Обновляем поле для образца
UPDATE tb_sp_izm_mmk ii
SET ii.sp_obr =w_ktsg.f_get_sp_Obr(sp_isp.rn_tv) || '  ' || w_ktsg.f_get_sp_Obr_ZNIZG(sp_isp.rn_tv)
WHERE ii.sid =t_sid AND ii.rn_isp =sp_isp.rn_isp AND ii.rn_tv = sp_isp.rn_tv
AND 
(
EXISTS (SELECT NULL FROM w_ktsg.tb_obr_s o WHERE o.rn_tv_izg = sp_isp.rn_tv)
OR EXISTS (SELECT NULL FROM w_ktsg.tb_poz_mo_s pm, w_ktsg.tb_obr_s oo WHERE pm.rn_tv = sp_isp.rn_tv AND oo.arid_pozmo = pm.att_arid)
)
;




ELSE
--Утвержденный
SELECT COUNT(*)
INTO num_vhod
FROM w_ktsg.v0_ust_comp_s u , w_ktsg.tb_tv utv, w_ktsg.v0_isp_ob_s uio
WHERE u.RN_ISPOB_CH = sp_isp.rn_isp
AND u.RN_TV<>494707
AND utv.rn = u.RN_TV
AND uio.RN_ISPOB = utv.rn_ispob
AND uio.TIP_ISPOB<>'М'
AND NOT EXISTS
(
select NULL
from tb_sp_izm_prim a
where a.sid = t_sid
and a.rn_tv = sp_isp.rn_tv
and a.rn_isp = sp_isp.rn_isp
AND a.rn_tv_kula = u.RN_TV and  a.typ_prim = 0
);



IF num_vhod>15 THEN
INSERT INTO tb_sp_izm_vhod v
(v.sid,v.rn_tv_ch,v.tn_isp_ch,v.typ_dce_k,v.obozn_k,v.num_k,v.ei_k,v.sbr_k)
VALUES
(t_sid,sp_isp.rn_tv,sp_isp.rn_isp, NULL, 'Количество входимостей', num_vhod,NULL,NULL);
ELSE

INSERT INTO tb_sp_izm_vhod
SELECT
t_sid,sp_isp.rn_tv,sp_isp.rn_isp, ii.rn_vid_ispob , i.OBOZN,u.KOL,ei.kornaim, pp.kornaim ||'/'||vo.kornaim

FROM w_ktsg.v0_ust_comp_s u, w_ktsg.tb_tv tv, w_ktsg.v0_isp_ob_s i, w_ktsg.tb_isp_ob ii,
w_ei.tb_ei ei, w_ktsg.v0_poz_mo_s pm,
w_mp.tb_podr pp, w_vo.tb_vo vo
WHERE u.RN_ISPOB_CH = sp_isp.rn_isp
AND u.RN_TV<>494707
AND NOT EXISTS
(
select NULL
from tb_sp_izm_prim a
where a.sid = t_sid
and a.rn_tv = sp_isp.rn_tv
and a.rn_isp = sp_isp.rn_isp
AND a.rn_tv_kula = u.RN_TV and  a.typ_prim = 0
)
AND tv.rn = u.RN_TV AND i.RN_ISPOB = tv.rn_ispob AND ii.rn = i.RN_ISPOB
AND i.TIP_ISPOB<>'М'
AND ei.rn = u.RN_EI_UST
AND pm.RN_POZMO = u.RN_POZMO 
AND pp.rn = pm.RN_PODR AND vo.rn = pm.RN_VO
;

END IF;

--Обновляем поле для образца
UPDATE tb_sp_izm_mmk ii
SET ii.sp_obr =w_ktsg.f_get_sp_Obr(sp_isp.rn_tv,0) || '  ' || w_ktsg.f_get_sp_Obr_ZNIZG(sp_isp.rn_tv,0)
WHERE ii.sid =t_sid AND ii.rn_isp =sp_isp.rn_isp AND ii.rn_tv = sp_isp.rn_tv;
END IF;
END LOOP;

--Обновление Полей !!!!!!!!!!!Сделал как единственное место!!!!!!!!!!!!!

--ТАк же нужно поставить отметку у всех ДСЕ которые сидят в документе и по ним были изменения в Обр_С для того чтоб их печатали
--Более правильно показать все ДСЕ совместного изготовления по которым были записи от текущего документа в ОБРС

UPDATE tb_sp_izm_mmk sp
SET sp.rn_vid_ispob = (SELECT io.rn_vid_ispob FROM w_ktsg.tb_isp_ob io WHERE io.rn = sp.rn_isp),
sp.obozn_sort = sp.obozn_s, sp.str_vhhod = f_get_mo_vhodim(sp.rn_isp,p_RNPS ), 
sp.typ_izmtv = F_Get_TYPDCE(sp.rn_tv ,sp.rn_isp ,p_RNPS ), sp.is_sel=1
,sp.ei_prim = 
(SELECT e.kornaim
FROM w_ktsg.v01_ust_comp_s_ps u, w_ei.tb_ei e WHERE u.RN_ISPOB_CH = sp.rn_isp AND u.rn = p_RNPS AND u.RN_EI_UST<>52 AND e.rn = u.RN_EI_UST AND rownum<2) 
WHERE sp.sid = t_sid;



UPDATE tb_sp_izm_mmk sp
SET 
sp.edizmzag_b = CASE    
 WHEN nvl(sp.ei_prim,' ')=' ' OR nvl(sp.edizmzag_s,' ')<>' ' OR nvl(sp.edizmzag_b,' ')=' ' THEN sp.edizmzag_b
      ELSE sp.edizmzag_b||'/'||sp.ei_prim
                END,
sp.edizmzag_s =  CASE                
 WHEN nvl(sp.ei_prim,' ')=' ' OR nvl(sp.edizmzag_s,' ')=' '  THEN sp.edizmzag_s
      ELSE sp.edizmzag_b||'/'||sp.ei_prim
                END
WHERE sp.sid = t_sid;



UPDATE tb_sp_izm_mmk sp2
SET sp2.vsegda = 1
WHERE 
(sp2.rn_tv IN
(
SELECT i.rn_tv
FROM w_ktsg.tb_izm_tv i, w_ktsg.tb_obr_s o, w_ktsg.tb_audi ai
WHERE i.rn_persogl = p_RNPS AND o.rn_tv_izg = i.rn_tv AND o.att_arid = ai.att_arid AND ai.att_auth=p_RNPS
)
OR
instr(sp2.typ_izmtv,'ММК из ММВ')>0) 
AND sp2.sid = t_sid
;






IS_TOS:=0;
LOOP
--Переточовка в отчете образцов
--Образцы идут после совместноизготавливаемых ДСЕ (берем самое первое по обозначению!!!)
--Если для образца нету ДСЕ с которой ее ставить то суем на самого себя!!!

If typ_Doc = 'Р' or typ_doc='С' THEN
FOR sp_OBR IN
(
SELECT DISTINCT rn_isp,rn_tv
FROM ( 
SELECT i.rn_isp,i.rn_tv FROM tb_sp_izm_mmk i, w_ktsg.v1r_obr_s o 
WHERE i.sid = t_sid AND o.RN_TV_OBR = i.rn_tv 
--Добавим поиск во всех РНТВ в которых произошли изменения в данном документе по образцам
UNION ALL 
SELECT i.rn_isp,i.rn_tv 
FROM  tb_sp_izm_prim i
wHERE i.sid = t_sid AND i.typ_prim=2  )
)
LOOP
--Находим самую первую в таблице отчета запись по совместно изготавливаемому образцу
/*BEGIN
SELECT iz.typ_dce, \*iz.obozn_s*\iz.obozn_sort,iz.rn_vid_ispob
INTO TMPS_typ_dce , TMPS_obozn_s , TMPS_rn_vid_ispob 
FROM  w_ktsg.v1r_obr_s o1, tb_sp_izm_mmk iz
WHERE o1.RN_TV_OBR = sp_obr.rn_tv  AND iz.rn_tv = o1.RN_TV_IZG  AND iz.sid = t_sid
AND rownum <2;*/
BEGIN
SELECT typ_dce, obozn_sort,rn_vid_ispob
INTO TMPS_typ_dce , TMPS_obozn_s , TMPS_rn_vid_ispob
FROM
(
SELECT iz.typ_dce, iz.obozn_sort,iz.rn_vid_ispob
FROM  w_ktsg.v1r_obr_s o1, tb_sp_izm_mmk iz
WHERE o1.RN_TV_OBR = sp_obr.rn_tv  AND iz.rn_tv = o1.RN_TV_IZG  AND iz.sid = t_sid
UNION ALL
SELECT iz.typ_dce, iz.obozn_sort,iz.rn_vid_ispob
FROM tb_sp_izm_prim i, tb_sp_izm_mmk iz
WHERE i.rn_tv = sp_obr.rn_tv AND i.typ_prim=2 AND i.sid = t_sid AND iz.sid = t_sid AND iz.rn_isp = i.rn_isp_kuda AND iz.rn_tv = i.rn_tv_kula
)
WHERE ROWNUM<2;



UPDATE tb_sp_izm_mmk ii
SET ii.typ_dce = TMPS_typ_dce , ii.obozn_sort = TMPS_obozn_s, ii.rn_vid_ispob = TMPS_rn_vid_ispob, ii.is_obr = 1
WHERE ii.sid = t_sid AND ii.rn_isp = sp_obr.rn_isp AND ii.rn_tv = sp_obr.rn_tv;


EXCEPTION WHEN no_data_found THEN 
NULL; --поидее быть такого не должно!!!!
END;
END LOOP;


ELSE

FOR sp_OBR IN
(
/*SELECT DISTINCT i.rn_isp,i.rn_tv
FROM tb_sp_izm_mmk i, w_ktsg.v0_obr_s o
WHERE i.sid = t_sid AND o.RN_TV_OBR = i.rn_tv
*/
SELECT DISTINCT rn_isp,rn_tv
FROM ( 
SELECT i.rn_isp,i.rn_tv FROM tb_sp_izm_mmk i, w_ktsg.v0_obr_s o 
WHERE i.sid = t_sid AND o.RN_TV_OBR = i.rn_tv 
--Добавим поиск во всех РНТВ в которых произошли изменения в данном документе по образцам
UNION ALL 
SELECT i.rn_isp,i.rn_tv 
FROM  tb_sp_izm_prim i
wHERE i.sid = t_sid AND i.typ_prim=2  )
)
LOOP
BEGIN
/*SELECT iz.typ_dce, iz.obozn_sort  ,iz.rn_vid_ispob
INTO TMPS_typ_dce , TMPS_obozn_s , TMPS_rn_vid_ispob 
FROM  w_ktsg.v0_obr_s o1, tb_sp_izm_mmk iz
WHERE o1.RN_TV_OBR = sp_obr.rn_tv  AND iz.rn_tv = o1.RN_TV_IZG  AND iz.sid = t_sid
AND rownum <2;*/




SELECT typ_dce, obozn_sort,rn_vid_ispob
INTO TMPS_typ_dce , TMPS_obozn_s , TMPS_rn_vid_ispob
FROM
(
SELECT iz.typ_dce, iz.obozn_sort,iz.rn_vid_ispob
FROM  w_ktsg.v0_obr_s o1, tb_sp_izm_mmk iz
WHERE o1.RN_TV_OBR = sp_obr.rn_tv  AND iz.rn_tv = o1.RN_TV_IZG  AND iz.sid = t_sid
UNION ALL
SELECT iz.typ_dce, iz.obozn_sort,iz.rn_vid_ispob
FROM tb_sp_izm_prim i, tb_sp_izm_mmk iz
WHERE i.rn_tv = sp_obr.rn_tv AND i.typ_prim=2 AND i.sid = t_sid AND iz.sid = t_sid AND iz.rn_isp = i.rn_isp_kuda AND iz.rn_tv = i.rn_tv_kula
)
WHERE ROWNUM<2;


UPDATE tb_sp_izm_mmk ii
SET ii.typ_dce = TMPS_typ_dce , ii.obozn_sort = TMPS_obozn_s, ii.rn_vid_ispob = TMPS_rn_vid_ispob, ii.is_obr = 1
WHERE ii.sid = t_sid AND ii.rn_isp = sp_obr.rn_isp AND ii.rn_tv = sp_obr.rn_tv;

EXCEPTION WHEN no_data_found THEN 
NULL; --поидее быть такого не должно!!!!
END;
END LOOP;

END IF;
IS_TOS:=IS_TOS+1;

--3 раза тосуем и выходим - пока сделал так по тупому
IF IS_TOS=3 THEN 
EXIT ;
END IF;
END LOOP;

--3-е удаляем старые данные по СИДу - вдруг сидят
Delete from tb_sp_izm_mmk t1 where t1.sid = t_sid AND t1.rn_isp = 1531143;
Delete from TB_SP_IZM_PRIM t2 where t2.sid = t_sid AND t2.rn_isp = 1531143;
Delete from TB_SP_IZM_VHOD t3 where t3.sid = t_sid AND t3.tn_isp_ch = 1531143;

--Так же необходимо удалить из tb_sp_izm_mmk все ДСЕ имеющие вхождение как заготовку и при этом не имеющие ТВ
-- и при этом ШПР=4

DELETE
FROM tb_sp_izm_mmk a
WHERE a.sid=t_sid AND EXISTS (SELECT NULL FROM tb_sp_izm_prim p1 WHERE p1.sid=t_sid AND p1.typ_prim=1 AND p1.rn_tv = a.rn_tv AND p1.rn_isp = a.rn_isp)
AND NOT EXISTS (SELECT NULL FROM tb_sp_izm_prim p1 WHERE p1.sid=t_sid AND p1.typ_prim<>1 AND p1.rn_tv = a.rn_tv AND p1.rn_isp = a.rn_isp)
AND a.rn_tv=0 AND a.spr_s = 4;
COMMIT;



return;
end p_CR_IZMPS_TMP;
/
-------------------------------------
--  New procedure p_cr_izm_ps_log  --
-------------------------------------
create or replace procedure w_mmkt.p_CR_IZM_PS_LOG(
--Логирование таблицы W_KTSG.Tb_Per_sogl
--Логирование Утверждения документа
p_RNPS in NUMBER --РН документа по которому формировать изменения дя отчета 
) IS
t_sid NUMBER;
p_user VARCHAR2(255);
BEGIN

SELECT DISTINCT sid into t_sid from v$mystat;

select distinct ss.OSUSER
INTO p_user
 from v$session ss WHERE ss.SID = t_sid;

INSERT INTO d140izm.tb_log_ps a
(a.data_log,a.table_name,a.field_name,a.field_rez_b,a.fiels_res_s, a.id_zap, a.o_user, a.GUID_US)
VALUES
(SYSDATE,'w_ktsg.tb_per_sogl', 'ind_stexist', 'С','У', p_RNPS, P_USER , W_AD.f_Get_Current_Aduser_Guid);

return;
end p_CR_IZM_PS_LOG;
/

------------------------------------------
--  New procedure p_fill_mv_persogl_tv  --
------------------------------------------
create or replace procedure w_mmkt.p_fill_mv_persogl_tv is
begin
  EXECUTE IMMEDIATE 'truncate TABLE mv_persogl_tv_t';
EXECUTE IMMEDIATE 'drop index I_MV_PERSOGL_T_ISP';
EXECUTE IMMEDIATE 'drop index I_MV_PERSOGL_T_RNPS';
EXECUTE IMMEDIATE 'drop index I_MV_PERSOGL_T_RNTV';

  FOR c1 IN (SELECT * FROM w_ktsg.tb_per_sogl ) LOOP
    INSERT INTO mv_persogl_tv_t 
      SELECT
--По каким изменениям менялся ТВ и какие ТВ меняло изменение
-- С датами и вариантом
(SELECT att_arstart
                 FROM w_ktsg.tb_audi a
                 WHERE a.att_auth=t.rn_persogl AND rownum<2
                 AND a.att_objtype<>1000 AND att_limit IS NULL
                 AND decode(p.ind_stexist,'У',0,'Н',0,1)=a.att_var) AS dt_izmstexist,t.rn_persogl,
p.rn_typedoc,t.rn_tv,tv.RN_ISPOB AS rn_ispob,
CASE WHEN p.ind_stexist IN('У','Н') THEN
     0 ELSE
     1
     END AS att_var
FROM
w_ktsg.tb_izm_tv t
JOIN w_ktsg.tb_per_sogl p ON t.rn_persogl=p.rn
JOIN w_ktsg.v_tv tv ON t.rn_tv=tv.rn 
WHERE t.rn_persogl=c1.rn
UNION
SELECT abc.att_arstart,abc.att_auth,abc.att_authtype,abc.rn_tv,abc.rn_ispob,abc.att_var FROM (
SELECT ( SELECT MAX(a1.att_arstart) FROM tb_audi a1
 WHERE a1.att_auth=a.att_auth) AS att_arstart, a.att_auth, a.att_authtype, tv.rn AS rn_Tv,io.rn_ispob,a.att_var
FROM
    tb_audi a
     JOIN w_ktsg.tb_isp_ob_s io ON a.att_arid=io.att_arid AND a.att_objtype=io.objtype
     LEFT JOIN w_ktsg.tb_tv tv ON io.rn_ispob=tv.rn_ispob
WHERE
      a.att_authtype  IN (1010,1008)
      AND a.att_limit IS NULL      
      AND a.att_auth=c1.rn
UNION ALL
SELECT a.att_arstart,a.att_auth,a.att_authtype, tvs.rn_tv,tv.rn_ispob,a.att_var
FROM
    tb_audi a
     JOIN w_ktsg.tb_tv_s tvs ON a.att_arid=tvs.att_arid AND a.att_objtype=tvs.objtype
     LEFT JOIN w_ktsg.tb_tv tv ON tvs.rn_tv=tv.rn
WHERE
      a.att_authtype  IN (1010,1008)
      AND a.att_limit IS NULL
      AND a.att_auth=c1.rn
UNION ALL
SELECT a.att_arstart,a.att_auth,a.att_authtype, mos.rn_tv,tv.rn_ispob,a.att_var
FROM
    w_ktsg.tb_audi a
            JOIN w_ktsg.tb_poz_mo_s mos ON a.att_arid=mos.att_arid AND a.att_objtype=mos.objtype
            LEFT JOIN w_ktsg.tb_tv tv ON mos.rn_tv=tv.rn
WHERE
      a.att_authtype  IN (1010,1008)
      AND a.att_limit IS NULL
      AND a.att_auth=c1.rn
UNION ALL
SELECT a.att_arstart,a.att_auth,a.att_authtype, (SELECT max(ttt2.rn_tv) FROM w_ktsg.tb_poz_mo_s ttt2 WHERE ttt2.att_arid=tds.arid_pozmo),
(SELECT max(tv.RN_ISPOB) FROM w_ktsg.tb_poz_mo_s ttt2
JOIN w_ktsg.v_tv tv ON tv.Rn=ttt2.rn_tv
WHERE ttt2.att_arid=tds.arid_pozmo),a.att_var
FROM
    tb_audi a
            JOIN w_ktsg.tb_tehn_dob_s tds ON a.att_arid=tds.att_arid AND a.att_objtype=tds.objtype
WHERE
      a.att_authtype  IN (1010,1008) AND a.att_limit IS NULL
      AND a.att_auth=c1.rn
UNION ALL
SELECT a.att_arstart,a.att_auth,a.att_authtype, zs.rn_tv,tv.rn_ispob,a.att_var
FROM
    tb_audi a
          JOIN w_ktsg.tb_t_zag_s zs ON a.att_arid=zs.att_arid AND a.att_objtype=zs.objtype
            LEFT JOIN w_ktsg.tb_tv tv ON zs.rn_tv=tv.rn
WHERE
      a.att_authtype  IN (1010,1008) AND a.att_limit IS NULL
      AND a.att_auth=c1.rn
 UNION ALL
SELECT a.att_arstart,a.att_auth,a.att_authtype, u.rn_tv,tv.RN_ISPOB,a.att_var
FROM
    tb_audi a
    JOIN w_ktsg.tb_ust_comp_s u ON a.att_arid=u.att_arid AND a.att_objtype=u.objtype
    LEFT JOIN w_ktsg.tb_tv tv ON u.rn_tv=tv.rn
WHERE
      a.att_authtype  IN (1010,1008) AND a.att_limit IS NULL
      AND a.att_auth=c1.rn
UNION ALL
SELECT a.att_arstart,a.att_auth,a.att_authtype, (SELECT mos.rn_tv FROM  w_ktsg.tb_poz_mo_s mos WHERE mos.att_arid=ob.arid_pozmo),
(SELECT tv.RN_ISPOB FROM  w_ktsg.tb_poz_mo_s mos
JOIN w_ktsg.v_tv tv ON mos.rn_tv=tv.rn
WHERE mos.att_arid=ob.arid_pozmo),a.att_var
FROM
    tb_audi a
    JOIN w_ktsg.tb_obr_s ob ON a.att_arid=ob.att_arid AND a.att_objtype=ob.objtype
WHERE
      a.att_authtype  IN (1010,1008)  AND a.att_limit IS NULL
      AND a.att_auth=c1.rn
)abc;

  END LOOP;
COMMIT;
EXECUTE IMMEDIATE 'create index I_MV_PERSOGL_T_ISP on MV_PERSOGL_TV_T (RN_ISPOB)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
EXECUTE IMMEDIATE 'create index I_MV_PERSOGL_T_RNPS on MV_PERSOGL_TV_T (RN_PERSOGL)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
EXECUTE IMMEDIATE 'create index I_MV_PERSOGL_T_RNTV on MV_PERSOGL_TV_T (RN_TV)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
  w_mmkt.p_send_text_mail('ryls@d140.vz','W_MMKT p_fill_mv_persogl_tv', 'Выполнено успешно');
end p_fill_mv_persogl_tv;
/

----------------------------------------
--  Changed procedure p_fill_oocp_cp  --
----------------------------------------
create or replace procedure w_mmkt.p_fill_oocp_cp is
BEGIN
FOR c IN (
    SELECT t.index_name FROM user_indexes t WHERE t.index_name IN ('I_CP_CH','I_CP_K')
) LOOP
  EXECUTE IMMEDIATE 'DROP INDEX ' || c.index_name;
END LOOP;
DELETE FROM tb_cp;
INSERT INTO tb_cp
--Состав ММК
select --+ star first_rows
--distinct
      --tvc.rn,
      s2mc.kdce AS kdce_ch,      
      s2m.kdce AS kdce_k, 
      round(uca.kol,3) AS kol,
      mp.kornaim AS cexsb
from w_ktsg.mv_isp_ob ios_k
     JOIN w_ktsg.mv_tv tvk ON ios_k.rn=tvk.rn_ispob
     JOIN tb_s2_mmk_kdce s2m ON tvk.rn=s2m.rn_tv
     inner join (
                select ucj.RN_TV as RN_TV,
                        ucj.RN_ISPOB_CH as RN_ISPOB_CH,
                        ucj.RN_POZMO as RN_POZMO,
                        ucj.KOL,                        
                        ei15.kornaim AS eik,
                        'У' AS typ
                from w_ktsg.mv_ust_comp ucj
                LEFT JOIN w_ei.tb_ei ei15 ON ucj.RN_EI_UST=ei15.rn                
                union all
                select oa.RN_TV_IZG as RN_TV,
                        tvobr.rn_ispob as RN_ISPOB_CH,
                        mosobr.rn_pozmo as RN_POZMO,
                        oa.TEHNKOL/NVL(oa.MAXPART,1) as KOL,
                        NULL AS eik,
                        'О' AS typ
                from w_ktsg.mv_obr oa
                inner join w_ktsg.tb_tv tvobr on tvobr.rn=oa.RN_TV_OBR
                inner join w_ktsg.tb_poz_mo_s mosobr on mosobr.att_arid=oa.ARID_POZMO                
                /*UNION ALL
                --Вхождение в товар
                SELECT --+ star
                  us.rn_Tv,
                  us.RN_ISPOB_CH,
                  us.RN_POZMO,
                  us.KOL,
                  'КГ' AS eik,
                  'Т' AS typ
                   FROM                  
                  w_ktsg.v_tv tv
                  JOIN w_ktsg.mv_ust_comp us ON tv.RN_ISPOB=us.RN_ISPOB_CH
                  JOIN w_ei.tb_ei ei16 ON us.RN_EI_UST=ei16.rn
                  WHERE  us.rn_Tv=494707\*это товар*\*/
           )    
           uca on uca.RN_TV=tvk.RN                 
                inner join w_ktsg.mv_isp_ob oc on uca.RN_ISPOB_CH=oc.rn
                     JOIN tb_s2_mmk_kdce s2mc ON oc.rn=s2mc.rn_ispob
                left join w_ktsg.mv_tv tvc on oc.RN=tvc.RN_ISPOB
     left join w_ktsg.mv_poz_mo ms on uca.RN_POZMO=ms.RN
     left join w_mp.tb_podr mp on ms.RN_PODR=mp.rn
     WHERE ios_k.rn_vid_ispob<>1021;
--Состав Конфигурации которые созданы на основе ММК
INSERT INTO tb_cp
select --+ star first_rows
--distinct
      --tvc.rn,
      s2mc.kdce AS kdce_ch,      
      s2m.kdce AS kdce_k, 
      round(nvl(i.kol,uca.kol),3) AS kol,
      coalesce(decode(mosk.rn_pod,0,'000',pdk.kornaim),mmk_k_mp.kornaim,mp.kornaim) AS cexsb
from w_ktsg.mv_isp_ob ios_k
     JOIN tb_s2_mmk_kdce s2m ON ios_k.rn=s2m.rn_ispob
     JOIN w_konfig.tb_konf k ON k.rn=ios_k.rn
     inner join (
                select ucj.RN_TV as RN_TV,
                        ucj.RN_ISPOB_CH as RN_ISPOB_CH,
                        ucj.RN_POZMO as RN_POZMO,
                        ucj.KOL,
                        ei15.kornaim AS eik,
                        'У' AS typ
                from w_ktsg.mv_ust_comp ucj
                LEFT JOIN w_ei.tb_ei ei15 ON ucj.RN_EI_UST=ei15.rn
                union all
                select oa.RN_TV_IZG as RN_TV,
                        tvobr.rn_ispob as RN_ISPOB_CH,
                        mosobr.rn_pozmo as RN_POZMO,
                        oa.TEHNKOL/NVL(oa.MAXPART,1) as KOL,
                        NULL AS eik,
                        'О' AS typ
                from w_ktsg.mv_obr oa
                inner join w_ktsg.tb_tv tvobr on tvobr.rn=oa.RN_TV_OBR
                inner join w_ktsg.tb_poz_mo_s mosobr on mosobr.att_arid=oa.ARID_POZMO
           )
           uca on uca.RN_TV=k.rn_tv_mmk
           LEFT JOIN w_konfig.v0_ust_comp_s i ON i.RN_K=k.rn AND uca.RN_ISPOB_CH=i.RN_CH AND uca.RN_POZMO=i.RN_POZ_MO
           LEFT JOIN w_konfig.v0_poz_mo_s mosk ON i.RN_POZ_MO=mosk.RN_POZ_MO
           LEFT JOIN w_mp.tb_podr pdk ON mosk.RN_pod=pdk.rn           
           LEFT JOIN w_ktsg.mv_poz_mo mos ON i.RN_POZ_MO=mos.rn
           LEFT JOIN w_mp.tb_podr mmk_k_mp ON mos.rn_podr=mmk_k_mp.rn
                LEFT join w_ktsg.mv_isp_ob oc on uca.RN_ISPOB_CH=oc.rn
                     JOIN tb_s2_mmk_kdce s2mc ON oc.rn=s2mc.rn_ispob
                left join w_ktsg.mv_tv tvc on oc.RN=tvc.RN_ISPOB
     left join w_ktsg.mv_poz_mo ms on uca.RN_POZMO=ms.RN
     left join w_mp.tb_podr mp on ms.RN_PODR=mp.rn
     WHERE ios_k.rn_vid_ispob=1021  AND nvl(i.kol,uca.kol)<>0
--     AND ios_k.obozn='СМ2.01.000-005'
;
--Состав Конфигураций, являющихся комплектом
INSERT INTO tb_cp
select --+ star first_rows
--distinct
      s2mc.kdce AS kdce_ch,      
      s2m.kdce AS kdce_k, 
      round(ucj2.kol,3) AS kol,
      decode(mosk.rn_pod,0,'000',pdk.kornaim) AS cexsb
from w_ktsg.mv_isp_ob ios_k
     JOIN tb_s2_mmk_kdce s2m ON ios_k.rn=s2m.rn_ispob
     JOIN w_konfig.tb_konf k ON k.rn=ios_k.rn
     JOIN w_konfig.v0_ust_comp_s ucj2 ON ucj2.RN_K=k.rn     
     JOIN w_konfig.v0_poz_mo_s mosk ON ucj2.RN_POZ_MO=mosk.RN_POZ_MO
     JOIN w_mp.tb_podr pdk ON mosk.RN_pod=pdk.rn
     JOIN tb_s2_mmk_kdce s2mc ON ucj2.RN_CH=s2mc.rn_ispob                
     WHERE ios_k.rn_vid_ispob=1021;
     
EXECUTE IMMEDIATE 'create index I_CP_CH on TB_CP (KDCE_CH)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
EXECUTE IMMEDIATE 'create index I_CP_K on TB_CP (KDCE_K)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';

end p_fill_oocp_cp;
/
------------------------------------------
--  Changed procedure p_fill_oocp_kdce  --
------------------------------------------
create or replace procedure w_mmkt.p_fill_oocp_kdce is
begin
    DELETE FROM tb_s2_mmk_kdce;
  INSERT INTO tb_s2_mmk_kdce
SELECT io.rn,tvc.rn,ROWNUM/*,io.obozn,tvc.vi,w_ktsg.f_ec_spr(tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp),tvc.tvnaim/*,
tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp*//*,
(SELECT COUNT(*) FROM w_ktsg.mv_t_zag z WHERE z.rn_ispob_zag=io.rn) cz,
(SELECT COUNT(*) FROM w_ktsg.mv_ust_comp u WHERE u.rn_ispob_ch=io.rn) cu,
(SELECT COUNT(*) FROM w_ktsg.tb_izm_Tv t JOIN w_ktsg.tb_tv i ON t.rn_tv=i.rn WHERE i.RN_ISPOB=io.rn) ci,
(SELECT COUNT(*) FROM w_ktsg.tb_izm_Tv t JOIN w_ktsg.tb_tv i ON t.rn_tv=i.rn 
                      JOIN w_ktsg.tb_per_sogl p ON t.RN_PERSOGL=p.rn AND p.ind_stexist IN ('Р','С')
WHERE i.RN_ISPOB=io.rn) cir*/
FROM
w_ktsg.mv_isp_ob io
                 JOIN w_ktsg.tb_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
                left join w_ktsg.mv_tv tvc on io.rn=tvc.rn_ispob    
                left join w_ktsg.tb_tv tv on io.rn=tv.rn_ispob
                WHERE /*tvc.rn IS NULL
                      AND*/ vio.kornaim<>'Р' AND io.tip_ispob<>'О'                      
--Убираем материалы которые никуда не идут
AND w_ktsg.f_ec_spr(tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp)<>' '
AND NOT (/*io.kornaim IN ('М','П') AND io.tip_ispob='П' AND*/ tv.rn IS NULL
--AND (SELECT COUNT(*) FROM w_ktsg.mv_t_zag z WHERE z.rn_ispob_zag=io.rn)=0
AND (SELECT COUNT(*) FROM w_ktsg.mv_ust_comp u WHERE u.rn_ispob_ch=io.rn)=0
)
--Убираем материалы которые идут в состав только рецептов
AND NOT (io.kornaim  IN ('М','П') AND io.tip_ispob='П' AND tv.rn IS NULL
--AND (SELECT COUNT(*) FROM w_ktsg.mv_t_zag z WHERE z.rn_ispob_zag=io.rn)=0
AND (SELECT COUNT(*) FROM w_ktsg.mv_ust_comp u WHERE u.rn_ispob_ch=io.rn)=
(SELECT COUNT(*) FROM w_ktsg.mv_ust_comp u2 
        JOIN w_ktsg.tb_tv tv2 ON u2.rn_tv=tv2.rn
        JOIN w_ktsg.mv_isp_ob u3 ON tv2.rn_ispob=u3.rn
WHERE u2.rn_ispob_ch=io.rn AND u3.kornaim='Р')
)
AND NOT ((SELECT COUNT(*) FROM w_mmkt.mv_persogl_tv t WHERE t.RN_ISPOB=io.rn)=1
    AND (SELECT COUNT(*) FROM w_mmkt.mv_persogl_tv t 
                      JOIN w_ktsg.tb_per_sogl p ON t.RN_PERSOGL=p.rn AND p.ind_stexist IN ('Р','С')
WHERE t.RN_ISPOB=io.rn)=1
)
AND NOT  (
(SELECT COUNT(*) FROM w_ktsg.tb_izm_Tv t JOIN w_ktsg.tb_tv i ON t.rn_tv=i.rn WHERE i.RN_ISPOB=io.rn)=1
AND (SELECT COUNT(*) FROM w_ktsg.tb_izm_Tv t JOIN w_ktsg.tb_tv i ON t.rn_tv=i.rn 
                      JOIN w_ktsg.tb_per_sogl p ON t.RN_PERSOGL=p.rn AND p.ind_stexist IN ('Р','С')
WHERE i.RN_ISPOB=io.rn)=1 );

end p_fill_oocp_kdce;
/
----------------------------------------
--  Changed procedure p_fill_oocp_mn  --
----------------------------------------
create or replace procedure w_mmkt.p_fill_oocp_mn is
begin
  DELETE FROM tb_mn;
FOR c IN (SELECT t.index_name FROM user_indexes t WHERE t.index_name IN ('I_MN_KDCE','I_MN_NN')) LOOP
    EXECUTE IMMEDIATE 'drop INDEX ' || c.index_name;    
END LOOP;
INSERT INTO tb_mn
select --+ star first_rows
--distinct
      s2m.kdce,
      nvl(sold.oldnn,sold2.oldnn) as NOMN_S,
      ei.code_vz as ED_S,
/*      nvl2(z.RN_TV,
           decode(z.NORMRASH,0,0.00001,z.NORMRASH),
           decode(to_number(tvc.IND_NALCOMP),1,NULL,1) )*/
      round(nvl(z.NORMRASH,0.0) ,8) as NRM_S,
      round(nvl(tvc.TVMASSA,0.0),8) as CHVESDCE_S,
      nvl(z.KOLDETZAG,1) as KOLIZZAG_S,
      z.VIDZAG AS VID_ZAG_S, --В формируемых изменениях не меняется
      round(nvl(z.VESZAG,0),8) as VESZAG_S,      
      CASE
       WHEN oz.obozn is not null then 
            CASE WHEN length(oz.obozn||'@'||z.geomr_dl||'*'||z.geomr_sh) >50 THEN
                 rpad(oz.obozn||'@'||z.geomr_dl||'*'||z.geomr_sh,50)
            ELSE
                 oz.obozn||'@'||z.geomr_dl||'*'||z.geomr_sh
            END
       WHEN tvc.ind_nalcomp='1' THEN 'СБОРКА'
       /*WHEN oz.obozn IS NULL THEN
       --Если признак два и нет обозначения материала - то запихиваем обознач и наим.
            rpad(oc.obozn || nvl(tvc.tvnaim,' '),50)
       else rpad(' ',50)*/
      END as RAZMZAG_S/*,
      
      '00' as PRICHINA,
      rpad(translate(oc.obozn,', ','.'),40) as DCE_CH_B,
      rpad(nvl(tvc.VI,'00'),2) as VI_CH_B,
      rpad(w_ktsg.F_EC_SPR(tvc.rn,oc.tip_ispob,oc.rn_vid_ispob,oc.ind_mizg,tvc.IND_NALCOMP),
           1) as SPR_B,
      rpad(translate(ios_k.obozn,', ','.'),40) as DCE_K_B,
      rpad(nvl(tvk.VI,'00'),2) as VI_K_B,
      rpad(nvl(tvc.tvnaim,oc.obozn),15) as NAIM_DCE_S,
      rpad( w_ktsg.F_EC_NUMB(uca.KOL),8) as KPRIM_S,
      --Маршрут стало
      rpad(w_ktsg.F_EC_MOST(tvc.RN)||decode(uca.typ,'О',' ' ,null,' ',rpad(mp.kornaim,3)||decode(ios_k.obozn,'ТОВАР','ОТП','СБР')) ,476) as MO_ST,
      
      rpad(case
       WHEN oz.obozn is not null then rpad(oz.obozn||'@'||z.geomr_dl||'*'||z.geomr_sh,50)
       WHEN tvc.ind_nalcomp='1' THEN rpad('СБОРКА',50)
       WHEN oz.obozn IS NULL THEN
       --Если признак два и нет обозначения материала - то запихиваем обознач и наим.
            rpad(oc.obozn || nvl(tvc.tvnaim,' '),50)
       else rpad(' ',50)
      end,50) as RAZMZAG_S,
      --rpad(' ',3) as ED_S, --В формируемых изменениях не меняется
      
      rpad(nvl(W_KTSG.F_EC_MOST_POL(tvc.RN,1),rpad(mp.kornaim,3) ||'СБР') ,3) as CEXPM_S,
      rpad(' ',14) as NNOM_B, --Для формируемых изменений несущественно
      rpad(' ',40) as DCE_CH_S, --В формируемых изменениях не меняется
      rpad(' ',2) as VI_CH_S, --В формируемых изменениях не меняется
      ' ' as SPR_CH_S, --В формируемых изменениях не меняется
      rpad(' ',40) as DCE_K_S, --В формируемых изменениях не меняется
      rpad(' ',2) as VI_K_S, --В формируемых изменениях не меняется
      rpad(' ',2) as SPR_ISP, --На ЕС не передается
      rpad('00000',5) as NOM_MMV, --На ЕС не передается
      rpad(' ',10) as OTM, --На ЕС не передается
      rpad(' ',8) as TEHN_PRIM, --На ЕС не передается
      rpad(' ',3) as CEX_ISP, --На ЕС не передается
      rpad(' ',8) as NAISP, --На ЕС не передается
      rpad(' ',3) as CEX_ISP1, --На ЕС не передается
      rpad(' ',8) as NA_PODBOR, --На ЕС не передается
      rpad(' ',3) as CEX_PDB --На ЕС не передается*/
from /*JOIN w_ktsg.mv_isp_ob ios_k ON s2m.rn_ispob=ios_k.rn
     JOIN w_ktsg.mv_tv tvk ON ios_k.rn=tvk.rn_ispob AND s2m.rn_tv=tvk.rn
     inner join (
                select ucj.RN_TV as RN_TV,
                        ucj.RN_ISPOB_CH as RN_ISPOB_CH,
                        ucj.RN_POZMO as RN_POZMO,
                        ucj.KOL,
                        ei15.kornaim AS eik,
                        'У' AS typ
                from w_ktsg.mv_ust_comp ucj
                LEFT JOIN w_ei.tb_ei ei15 ON ucj.RN_EI_UST=ei15.rn
                union all
                select oa.RN_TV_IZG as RN_TV,
                        tvobr.rn_ispob as RN_ISPOB_CH,
                        mosobr.rn_pozmo as RN_POZMO,
                        oa.TEHNKOL/NVL(oa.MAXPART,1) as KOL,
                        NULL AS eik,
                        'О' AS typ
                from w_ktsg.mv_obr oa
                inner join w_ktsg.tb_tv tvobr on tvobr.rn=oa.RN_TV_OBR
                inner join w_ktsg.tb_poz_mo_s mosobr on mosobr.att_arid=oa.ARID_POZMO
                \*UNION ALL
                --Вхождение в товар
                SELECT --+ star
                  us.rn_Tv,
                  us.RN_ISPOB_CH,
                  us.RN_POZMO,
                  us.KOL,
                  'КГ' AS eik,
                  'Т' AS typ
                   FROM
                  w_ktsg.v_tv tv
                  JOIN w_ktsg.mv_ust_comp us ON tv.RN_ISPOB=us.RN_ISPOB_CH
                  JOIN w_ei.tb_ei ei16 ON us.RN_EI_UST=ei16.rn
                  WHERE  us.rn_Tv=494707\*это товар*\*\
           )    
           uca on uca.RN_TV=tvk.RN*/                 
                /*inner join*/ 
                tb_s2_mmk_kdce s2m 
                JOIN w_ktsg.mv_isp_ob oc ON s2m.rn_ispob=oc.rn--on uca.RN_ISPOB_CH=oc.rn
                left join w_ktsg.mv_tv tvc on oc.RN=tvc.RN_ISPOB AND s2m.rn_tv=tvc.rn
/*     left join w_ktsg.mv_poz_mo ms on uca.RN_POZMO=ms.RN
     left join w_mp.tb_podr mp on ms.RN_PODR=mp.rn
*/     left join w_ktsg.mv_t_zag z on tvc.RN=z.rn_tv
     LEFT join w_ktsg.mv_isp_ob oz on z.RN_ISPOB_ZAG=oz.RN
     left join w_sprmat.tb_mat_spr s on oz.RN_MAT=s.rn
     left join w_sprmat.tb_mat_oldnn sold on s.rn=sold.material_rn and sold.is_active=1
     left join w_ei.tb_ei ei on z.rn_ei=ei.rn
     left join w_sprmat.tb_mat_spr s2 on oc.RN_MAT=s2.rn
     left join w_sprmat.tb_mat_oldnn sold2 on s2.rn=sold2.material_rn and sold2.is_active=1;
-- Create/Recreate indexes 
EXECUTE IMMEDIATE 'create index I_MN_KDCE on TB_MN (KDCE)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
EXECUTE IMMEDIATE 'create index I_MN_NN on TB_MN (NN)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';

end p_fill_oocp_mn;
/
----------------------------------------
--  Changed procedure p_fill_oocp_mo  --
----------------------------------------
create or replace procedure w_mmkt.p_fill_oocp_mo is
begin
  DELETE FROM tb_mo;
  FOR c IN (SELECT t.index_name FROM user_indexes t WHERE t.index_name IN ('I_MO_CEX','I_MO_KDCE')) LOOP
      EXECUTE IMMEDIATE 'drop index ' || c.index_name;
  END LOOP;
  FOR c1 IN (SELECT * FROM tb_s2_mmk_kdce  --WHERE rownum<10000
  ) LOOP
INSERT INTO tb_mo
SELECT g.kdce,rank() over (PARTITION BY kdce ORDER BY pornom)*100 AS nmp,
       ceh,
       vo,
       SUM(nvl(td,0)) over (PARTITION BY kdce ORDER BY pornom DESC) AS td
FROM (
-- Позиции из ММК
SELECT --+first_rows leading(s2m) use_nl(s2m io tvc) use_nl(io vio) push_pred(mo)
io.rn,
tvc.rn AS rn_Tv,s2m.kdce,io.obozn AS dce,tvc.vi,
io.pack_obozn AS dce_s,
nvl(mo.rn,mo2.rn) AS rn_mo,
nvl(mo.pornom,mo2.pornom) AS pornom,
substr(coalesce(p.kornaim,p3.kornaim,p2.kornaim),1,3) as ceh,
substr(coalesce(v.kornaim,v3.kornaim,v2.kornaim),1,3) as vo,
nvl((select nvl(sum(tds.TEHNDOB),0)+SUM(nvl(nvl2(tds.tehndob,0,tds.TEHNKOL/tds.MAXPART),0)) from w_ktsg.mv_TEHN_DOB tds where tds.ARID_POZMO=nvl(mo.att_arid,mo2.att_arid)
                   ),0) as td
FROM
tb_s2_mmk_kdce s2m
JOIN w_ktsg.mv_isp_ob io ON s2m.rn_ispob=io.rn
                JOIN w_ktsg.tb_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
                LEFT join w_ktsg.tb_tv tvc on io.rn=tvc.rn_ispob AND tvc.rn=s2m.rn_tv
                LEFT JOIN w_ktsg.mv_POZ_MO mo ON tvc.rn=mo.rn_tv                                
                LEFT JOIN w_konfig.tb_konf kf ON io.rn=kf.rn AND vio.kornaim='Ф'
                LEFT JOIN w_ktsg.mv_POZ_MO mo2 ON kf.rn_tv_mmk=mo2.rn_tv
                LEFT JOIN w_konfig.tb_poz_mo m2 ON mo2.rn=m2.rn_poz_mo
                LEFT JOIN w_konfig.tb_poz_mo mok2 ON io.rn=mok2.rn AND mok2.rn_poz_mo=mo2.rn
                LEFT JOIN w_konfig.V0_POZ_MO_S mosk ON mosk.RN_POZ_MO=mok2.rn_poz_mo AND mo2.rn=mosk.RN_POZ_MO AND mosk.PR=2
                LEFT JOIN w_konfig.tb_poz_mo mok ON io.rn=mok.rn AND mok.rn_poz_mo=mo2.rn
                LEFT JOIN w_konfig.V0_POZ_MO_S mosku ON mosku.RN_POZ_MO=mok.rn_poz_mo AND mo2.rn=mosku.RN_POZ_MO AND mosku.PR=1
                LEFT join W_MP.TB_PODR p ON mo.RN_PODR=p.RN
                LEFT join W_VO.TB_VO v ON mo.RN_VO=v.RN
                LEFT join W_MP.TB_PODR p2 ON mo2.RN_PODR=p2.RN
                LEFT join W_VO.TB_VO v2 ON mo2.RN_VO=v2.RN
                LEFT join W_MP.TB_PODR p3 ON mosk.RN_POD=p3.RN
                LEFT join W_VO.TB_VO v3 ON mosk.RN_VO=v3.RN
WHERE s2m.kdce=c1.kdce
AND mosku.RN_POZ_MO IS NULL
UNION ALL
SELECT --+first_rows leading(s2m) use_nl(s2m io tvc) use_nl(io vio) push_pred(mo)
io.rn,NULL,s2m.kdce,io.obozn AS dce,NULL AS vi,--w_ktsg.f_ec_spr(tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp) AS spr,
/*tvc.tvnaim AS naim_dce,*/ io.pack_obozn AS dce_s,
mok.rn,
mok.por_nom,
substr(p.kornaim,1,3) as ceh,
substr(v.kornaim,1,3) as vo,
0
FROM
tb_s2_mmk_kdce s2m
               JOIN w_ktsg.mv_isp_ob io ON s2m.rn_ispob=io.rn
                JOIN w_ktsg.tb_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn AND vio.kornaim='Ф'
                JOIN w_konfig.tb_konf kf ON io.rn=kf.rn
                JOIN w_konfig.tb_POZ_MO mok ON kf.rn=mok.rn
                JOIN w_konfig.V0_POZ_MO_S mosk ON mok.rn_poz_mo=mosk.RN_POZ_MO AND mosk.PR=3
                LEFT JOIN W_MP.TB_PODR p on mosk.RN_POD=p.RN
                JOIN W_VO.TB_VO v   on mosk.RN_VO=v.RN
WHERE s2m.kdce=c1.kdce --330230                
) g ORDER BY pornom;
END LOOP;
EXECUTE IMMEDIATE 'create bitmap index I_MO_CEX on TB_MO (CEX)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
EXECUTE IMMEDIATE 'create index I_MO_KDCE on TB_MO (KDCE)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
end p_fill_oocp_mo;
/
----------------------------------------
--  Changed procedure p_fill_oocp_oo  --
----------------------------------------
create or replace procedure w_mmkt.p_fill_oocp_oo is
begin
  BEGIN
  EXECUTE IMMEDIATE 'alter table TB_OO drop constraint PK_OO_KDCE cascade';
  EXCEPTION
          WHEN OTHERS THEN NULL;
  END;
  FOR c in (SELECT t.index_name
      FROM user_indexes t WHERE t.index_name 
      IN ('I_OO_DCE','I_OO_DCE_S','I_OO_SPR')
  ) LOOP
    EXECUTE IMMEDIATE 'drop INDEX ' || c.index_name;
  END LOOP;
  DELETE FROM tb_oo;
  INSERT INTO tb_oo
SELECT --+first_rows leading(io) use_nl(s2m io tvc) use_nl(io vio)
s2m.kdce,
CASE WHEN length(io.obozn)>40 THEN
    rpad(io.obozn,40)
ELSE
    io.obozn
END AS dce,
nvl(tvc.vi,'00') AS vi,
w_ktsg.f_ec_spr(tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp) AS spr,
CASE WHEN length(tvc.tvnaim)>15 THEN
     rpad(tvc.tvnaim,15)
ELSE
     tvc.tvnaim
END AS naim_dce, 
CASE WHEN length(io.pack_obozn)>40 THEN
rpad(io.pack_obozn,40)
ELSE
io.pack_obozn
END AS dce_s/*,
tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp*/
FROM
tb_s2_mmk_kdce s2m
JOIN w_ktsg.mv_isp_ob io ON s2m.rn_ispob=io.rn
                 JOIN w_ktsg.tb_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
                left join w_ktsg.mv_tv tvc on io.rn=tvc.rn_ispob AND tvc.rn=s2m.rn_tv
                LEFT JOIN w_kts.n3spr n3 ON n3.dce=io.obozn AND tvc.vi=n3.v
                WHERE /*tvc.rn IS NULL
                      AND*/ vio.kornaim<>'Р' AND io.tip_ispob<>'О' AND vio.kornaim<>'М'
AND NOT (n3.dce IS NULL AND io.tip_ispob='М')                      
AND w_ktsg.f_ec_spr(tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp)<>' ';

  INSERT INTO tb_oo
SELECT --+first_rows leading(io) use_nl(s2m io tvc) use_nl(io vio)
s2m.kdce,
CASE WHEN length(io.obozn)>40 THEN
    rpad(io.obozn,40)
ELSE
    io.obozn
END AS dce,
nvl(tvc.vi,'00') AS vi,w_ktsg.f_ec_spr(tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp) AS spr,
CASE WHEN length(tvc.tvnaim)>15 THEN
     rpad(tvc.tvnaim,15)
ELSE
     tvc.tvnaim
END AS naim_dce, 
CASE WHEN length(io.pack_obozn)>40 THEN
rpad(io.pack_obozn,40)
ELSE
io.pack_obozn
END AS dce_s/*,
tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp*/
FROM
tb_s2_mmk_kdce s2m
JOIN w_ktsg.mv_isp_ob io ON s2m.rn_ispob=io.rn
                 JOIN w_ktsg.tb_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
                left join w_ktsg.mv_tv tvc on io.rn=tvc.rn_ispob AND tvc.rn=s2m.rn_tv
                LEFT JOIN w_kts.n3spr n3 ON n3.dce=io.obozn AND tvc.vi=n3.v
                WHERE /*tvc.rn IS NULL
                      AND*/ vio.kornaim<>'Р' AND io.tip_ispob<>'О' AND vio.kornaim='М'
AND w_ktsg.f_ec_spr(tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp)<>' '
--AND NOT (n3.dce IS NULL AND io.tip_ispob='М')
AND 
                      EXISTS (SELECT NULL FROM w_ktsg.mv_ust_comp u WHERE u.rn_ispob_ch=io.rn);-- Create/Recreate primary, unique and foreign key constraints 
EXECUTE IMMEDIATE '
alter table tb_OO
  add constraint PK_OO_KDCE primary key (KDCE)
  using index 
  tablespace TS_NOTLOG
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )'; 
EXECUTE IMMEDIATE 'create index I_OO_DCE on TB_OO (DCE, VI)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
EXECUTE IMMEDIATE 'create index I_OO_DCE_S on TB_OO (DCE_S)
  tablespace TS_NOTLOG
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
EXECUTE IMMEDIATE 'create bitmap index I_OO_SPR on TB_OO (SPR)
  tablespace TS_NOTLOG
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';

end p_fill_oocp_oo;
/
----------------------------------------
--  New procedure p_fill_oocp_mo_old  --
----------------------------------------
create or replace procedure w_mmkt.p_fill_oocp_mo_old is
begin
  DELETE FROM tb_mo;
  FOR c IN (SELECT t.index_name FROM user_indexes t WHERE t.index_name IN ('I_MO_CEX','I_MO_KDCE')) LOOP
      EXECUTE IMMEDIATE 'drop index ' || c.index_name;
  END LOOP;
INSERT INTO tb_mo
SELECT g.kdce,rank() over (PARTITION BY kdce ORDER BY pornom)*100 AS nmp,-- g.pornom,
       ceh,
       vo,
       CASE WHEN (SELECT COUNT(*) FROM w_ktsg.mv_poz_mo mm JOIN w_ktsg.mv_tehn_dob tt ON mm.att_arid=tt.arid_pozmo
       WHERE mm.rn_tv=g.rn)>0 THEN
       SUM(nvl(td,0)) over (PARTITION BY kdce ORDER BY pornom DESC)
       ELSE
        0
       END AS td
FROM (
SELECT --+first_rows leading(s2m) use_nl(s2m io tvc) use_nl(io vio)
tvc.rn,s2m.kdce,io.obozn AS dce,tvc.vi,--w_ktsg.f_ec_spr(tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp) AS spr,
tvc.tvnaim AS naim_dce, io.pack_obozn AS dce_s,
mo.pornom,
substr(p.kornaim,1,3) as ceh,
substr(v.kornaim,1,3) as vo,
(select decode(nvl(sum(tds.TEHNDOB),0)+SUM(nvl(nvl2(tds.tehndob,0,tds.TEHNKOL/tds.MAXPART),0)),0,NULL,nvl(sum(tds.TEHNDOB),0)+SUM(nvl(nvl2(tds.tehndob,0,tds.TEHNKOL/tds.MAXPART),0))) from w_ktsg.mv_TEHN_DOB tds where tds.ARID_POZMO=mo.att_ARID
                   ) as td
/*,
tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp*/
FROM
tb_s2_mmk_kdce s2m
JOIN w_ktsg.mv_isp_ob io ON s2m.rn_ispob=io.rn
                JOIN w_ktsg.tb_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
                join w_ktsg.mv_tv tvc on io.rn=tvc.rn_ispob AND tvc.rn=s2m.rn_tv
                JOIN --w_ktsg.mv_POZ_MO mo ON tvc.rn=mo.rn_tv                                
                (SELECT mo2.rn_tv,pornom,nvl(mosk.rn_pod,mos.rn_podr)AS rn_podr,
                        nvl(mosk.RN_VO,mos.rn_vo) AS rn_vo, 
                        nvl(mosk.att_ARID,mos.att_arid) AS att_arid
                        FROM w_ktsg.V_POZ_MO mo2
                            INNER JOIN w_ktsg.V0_POZ_MO_S mos on mo2.RN=mos.RN_POZMO
                            LEFT JOIN w_konfig.V0_poz_mo_s mosk ON mos.RN_POZMO=mosk.RN_POZ_MO AND mosk.pr=2
                   UNION ALL
                   SELECT mok.rn,mok.por_nom,mosk.rn_pod,mosk.rn_vo, mosk.att_arid 
                        FROM  w_konfig.tb_POZ_MO mok 
                            INNER JOIN w_konfig.V0_POZ_MO_S mosk on mok.rn_poz_mo=mosk.RN_POZ_MO AND mosk.PR=3
                ) mo ON tvc.rn=mo.rn_tv
                
                inner join W_MP.TB_PODR p on mo.RN_PODR=p.RN
                inner join W_VO.TB_VO v on mo.RN_VO=v.RN
            where mo.PORNOM>=0                
                AND vio.kornaim<>'Р' AND io.tip_ispob<>'О'
--AND w_ktsg.f_ec_spr(tvc.rn,io.tip_ispob,io.rn_vid_ispob,io.ind_mizg,tvc.ind_nalcomp)<>' '
--AND io.obozn='3Л-01.02.211'
) g;
EXECUTE IMMEDIATE 'create bitmap index I_MO_CEX on TB_MO (CEX)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
EXECUTE IMMEDIATE 'create index I_MO_KDCE on TB_MO (KDCE)
  tablespace MATERIAL
  pctfree 10
  initrans 2
  maxtrans 255
  storage
  (
    initial 64K
    minextents 1
    maxextents unlimited
  )';
end p_fill_oocp_mo_old;
/

--------------------------------
--  Changed type curtyp_vera  --
--------------------------------
CREATE OR REPLACE TYPE W_MMKT.curtyp_vera IS ref_CURSOR ;
/
------------------------------
--  Changed type t_find_tv  --
------------------------------
create or replace type w_mmkt.T_Find_tv as object
(--Иванова Вера 14.02.2007
     Rn number,
     Obozn Varchar2(300),
     vi Varchar2(2),
     TvNaim Varchar2(300),
     m Varchar2(300),
     Nom_num varchar2(200),
     z varchar2(300),
     doly varchar2(50),
     geomr_dl number,
     geomr_sh number,
     ind_komp number    
)
/
-------------------------------------
--  Changed type t_res_trud_oi_el  --
-------------------------------------
create or replace type w_mmkt.t_res_trud_oi_el as object
(
  -- Author  : BRULEV
  -- Created : 09.10.2008 15:54:49
  -- Purpose : Для сверки норматива по цехам
  rn_uzel NUMBER,
  zex VARCHAR2(3),
  tsd NUMBER,
  tk NUMBER,
  tpv NUMBER
)
/
----------------------------------
--  Changed type t_res_trud_oi  --
----------------------------------
create or replace type w_mmkt.t_res_trud_oi as TABLE OF t_res_trud_oi_el;
/
------------------------------
--  Changed type t_tv_info  --
------------------------------
CREATE OR REPLACE TYPE W_MMKT.T_TV_INFO IS OBJECT
-- 24.11.2007 Бельтюков Н.В.
-- 26.05.2008 Бельтюков Н.В. Добавлены столбцы KOL_ZAPUSK, KOL_VYPUSK
-- 17.10.2008 Бельтюков Н.В. Добавлены столбцы IND_OBJ, RN_PS_TV, NOMIZM_TV
-- 20.02.2009 Бельтюков Н.В. Добавлены столбцы IND_NOMZA, IND_NZ_PLAN
-- Тип-запись, возвращаемый функцией поиска ММК
(
     RN           NUMBER,         --RN технол. варианта используемого объекта
     OBOZN        VARCHAR2(255),  --обозначение исполь.объекта
     VI           VARCHAR2(30),   --вариант изготовления технол. варианта
     TVNAIM       VARCHAR2(255),  --наименование технол. варианта
     TVMASSA      NUMBER,          --масса технол. варианта
     DOLY         NUMBER,         --доля изготовления технологического варианта
     IND_NALCOMP  CHAR(1),        --индикатор наличия компонент у объекта
     RN_ISPOB     NUMBER,         --RN исполь.объекта
     RN_MAT       NUMBER,         --RN материала Справочника материалов
     VID_ISPOB    VARCHAR2(30),   --вид использ.объекта
     TIP_ISPOB    CHAR(1),        --тип использ.объекта
     IND_OBJ      VARCHAR2(30),   --индикатор объекта (ММК/ММВ для тех. варианта или описание для используемого объекта)
     IND_NOMZA    CHAR(1),        --индикатор наличия объекта в Номзе 
     IND_NZ_PLAN  CHAR(1),        --индикатор наличия планируемости в Номзе
     RN_PS_TV     NUMBER,         --RN текущего изменения ММК/ММВ
     NOMIZM_TV    VARCHAR2(30),   --номер текущего изменения ММК/ММВ 
     MO_STRING    VARCHAR2(500),  --МО использ.объекта
     TRUD_STRING  VARCHAR2(300),  --информация о труде исполь.объекта
     NN           VARCHAR2(25),   --номенкл. номер объекта (материала из справочника),взятого в качестве заготовки при изготовлениии объекта
     OBOZN_TZAG   VARCHAR2(255),  --обозначение используемого объекта,взятого в качестве заготовки при изготовлениии объекта
     NORMRASH     NUMBER,         --норма расхода заготовки
     GEOMR_DL     NUMBER,         --геометрические размеры заготовки
     GEOMR_SH     NUMBER,         --геометрические размеры заготовки
     KDZ          NUMBER,         --Количество деталей из заготовки
     VESZAG       NUMBER,         --Вес заготовки
     KOL          NUMBER,         --конструктор. кол-во вхождения в сборку(если она задана)
     KOL_ZAPUSK   NUMBER,         --технол.кол-во с учетом всех вышестоящих технол.добавок + собственные технол. добавки
     KOL_VYPUSK   NUMBER,         --технол.кол-во с учетом всех вышестоящих технол.добавок
     EI           VARCHAR2(30)    --единица измерения вхождения в сборку(если она задана)
)
/
----------------------------------
--  Changed type t_tv_info_set  --
----------------------------------
CREATE OR REPLACE TYPE W_MMKT.T_TV_INFO_SET IS TABLE OF T_TV_INFO
/
--------------------------------
--  Changed type t_mmk_izvec  --
--------------------------------
create or replace type w_mmkt.t_mmk_izvec as object
(
      POR_NOM_IZ VARCHAR2(5),
      NOM_TIZM VARCHAR2(5),
      NOM_KIZM VARCHAR2(6),
      PR_IZM VARCHAR2(1),
      PRICHINA VARCHAR2(2),
      DATA_TEK VARCHAR2(6),
      DCE_CH_B VARCHAR2(40),
      VI_CH_B VARCHAR2(2),
      SPR_B VARCHAR2(1),
      DCE_K_B VARCHAR2(40), 
      VI_K_B VARCHAR2(2),
      NAIM_DCE_S VARCHAR2(15),
      KPRIM_S  VARCHAR2(8),
      MO_ST  VARCHAR2(476),
      NOMN_S VARCHAR2(14), --В формируемых изменениях не меняется
      RAZMZAG_S VARCHAR2(50), --В формируемых изменениях не меняется
      ED_S VARCHAR2(3), --В формируемых изменениях не меняется
      CHVESDCE_S VARCHAR2(12), --В формируемых изменениях не меняется
      VESZAG_S VARCHAR2(12), --В формируемых изменениях не меняется
      NRM_S VARCHAR2(12), --В формируемых изменениях не меняется
      KOLIZZAG_S VARCHAR2(7), --В формируемых изменениях не меняется
      VID_ZAG_S VARCHAR2(2), --В формируемых изменениях не меняется
      CEXPM_S VARCHAR2(3), --Для формируемых изменений несущественно
      NNOM_B VARCHAR2(14), --Для формируемых изменений несущественно
      DCE_CH_S VARCHAR2(40), --В формируемых изменениях не меняется
      VI_CH_S VARCHAR2(2), --В формируемых изменениях не меняется
      SPR_CH_S VARCHAR2(1), --В формируемых изменениях не меняется
      DCE_K_S VARCHAR2(40), --В формируемых изменениях не меняется
      VI_K_S VARCHAR2(2), --В формируемых изменениях не меняется
      OTDPRC13 VARCHAR2(24),
      SPR_ISP VARCHAR2(2), --На ЕС не передается
      OB_UZLA VARCHAR2(40), --На ЕС не передается
      NOM_MMV VARCHAR2(5), --На ЕС не передается
      OTM VARCHAR2(10), --На ЕС не передается
      TEHN_PRIM VARCHAR2(8), --На ЕС не передается
      CEX_ISP VARCHAR2(3), --На ЕС не передается
      NAISP VARCHAR2(8), --На ЕС не передается
      CEX_ISP1 VARCHAR2(3), --На ЕС не передается
      NA_PODBOR VARCHAR2(8), --На ЕС не передается
      CEX_PDB varchar2(3)  --На ЕС не передается
)
/
-----------------------------------
--  Changed type t_tb_mmk_izvec  --
-----------------------------------
create or replace type w_mmkt.T_TB_mmk_izvec  as TABLE OF  t_mmk_izvec ;
/
---------------------------------
--  New package pk_mmk_info_r  --
---------------------------------
CREATE OR REPLACE PACKAGE W_MMKT.PK_MMK_INFO_R IS

   -- Author  : BRULEV
   -- Created : 29.06.2006 11:13:50
   -- Purpose :

   -- Public type declarations

   TYPE curtyp IS REF CURSOR;

   -- Public function and procedure declarations
   FUNCTION F_GET_IZMTV (p_rntv IN NUMBER, p_date IN DATE DEFAULT NULL) RETURN tb_izmtv PIPELINED ;
   --
   PROCEDURE P_FIND(P_OBOZN  IN VARCHAR2,
                    P_CONT   IN VARCHAR2,
                    P_KOL    IN INTEGER,
                    P_CURSEL OUT curtyp);

   -- Агафонова Н.С.(11.07.2006)
   FUNCTION F_MO(P_RN IN INTEGER) RETURN VARCHAR2;
   /*PROCEDURE P_FIND_1(P_OBOZN  IN VARCHAR2,
   P_CONT   IN VARCHAR2,
   P_KOL    IN INTEGER,
   P_CURSEL OUT curtyp);  */
   PROCEDURE P_FIND_1(P_OBOZN  IN VARCHAR2,
                      P_CONT   IN VARCHAR2,
                      P_KOL    IN INTEGER,
                      P_PACKED IN VARCHAR2,
                      P_CURSEL OUT curtyp);
   FUNCTION F_TRUD(P_RN IN NUMBER,
            p_dst IN INTEGER DEFAULT 0/*0-только вед, 1-тетрадные, -1 - определение*/,
            p_date IN DATE DEFAULT w_ktsg.pk_values.curdate) RETURN VARCHAR2;
    --*************************************************************
PROCEDURE    p_tv_info(p_rntv IN NUMBER,
                                       p_date IN DATE,
                                             p_tv OUT curtyp);
--*************************************************************
PROCEDURE    p_izd_cexs(p_rntv IN NUMBER,
                                      p_date IN DATE,
                                      p_cur OUT curtyp);
--*************************************************************
PROCEDURE    p_izd_dce_by_cex(p_rntv IN NUMBER,
                        p_cex IN VARCHAR2,
                        p_date IN DATE,
                        p_cur OUT curtyp);
--*************************************************************
PROCEDURE    p_zag(p_rntv IN NUMBER,
                                             p_rzr IN NUMBER DEFAULT 0,
                                             p_zag OUT curtyp
);
--*************************************************************
PROCEDURE    p_all(p_rntv IN NUMBER,
                                    p_date IN DATE,
                                             p_tv OUT curtyp,
                                             p_mo OUT curtyp,
                                             p_zag OUT curtyp,
                                             p_obr OUT curtyp,
                                             p_sost OUT curtyp,
                                             p_vhod OUT curtyp,
                                             p_izmtv OUT curtyp,
                                       p_oinfo OUT curtyp);
--**************************************************************
PROCEDURE    p_info_mo(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_mo OUT curtyp
                         );
--**************************************************************
PROCEDURE    p_info_zag(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_zag OUT curtyp
                         );
--**************************************************************
PROCEDURE    p_info_izm(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_izm OUT curtyp
                         );                         
--**************************************************************
PROCEDURE    p_act_td(p_arid IN NUMBER,
                                       p_DATE IN DATE,
                                       p_td out curtyp);
--**************************************************************
PROCEDURE    p_findizm(p_nomizm IN varchar2,
                                       p_typ IN INTEGER DEFAULT -1, --Тип извещения
                                       p_status IN VARCHAR2 DEFAULT 'РСУН', --Извещения с какими статусами искать - по умолчанию все
                                       p_aut IN VARCHAR2 DEFAULT NULL, -- Автор извещений - по умолчанию все
                                       p_ncompl IN INTEGER DEFAULT 0, -- Необработанные
                                       p_psh out curtyp);
--**************************************************************
PROCEDURE    p_getpsh(p_rnps in number,
                      p_psh out curtyp);
--**************************************************************
--Данные изменения
PROCEDURE    p_izmdata(p_rntv IN NUMBER,
                                       p_rnps IN NUMBER,
                                       p_psh out curtyp,
                                       p_tv out curtyp,
                                       p_mo OUT curtyp,
                                       p_zag OUT curtyp,
                                       p_obr OUT curtyp,
                                       p_sost OUT curtyp,
                                       p_vhod OUT curtyp,
                                       p_isp OUT curtyp,
                                       p_td OUT curtyp);

--**************************************************************
PROCEDURE    p_izmdce(p_rnps IN number,
                                       p_dce out curtyp);
--**************************************************************
PROCEDURE    p_td(p_arid IN NUMBER,
                                       p_DATE IN VARCHAR2,
                                       p_old IN VARCHAR2 DEFAULT NULL,
                                       p_td out curtyp);
--**************************************************************
PROCEDURE    p_matizm(p_rnmat IN NUMBER,
                                       p_psh out curtyp)    ;
--**************************************************************
PROCEDURE    p_matizmdce(p_rnps IN number,
                                                    p_rnmat IN NUMBER,
                                                    p_dce out curtyp);
PROCEDURE p_rel_cursor (p_cur IN curtyp);

   TYPE T_Find_tv IS RECORD( --Иванова Вера 14.02.2007
      Rn       NUMBER,
      Obozn    VARCHAR2(300),
      vi       VARCHAR2(2),
      TvNaim   VARCHAR2(300),
      m        VARCHAR2(300),
      Nom_num  VARCHAR2(200),
      z        VARCHAR2(300),
      doly     VARCHAR2(50),
      geomr_dl NUMBER,
      geomr_sh NUMBER,
      ind_komp NUMBER);
   TYPE tb_find IS TABLE OF t_find_tv INDEX BY BINARY_INTEGER;
   TYPE T_Find_tv_klon IS RECORD( --Иванова Вера 14.02.2007
      Rn       NUMBER,
      Obozn    VARCHAR2(300),
      vi       VARCHAR2(2),
      TvNaim   VARCHAR2(300),
      m        VARCHAR2(300),
      tr       VARCHAR2(300),
      Nom_num  VARCHAR2(200),
      z        VARCHAR2(300),
      doly     VARCHAR2(50),
      geomr_dl NUMBER,
      geomr_sh NUMBER,
      ind_komp NUMBER,
      rn_ispob NUMBER,
      kol      NUMBER,
      ap       NUMBER,
      ez       VARCHAR2(10));
   TYPE tb_find_klon IS TABLE OF t_find_tv_klon INDEX BY BINARY_INTEGER;
   TYPE rec_tb_temp IS RECORD(
      kdce_ch NUMBER,
      tv_ch   NUMBER,
      ez      NUMBER,
      kol     NUMBER,
      ap      NUMBER);
   TYPE tb_temp IS TABLE OF rec_tb_temp INDEX BY BINARY_INTEGER;

END PK_MMK_INFO_R;
/

-------------------------------------
--  Changed package body pk_delta  --
-------------------------------------
CREATE OR REPLACE PACKAGE BODY W_MMKT.PK_DELTA IS
vPart number:=1000000;
vRnd number := 4;
--*************************************************************
  --Дельта разрезе цехов
PROCEDURE    p_delta_zex(p_rntv IN NUMBER,
                         p_dstart IN date,
                         p_dend in date,
                         p_pz IN VARCHAR2,
                         p_delta OUT curtyp
) AS
strdsd VARCHAR2(7):='dtsd';
strdpv VARCHAR2(7):='dtpv';
strdtk VARCHAR2(7):='dtk';
BEGIN
     IF p_pz='1' THEN
        strdsd:='dtsd_pz';
        strdpv:='dtpv_pz';
        strdtk:='dtk_pz';        
     END IF;                                             
                                             
--Дельта по цехам в Н/Ч
OPEN p_delta FOR '
SELECT rn_podr,kornaim,
round(SUM(dtsd)/:x1/60,:x2) AS dtsd, 
round((SUM(dtpv)+sum(dtk))/:x13/60,:x14) AS dtpv_f,
round(SUM(dtpv)/:x3/60,:x4) AS dtpv, round(SUM(dtk)/:x5/60,:x6) AS dtk,
round((sum(dtsd)+SUM(dtpv)+sum(dtk))/:x15/60,:x16) AS dt_f
--INTO vSd2, vPv2, vK2
FROM  
(SELECT * FROM (
select golova,''3'' AS prizn,dstart,farid,rntv,t.rn_podr,rn_prich,p1.date_istate,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS delta,
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_b,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_s, --Запуск стало
last_value(nvl(' || strdsd || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY                 dstart,farid,base ROWS 1 preceding)-
first_value(nvl(' || strdsd || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtsd,
last_value(nvl(' || strdpv || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(' || strdpv || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtpv,
last_value(nvl(' || strdtk || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(' || strdtk || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtk

from tb_res_rstr t LEFT JOIN w_otk.v_tb_prich_Tr p1 ON t.rn_prich =p1.RN
WHERE  t.rn in(select p2.rn from v_res_ex_p1m p2 where 
p2.RN_TV=:x7 and p2.dstart>=:x8 and p2.dstart<:x9
and p2.dend>:x81 and p2.dend<=:x91)

) d JOIN w_mp.tb_podr pdd ON d.rn_podr=pdd.rn
--WHERE dtsd<>0 OR dtpv<>0 OR dtk<>0
ORDER BY 1,3,4,5,6,2
) GROUP BY rn_podr,kornaim
--having round(sum(dtk),6)<>0 or round(sum(dtpv),6)<>0 or round(sum(dtsd),6)<>0
ORDER BY 1'
         USING vPart,vRnd,vPart,vRnd,vPart,vRnd,vPart,vRnd,vPart,vRnd,p_rntv,p_dstart,p_dend,p_dstart,p_dend/*,p_rntv,p_dstart,p_dend*/;
END;
--*************************************************************
  --Дельта в разрезе извещений и технических отделов
function    f_delta_izv(p_rntv IN NUMBER,
                         p_dstart IN date,
                         p_dend in date,
                         p_pz IN VARCHAR2,                         
                         p_rnpodr IN NUMBER DEFAULT NULL
)return tb_delta_izv 
PIPELINED
AS
t t_delta_izv;
oldrn t_delta_izv;
sd number:=0;
pv number:=0;
ff number:=0;
first boolean:=True;
i integer:=0;
sd_f number:=0;
pv_f number:=0;
ff_f number:=0;
j integer:=0;
vrn_res number;
BEGIN
t:=t_delta_izv(null,null,null,null,null,null,null,null,null,null,null,NULL);
oldrn:=t_delta_izv(null,null,null,null,null,null,null,null,null,null,null,NULL);
--Дельта по извещениям и тех.отделам в Н/Ч
select max(p2.rn) into vrn_res from v_res_ex_p1m p2 where p2.RN_TV=p_rntv and p2.dstart=p_dstart and dend=p_dend;
for c in (
select --+ first_rows
rn_prich,typ,
case when typ='Т' then
         w_otkv.f_get_tn_zex2(rn_prich)
     when typ='П' then
         F_RES_GET_MO_TO_STR(vrn_res,t56.rn_prich,1)
     else
         F_RES_GET_MO_TO_STR(vrn_res,t56.rn_prich,0)
end as zex,
--nomizm,
case when (rn_podr is null and typ='П') then 'Изменение ПЗ времени'
     else
        nomizm
end as nomizm,
numosn_un,
rn_osn,
case when (rn_podr is null and typ='П') then 193
     else
        rn_podr
end as rn_podr,
case when (kornaim is null and typ='П') then '888'
     else
        kornaim
end as kornaim,
dtsd,dtpv_f,dt_f from (
SELECT golova,aw.rn_prich,
--nvl2(tr.RN,'Т','М') as typ,
/*case when tr.RN_TYPEDOC=2008 then 'Т'
     when tr.RN_TYPEDOC=2009 then 'П'
     else 'М'
end typ,*/
case when tr.RN_TYPEDOC=2008 and ps.RN_TYPEDOC is null then 'Т'
     when tr.RN_TYPEDOC is null and ps.RN_TYPEDOC in (1008,1010) then 'М'
     else 'П'
end typ,
nvl(to_char(tr.NOMIZM105) ,ps.NOMIZM) as nomizm,nvl(ps2.NOMIZM,tr.NUMOSN_UN) AS numosn_un,ps2.rn AS rn_osn,
nvl(trspr.PODR_RSPR_FK,mspr.rn_podr) as rn_podr,nvl(/*tpd*/trspr1.kornaim,mpd.kornaim) as kornaim,
round(coalesce(trspr.PROCENT/100,mspr.dolypodr,1)*SUM(dtsd)/vPart/60,vRnd) AS dtsd,
round(coalesce(trspr.PROCENT/100,mspr.dolypodr,1)*(SUM(dtpv)+sum(dtk))/vPart/60,vRnd) AS dtpv_f,
round(coalesce(trspr.PROCENT/100,mspr.dolypodr,1)*SUM(dtpv)/vPart/60,vRnd) AS dtpv, 
round(coalesce(trspr.PROCENT/100,mspr.dolypodr,1)*SUM(dtk)/vPart/60,vRnd) AS dtk,
round(coalesce(trspr.PROCENT/100,mspr.dolypodr,1)*(sum(dtsd)+SUM(dtpv)+sum(dtk))/vPart/60,vRnd) AS dt_f,
dstart,farid
--INTO vSd2, vPv2, vK2
FROM
(SELECT * FROM (
select golova,'3' AS prizn,dstart,farid,rntv,t.rn_podr,rn_prich,p1.date_istate,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS delta,
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_b,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_s, --Запуск стало
last_value(nvl(decode(p_pz,'0',dtsd,dtsd_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY                 dstart,farid,base ROWS 1 preceding)-
first_value(nvl(decode(p_pz,'0',dtsd,dtsd_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtsd,
last_value(nvl(decode(p_pz,'0',dtpv,dtpv_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(decode(p_pz,'0',dtpv,dtpv_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtpv,
last_value(nvl(decode(p_pz,'0',dtk,dtk_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(decode(p_pz,'0',dtk,dtk_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtk

 from tb_res_rstr t LEFT JOIN w_otk.v_tb_prich_Tr p1 ON t.rn_prich =p1.RN
 WHERE /*2=(SELECT COUNT(*) FROM tb_res_rstr p WHERE p.rn=t.rn and p.golova=t.golova AND p.dstart=t.dstart AND p.farid=t.farid AND nvl(p.rntv,-1)=nvl(t.rntv,-1)
       AND p.rn_podr=t.rn_podr AND p.rn_prich=t.rn_prich
 ) AND*/ t.rn IN (select p2.rn from v_res_ex_p1m p2 where p2.RN_TV=p_rntv 
 and p2.dstart>=p_dstart and p2.dstart<p_dend
 and p2.dend>p_dstart and p2.dend<=p_dend)
 --vrn_res
 AND (p_rnpodr IS NULL OR  p_rnpodr=t.rn_podr)
  --WHERE delta<>0
/*UNION ALL 
select golova,base,dstart, farid,rntv,t.rn_podr,rn_prich,p1.DATE_ISTATE, ap* decode(base,1,-1,1), ap* decode(base,1,1,NULL) AS zap_b, ap* decode(base,1,NULL,1) AS zap_s,dtsd, dtpv, dtk
 from tb_res_rstr t LEFT JOIN w_otk.v_tb_prich_Tr p1 ON t.rn_prich =p1.RN
WHERE 1=(SELECT COUNT(*) FROM tb_res_rstr p WHERE p.rn=t.rn and p.golova=t.golova AND p.dstart=t.dstart AND p.farid=t.farid AND nvl(p.rntv,-1)=nvl(t.rntv,-1) AND p.rn_podr=t.rn_podr 
AND p.rn_prich=t.rn_prich) 
AND t.rn=(select p2.rn from v_res_ex_p1m p2 where p2.RN_TV=p_rntv and p2.dstart=p_dstart and dend=p_dend)*/
) d JOIN w_mp.tb_podr pdd ON d.rn_podr=pdd.rn
--WHERE dtsd<>0 OR dtpv<>0 OR dtk<>0
ORDER BY 1,3,4,5,6,2
)aw left join w_otk.v_tb_prich_tr tr on aw.rn_prich=tr.RN
    left join w_otk.v_tb_rspr trspr on tr.RN=trspr.RN_PRICH
    left join w_mp.tb_podr trspr1 on trspr.PODR_RSPR_FK=trspr1.rn    
    left join w_osnov.v_tb_prich mpri on tr.RN=mpri.RN
    left join w_osnov.v_tb_typedoc mpri1 on mpri.RN_TYPEDOC=mpri1.RN
    LEFT JOIN w_ktsg.v_per_sogl ps2 ON mpri.rn_srcprich=ps2.RN
    left join w_ktsg.v_per_sogl ps on aw.rn_prich=ps.RN
    left join w_ktsg.tb_doly_vig mspr  on ps.rn=mspr.rn_persogl
    left join w_mp.tb_podr mpd on mspr.rn_podr=mpd.rn    
 /*left join (w_otk.v_tb_prich_tr tr
     join w_otk.v_rspr trspr on tr.rn=trspr.RN_PRICH
     join w_mp.tb_podr tpd on trspr.PODR_RSPR_FK=tpd.rn
    ) on aw.rn_prich=tr.RN
    LEFT JOIN w_osnov.v_prich mpri ON tr.RN=mpri.rn
    LEFT JOIN w_ktsg.v_per_sogl ps2 ON mpri.rn_srcprich=ps2.RN
    left join (w_ktsg.v_per_sogl ps 
    join w_ktsg.tb_doly_vig mspr on ps.rn=mspr.rn_persogl
    join w_mp.tb_podr mpd on mspr.rn_podr=mpd.rn    
    )on aw.rn_prich=ps.RN  */ 
GROUP BY golova,aw.rn_prich,
--nvl2(tr.RN,'Т','М') ,
/*case when tr.RN_TYPEDOC=2008 then 'Т'
     when tr.RN_TYPEDOC=2009 then 'П'
     else 'М'
end,*/
case when tr.RN_TYPEDOC=2008 and ps.RN_TYPEDOC is null then 'Т'
     when tr.RN_TYPEDOC is null and ps.RN_TYPEDOC in (1008,1010) then 'М'
     else 'П'
end,
nvl(to_char(tr.NOMIZM105) ,ps.NOMIZM) ,nvl(ps2.NOMIZM,tr.NUMOSN_UN),ps2.rn,
nvl(trspr.PODR_RSPR_FK,mspr.rn_podr),
coalesce(trspr.PROCENT/100,mspr.dolypodr,1),
nvl(/*tpd*/trspr1.kornaim,mpd.kornaim),dstart,farid
) t56 ORDER BY dstart,farid
) LOOP
    IF oldrn.rn_prich=c.rn_prich AND oldrn.kornaim<>c.kornaim THEN --!!
       j:=j+1;
    END IF;
    if first then
       oldrn.rn_prich:=c.rn_prich;
       oldrn.typ:=c.typ;
       oldrn.nomizm:=c.nomizm;
       oldrn.numosn:=c.numosn_un;
       oldrn.rn_osn:=c.rn_osn;
       oldrn.zex:=c.zex;
       oldrn.kornaim:=c.kornaim;--!!
       first:=false;
       j:=1;
    end if;
    
    if oldrn.rn_prich<>c.rn_prich OR (oldrn.rn_prich=c.rn_prich AND oldrn.kornaim=c.kornaim)  then --Кончилось изменение
        t.rn_prich:=oldrn.rn_prich;       
        t.typ:=oldrn.typ;
        t.nomizm:=oldrn.nomizm;
        t.numosn:=oldrn.numosn;
        t.rn_osn:=oldrn.rn_osn;
        t.zex:=oldrn.zex;
        t.rn_podr:=NULL;
        t.kornaim:=NULL;
        t.dtsd:=sd;
        t.dtpv_f:=pv;
        t.dt_f:=ff;
        t.num:=i;
        sd:=0;
        pv:=0;
        ff:=0;
        oldrn.rn_prich:=c.rn_prich;
        oldrn.typ:=c.typ;
        oldrn.nomizm:=c.nomizm;
       oldrn.numosn:=c.numosn_un;
       oldrn.rn_osn:=c.rn_osn;
       oldrn.zex:=c.zex;
       oldrn.kornaim:=c.kornaim;--!!
        i:=i+1;
        if j>1 then
           pipe row(t);           
        end if;
        j:=1;
    end if;
    t.num:=i;
    t.rn_prich:=c.rn_prich;
    t.typ:=c.typ;
    t.zex:=c.zex;
    t.nomizm:=c.nomizm;
    t.numosn:=c.numosn_un;
    t.rn_osn:=c.rn_osn;
    t.rn_podr:=c.rn_podr;
    t.kornaim:=c.kornaim;
    t.dtsd:=c.dtsd;
    t.dtpv_f:=c.dtpv_f;
    t.dt_f:=c.dt_f;
    sd:=sd+c.dtsd;
    pv:=pv+c.dtpv_f;
    ff:=ff+c.dt_f;

    sd_f:=sd_f+c.dtsd;
    pv_f:=pv_f+c.dtpv_f;
    ff_f:=ff_f+c.dt_f;
    pipe row(t);
dbms_output.put_line('1 ' || j);
end loop;
dbms_output.put_line('3 ' || j);
        t.rn_prich:=oldrn.rn_prich;       
        t.typ:=oldrn.typ;
        t.zex:=oldrn.zex;
        t.nomizm:=oldrn.nomizm;
        t.numosn:=OLDrn.numosn;        
        t.rn_osn:=oldrn.rn_osn;
        t.rn_podr:=NULL;
        t.kornaim:=NULL;
        t.dtsd:=sd;
        t.dtpv_f:=pv;
        t.dt_f:=ff;
        t.num:=i;
        if j>1 then
           pipe row(t);
        end if;
--Итого
        t.rn_prich:=null;
        t.typ:=null;
        t.zex:=null;
        t.nomizm:='Итого';
        t.numosn:=NULL;
        t.rn_osn:=NULL;
        t.rn_podr:=NULL;
        t.kornaim:=NULL;
        t.dtsd:=sd_f;
        t.dtpv_f:=pv_f;
        t.dt_f:=ff_f;
        t.num:=i+1;
        pipe row(t);
RETURN;
end;
--*************************************************************
  --Дельта по извещению трудовому в разрезе ДСЕ
PROCEDURE    p_delta_izvtot(p_rntv IN NUMBER,
                         p_dstart IN date,
                         p_dend in date,
                         p_pz in varchar2,
                         p_rnprich in number,
                         p_delta OUT curtyp
) AS
strsd VARCHAR2(7):='tsd';
strpv VARCHAR2(7):='tpv';
strtk VARCHAR2(7):='tk';
strdsd VARCHAR2(7):='dtsd';
strdpv VARCHAR2(7):='dtpv';
strdtk VARCHAR2(7):='dtk';
BEGIN
     IF p_pz='1' THEN
        strsd:='tsd_pz';
        strpv:='tpv_pz';
        strtk:='tk_pz';        

        strdsd:='dtsd_pz';
        strdpv:='dtpv_pz';
        strdtk:='dtk_pz';        
     END IF;                                             

open p_delta for 
'SELECT aw.rn_prich,rntv,round(zap_b/:x1,:x27) as ap/*,nvl2(tr.RN,''Т'',''М'') as typ,nvl(to_char(tr.NOMIZM105) ,ps.NOMIZM) as nomizm,
nvl(trspr.PODR_RSPR_FK,mspr.rn_podr) as rn_podr,nvl(tpd.kornaim,mpd.kornaim) as kornaim*/,
io.obozn,tv.vi,
round(sum(tsd/60),:x22) as tsd,
round(sum( (tpv+tk)/60),:x23) as tpv_f,
round(sum(tpv/60),:x24) as tpv,round(sum(tk/60),:x25) as tk,
round(sum((tsd+tpv+tk)/60),:x26) as t_f,
round(SUM(dtsd)/:x2/60,:x3) AS dtsd,
round((SUM(dtpv)+sum(dtk)) /:x4/60,:x5) AS dtpv_f,
round(SUM(dtpv) /:x6/60,:x7) AS dtpv, round(SUM(dtk)/:x8/60,:x9) AS dtk,
round((SUM(dtsd)+SUM(dtpv)+sum(dtk)) /:x10/60,:x11) AS dt_f
--INTO vSd2, vPv2, vK2
FROM
(SELECT * FROM (
select golova,''3'' AS prizn,dstart,farid,rntv,t.rn_podr,rn_prich,p1.date_istate,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS delta,
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_b,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_s, --Запуск стало
last_value(nvl('|| strsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY                 dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS tsd,
last_value(nvl('|| strdsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY                 dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strdsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtsd,
last_value(nvl('|| strpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS tpv,
last_value(nvl('|| strdpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strdpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtpv,
last_value(nvl('|| strtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS tk,
last_value(nvl('|| strdtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strdtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtk

 from tb_res_rstr t LEFT JOIN w_otk.v_tb_prich_Tr p1 ON t.rn_prich =p1.RN
 WHERE /*2=(SELECT COUNT(*) FROM tb_res_rstr p WHERE p.rn=t.rn and p.golova=t.golova AND p.dstart=t.dstart AND p.farid=t.farid AND nvl(p.rntv,-1)=nvl(t.rntv,-1)
       AND p.rn_podr=t.rn_podr AND p.rn_prich=t.rn_prich
 ) AND*/ t.rn in (select p2.rn from v_res_ex_p1m p2 where p2.RN_TV=:x12 /*305625*/ 
 and p2.dstart>=:x13 and p2.dstart<:x131
 and dend>:x14 and dend<=:x141)
 and t.rn_prich=:x17
  --WHERE delta<>0
) d JOIN w_mp.tb_podr pdd ON d.rn_podr=pdd.rn
--WHERE dtsd<>0 OR dtpv<>0 OR dtk<>0
ORDER BY 1,3,4,5,6,2
)aw /*left join (w_otk.v_tb_prich_tr tr
    join w_otk.v_rspr trspr on tr.rn=trspr.RN_PRICH
    join w_mp.tb_podr tpd on trspr.PODR_RSPR_FK=tpd.rn
    ) on aw.rn_prich=tr.RN
    left join (w_ktsg.v_per_sogl ps
    join w_ktsg.tb_doly_vig mspr on ps.rn=mspr.rn_persogl
    join w_mp.tb_podr mpd on mspr.rn_podr=mpd.rn
    )on aw.rn_prich=ps.RN*/
    join w_ktsg.tb_tv tv on aw.rntv=tv.rn
    join w_ktsg.v0_isp_ob_s io on tv.rn_ispob=io.RN_ISPOB
GROUP BY golova,aw.rn_prich,rntv,zap_b,io.obozn,tv.vi/*,nvl2(tr.RN,''Т'',''М'') ,nvl(to_char(tr.NOMIZM105) ,ps.NOMIZM) ,nvl(trspr.PODR_RSPR_FK,mspr.rn_podr),*/
order by 4,5'
using vPart,vRnd,vRnd,vRnd,vRnd,vRnd,vRnd,
vPart,vRnd,vPart,vRnd,vPart,vRnd/*7*/,vPart,vRnd,vPart,vRnd,p_rntv,p_dstart,p_dend,p_dstart,p_dend,p_rnprich/*15*//*,p_rntv,p_dstart,p_dend,p_rnprich*/;
end;
--*************************************************************
  --Дельта по извещению маршрутному в разрезе цехов
PROCEDURE    p_delta_izvzex(p_rntv IN NUMBER,                        
                         p_dstart IN date,
                         p_dend in date,
                         p_pz in varchar2,
                         p_rnprich in number,
                         p_delta OUT curtyp
) AS
strdsd VARCHAR2(7):='dtsd';
strdpv VARCHAR2(7):='dtpv';
strdtk VARCHAR2(7):='dtk';
BEGIN
     IF p_pz='1' THEN
        strdsd:='dtsd_pz';
        strdpv:='dtpv_pz';
        strdtk:='dtk_pz';        
     END IF;                                             
--Дельта по цехам в Н/Ч
OPEN p_delta FOR '
SELECT rn_podr,kornaim,round(SUM(dtsd)/:x1/60,:x2) AS dtsd, 
round((SUM(dtpv)+sum(dtk))/:x13/60,:x14) AS dtpv_f,
round(SUM(dtpv)/:x3/60,:x4) AS dtpv, round(SUM(dtk)/:x5/60,:x6) AS dtk,
round((sum(dtsd)+SUM(dtpv)+sum(dtk))/:x15/60,:x16) AS dt_f
--INTO vSd2, vPv2, vK2
FROM  
(SELECT * FROM (
select golova,''3'' AS prizn,dstart,farid,rntv,t.rn_podr,rn_prich,p1.date_istate,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS delta,
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_b,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_s, --Запуск стало

last_value(nvl(' || strdsd || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY                 dstart,farid,base ROWS 1 preceding)-
first_value(nvl(' || strdsd || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtsd,
last_value(nvl(' || strdpv || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(' || strdpv || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtpv,
last_value(nvl(' || strdtk || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(' || strdtk || ',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtk

 from tb_res_rstr t LEFT JOIN w_otk.v_tb_prich_Tr p1 ON t.rn_prich =p1.RN
 WHERE  t.rn in (select p2.rn from v_res_ex_p1m p2 where p2.RN_TV=:x7 
 and p2.dstart>=:x8 and p2.dstart<:x9
 and p2.dend>:x81 and p2.dend<=:x91)
 and t.rn_prich=:x13
  --WHERE delta<>0
) d JOIN w_mp.tb_podr pdd ON d.rn_podr=pdd.rn
WHERE dtsd<>0 OR dtpv<>0 OR dtk<>0
ORDER BY 1,3,4,5,6,2
) GROUP BY rn_podr,kornaim
--having round(sum(dtk),6)<>0 or round(sum(dtpv),6)<>0 or round(sum(dtsd),6)<>0
ORDER BY 1'
         USING vPart,vRnd,vPart,vRnd,vPart,vRnd,vPart,vRnd,vPart,vRnd,p_rntv,p_dstart,p_dend,p_dstart,p_dend,p_rnprich/*,p_rntv,p_dstart,p_dend,p_rnprich*/;
END;
--*************************************************************
PROCEDURE    p_delta_izvtom(p_rntv IN NUMBER,
                         p_dstart IN date,
                         p_dend in date,
                         p_pz in varchar2,
                         p_rnprich in number,
                         p_rnpodr IN NUMBER,
                         p_delta OUT curtyp
) AS
--Дельта по извещению маршрутному и по цеху в разрезе ДСЕ
strsd VARCHAR2(7):='tsd';
strpv VARCHAR2(7):='tpv';
strtk VARCHAR2(7):='tk';
strdsd VARCHAR2(7):='dtsd';
strdpv VARCHAR2(7):='dtpv';
strdtk VARCHAR2(7):='dtk';
BEGIN
     IF p_pz='1' THEN
        strsd:='tsd_pz';
        strpv:='tpv_pz';
        strtk:='tk_pz';        

        strdsd:='dtsd_pz';
        strdpv:='dtpv_pz';
        strdtk:='dtk_pz';        
     END IF;                                             

open p_delta for 
'SELECT aw.rn_prich,rntv,round(zap_b/:x1,:x27) as zap_b,round(zap_s/:x1,:x28) as zap_s,round(delta/:x32,:x29) as dap/*,nvl2(tr.RN,''Т'',''М'') as typ,nvl(to_char(tr.NOMIZM105) ,ps.NOMIZM) as nomizm,
nvl(trspr.PODR_RSPR_FK,mspr.rn_podr) as rn_podr,nvl(tpd.kornaim,mpd.kornaim) as kornaim*/,
io.obozn,tv.vi,
round(sum(tsd/60),:x22) as tsd,
round(sum( (tpv+tk)/60),:x23) as tpv_f,
round(sum(tpv/60),:x24) as tpv,round(sum(tk/60),:x25) as tk,
round(sum((tsd+tpv+tk)/60),:x26) as t_f,
round(SUM(dtsd)/:x2/60,:x3) AS dtsd,
round((SUM(dtpv)+sum(dtk)) /:x4/60,:x5) AS dtpv_f,
round(SUM(dtpv) /:x6/60,:x7) AS dtpv, round(SUM(dtk)/:x8/60,:x9) AS dtk,
round((SUM(dtsd)+SUM(dtpv)+sum(dtk)) /:x10/60,:x11) AS dt_f
--INTO vSd2, vPv2, vK2
FROM
(SELECT * FROM (
select golova,''3'' AS prizn,dstart,farid,rntv,t.rn_podr,rn_prich,p1.date_istate,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS delta,
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_b,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_s, --Запуск стало

last_value(nvl('|| strsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY                 dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS tsd,
last_value(nvl('|| strdsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY                 dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strdsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtsd,
last_value(nvl('|| strpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS tpv,
last_value(nvl('|| strdpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strdpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtpv,
last_value(nvl('|| strtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS tk,
last_value(nvl('|| strdtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strdtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtk

 from tb_res_rstr t LEFT JOIN w_otk.v_tb_prich_Tr p1 ON t.rn_prich =p1.RN
 WHERE /*2=(SELECT COUNT(*) FROM tb_res_rstr p WHERE p.rn=t.rn and p.golova=t.golova AND p.dstart=t.dstart AND p.farid=t.farid AND nvl(p.rntv,-1)=nvl(t.rntv,-1)
       AND p.rn_podr=t.rn_podr AND p.rn_prich=t.rn_prich
 ) AND*/ t.rn in (select p2.rn from v_res_ex_p1m p2 where p2.RN_TV=:x12 /*305625*/ 
 and p2.dstart>=:x13 and dstart<:x14
 and p2.dend>:x131 and dend<=:x141)
 and t.rn_prich=:x17 and t.rn_podr=:x30

) d JOIN w_mp.tb_podr pdd ON d.rn_podr=pdd.rn
--WHERE dtsd<>0 OR dtpv<>0 OR dtk<>0
ORDER BY 1,3,4,5,6,2
)aw join w_ktsg.tb_tv tv on aw.rntv=tv.rn
    join w_ktsg.v0_isp_ob_s io on tv.rn_ispob=io.RN_ISPOB
GROUP BY golova,aw.rn_prich,rntv,zap_b,zap_s,delta,io.obozn,tv.vi/*,nvl2(tr.RN,''Т'',''М'') ,nvl(to_char(tr.NOMIZM105) ,ps.NOMIZM) ,nvl(trspr.PODR_RSPR_FK,mspr.rn_podr),*/
order by 4,5'
using /*zap_b*/vPart,vRnd, /*zap_s*/vPart,vRnd,/*delta*/vPart,vRnd,
vRnd,vRnd,vRnd,vRnd,vRnd,
vPart,vRnd,vPart,vRnd,vPart,vRnd/*7*/,vPart,vRnd,vPart,vRnd,p_rntv,p_dstart,p_dend,p_dstart,p_dend,p_rnprich/*15*/,p_rnpodr/*,p_rntv,p_dstart,p_dend,p_rnprich,p_rnpodr*/;
end;

--*************************************************************
  --Дельта в разрезе извещений, технических отделов и цехов
function f_delta_izvtotzex(p_rntv IN NUMBER,
                           p_dstart IN date,
                           p_dend in date,
                           p_pz IN VARCHAR2,                         
                           p_rnpodr IN NUMBER DEFAULT NULL
)return tb_delta_izv
pipelined 
AS
t t_delta_izv;
oldrn t_delta_izv;
sd number:=0;
pv number:=0;
ff number:=0;
first boolean:=True;
i integer:=0;
sd_f number:=0;
pv_f number:=0;
ff_f number:=0;
j integer:=0;
vrn_res number;
BEGIN
t:=t_delta_izv(null,null,null,null,null,null,null,null,null,NULL,NULL,NULL);
oldrn:=t_delta_izv(null,null,null,null,null,null,null,null,null,null,null,NULL);
--Дельта по извещениям и тех.отделам в Н/Ч
select max(p2.rn) into vrn_res from v_res_ex_p1m p2 where p2.RN_TV=p_rntv and p2.dstart=p_dstart and dend=p_dend;
for c in (
select rn_prich,typ,
/*case when typ='Т' then
     w_otkv.f_get_tn_zex(rn_prich)
else
    F_RES_GET_MO_TO_STR(vrn_res,t56.rn_prich)
--null
end  as zex,*/
--nomizm,
case when (rn_podr is null and typ='П') then 'Изменение ПЗ времени'
     else
        nomizm
end as nomizm,
numosn_un,
rn_osn,
--rn_podr,
case when (rn_podr is null and typ='П') then 193
     else
        rn_podr
end as rn_podr,
--kornaim,
case when (kornaim is null and typ='П') then '888'
     else
        kornaim
end as kornaim,
zex,dtsd,dtpv_f,dt_f from (
SELECT golova,
aw.kornaim as zex, 
aw.rn_prich,
--nvl2(tr.RN,'Т','М') as typ,
case when tr.RN_TYPEDOC=2008 and ps.RN_TYPEDOC is null then 'Т'
     when tr.RN_TYPEDOC is null and ps.RN_TYPEDOC in (1008,1010) then 'М'
     else 'П'
end typ,
nvl(to_char(tr.NOMIZM105) ,ps.NOMIZM) as nomizm,nvl(ps2.nomizm,tr.NUMOSN_UN) AS numosn_un,ps2.rn AS rn_osn,
nvl(trspr.PODR_RSPR_FK,mspr.rn_podr) as rn_podr,
nvl(/*tpd*/trspr1.kornaim,mpd.kornaim) as kornaim,
round(coalesce(trspr.PROCENT/100,mspr.dolypodr,1)*SUM(dtsd)/vPart/60,vRnd) AS dtsd,
round(coalesce(trspr.PROCENT/100,mspr.dolypodr,1)*(SUM(dtpv)+sum(dtk))/vPart/60,vRnd) AS dtpv_f,
round(coalesce(trspr.PROCENT/100,mspr.dolypodr,1)*SUM(dtpv)/vPart/60,vRnd) AS dtpv, 
round(coalesce(trspr.PROCENT/100,mspr.dolypodr,1)*SUM(dtk)/vPart/60,vRnd) AS dtk,
round(coalesce(trspr.PROCENT/100,mspr.dolypodr,1)*(sum(dtsd)+SUM(dtpv)+sum(dtk))/vPart/60,vRnd) AS dt_f,
dstart,farid
--INTO vSd2, vPv2, vK2
FROM
(SELECT * FROM (
select golova,'3' AS prizn,dstart,farid,rntv,t.rn_podr,rn_prich,p1.date_istate,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS delta,
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_b,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_s, --Запуск стало
last_value(nvl(decode(p_pz,'0',dtsd,dtsd_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY                 dstart,farid,base ROWS 1 preceding)-
first_value(nvl(decode(p_pz,'0',dtsd,dtsd_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtsd,
last_value(nvl(decode(p_pz,'0',dtpv,dtpv_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(decode(p_pz,'0',dtpv,dtpv_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtpv,
last_value(nvl(decode(p_pz,'0',dtk,dtk_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(decode(p_pz,'0',dtk,dtk_pz),0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtk

 from tb_res_rstr t LEFT JOIN w_otk.v_tb_prich_Tr p1 ON t.rn_prich =p1.RN
 WHERE t.rn IN (select p2.rn from v_res_ex_p1m p2 where p2.RN_TV=p_rntv 
                   and p2.dstart>=p_dstart and p2.dstart<p_dend
                   and p2.dend>p_dstart and p2.dend<=p_dend)
                   AND (p_rnpodr IS NULL OR  p_rnpodr=t.rn_podr)
) d JOIN w_mp.tb_podr pdd ON d.rn_podr=pdd.rn
ORDER BY 1,3,4,5,6,2
)aw left join w_otk.v_tb_prich_tr tr on aw.rn_prich=tr.RN
    left join w_otk.v_tb_rspr trspr on tr.RN=trspr.RN_PRICH
    left join w_mp.tb_podr trspr1 on trspr.PODR_RSPR_FK=trspr1.rn    
    left join w_osnov.v_tb_prich mpri on tr.RN=mpri.RN
    left join w_osnov.v_tb_typedoc mpri1 on mpri.RN_TYPEDOC=mpri1.RN
    LEFT JOIN w_ktsg.v_per_sogl ps2 ON mpri.rn_srcprich=ps2.RN
    left join w_ktsg.v_per_sogl ps on aw.rn_prich=ps.RN
    left join w_ktsg.tb_doly_vig mspr  on ps.rn=mspr.rn_persogl
    left join w_mp.tb_podr mpd on mspr.rn_podr=mpd.rn
/*left join (w_otk.v_tb_prich_tr tr
    join w_otk.v_rspr trspr on tr.rn=trspr.RN_PRICH
    join w_mp.tb_podr tpd on trspr.PODR_RSPR_FK=tpd.rn
    ) on aw.rn_prich=tr.RN
    LEFT JOIN w_osnov.v_prich mpri ON tr.RN=mpri.rn
    LEFT JOIN w_ktsg.v_per_sogl ps2 ON mpri.rn_srcprich=ps2.RN
    left join (w_ktsg.v_per_sogl ps 
    join w_ktsg.tb_doly_vig mspr on ps.rn=mspr.rn_persogl
    join w_mp.tb_podr mpd on mspr.rn_podr=mpd.rn    
    )on aw.rn_prich=ps.RN*/
GROUP BY golova,aw.kornaim,aw.rn_prich,
--nvl2(tr.RN,'Т','М'),
case when tr.RN_TYPEDOC=2008 and ps.RN_TYPEDOC is null then 'Т'
     when tr.RN_TYPEDOC is null and ps.RN_TYPEDOC in (1008,1010) then 'М'
     else 'П'
end,
nvl(to_char(tr.NOMIZM105) ,ps.NOMIZM) ,nvl(ps2.NOMIZM,tr.NUMOSN_UN),ps2.rn,
nvl(trspr.PODR_RSPR_FK,mspr.rn_podr),
coalesce(trspr.PROCENT/100,mspr.dolypodr,1),
nvl(/*tpd*/trspr1.kornaim,mpd.kornaim),dstart,farid
) t56 ORDER BY dstart,farid
) LOOP
    /*IF oldrn.rn_prich=c.rn_prich \*!!!*\ AND oldrn.kornaim<>c.kornaim \*!!!*\ THEN
          j:=j+1;
    END IF;*/
    if first then
       oldrn.rn_prich:=c.rn_prich;
       oldrn.typ:=c.typ;
       oldrn.nomizm:=c.nomizm;
       oldrn.numosn:=c.numosn_un;
       oldrn.rn_osn:=c.rn_osn;
       oldrn.zex:=c.zex;
       oldrn.kornaim:=c.kornaim;--!!
       first:=false;
       j:=1;
    end if;
    
    if oldrn.rn_prich<>c.rn_prich then --Кончилось изменение
        t.rn_prich:=oldrn.rn_prich;       
        t.typ:=oldrn.typ;
        t.nomizm:=oldrn.nomizm;
        t.numosn:=oldrn.numosn;
        t.rn_osn:=oldrn.rn_osn;
        t.zex:=oldrn.zex;
        t.rn_podr:=NULL;
        t.kornaim:=NULL;
        t.dtsd:=sd;
        t.dtpv_f:=pv;
        t.dt_f:=ff;
        t.num:=i;
        sd:=0;
        pv:=0;
        ff:=0;
        oldrn.rn_prich:=c.rn_prich;
        oldrn.typ:=c.typ;
        oldrn.nomizm:=c.nomizm;
       oldrn.numosn:=c.numosn_un;
       oldrn.rn_osn:=c.rn_osn;
       oldrn.zex:=c.zex;
       oldrn.kornaim:=c.kornaim;--!!
        i:=i+1;
        if j>1 then
           pipe row(t);           
        end if;
        j:=1;
    end if;
    t.num:=i;
    t.rn_prich:=c.rn_prich;
    t.typ:=c.typ;
    t.zex:=c.zex;
    t.nomizm:=c.nomizm;
    t.numosn:=c.numosn_un;
    t.rn_osn:=c.rn_osn;    
    t.rn_podr:=c.rn_podr;
    t.kornaim:=c.kornaim;
    t.zex:=c.zex;
    t.dtsd:=c.dtsd;
    t.dtpv_f:=c.dtpv_f;
    t.dt_f:=c.dt_f;
    sd:=sd+c.dtsd;
    pv:=pv+c.dtpv_f;
    ff:=ff+c.dt_f;

    sd_f:=sd_f+c.dtsd;
    pv_f:=pv_f+c.dtpv_f;
    ff_f:=ff_f+c.dt_f;
    pipe row(t);
dbms_output.put_line('1 ' || j);
end loop;
dbms_output.put_line('3 ' || j);
        t.rn_prich:=oldrn.rn_prich;       
        t.typ:=oldrn.typ;
        t.zex:=oldrn.zex;
        t.nomizm:=oldrn.nomizm;
        t.numosn:=OLDrn.numosn;        
        t.rn_osn:=oldrn.rn_osn;
        t.rn_podr:=NULL;
        t.kornaim:=NULL;
        t.dtsd:=sd;
        t.dtpv_f:=pv;
        t.dt_f:=ff;
        t.num:=i;
        if j>1 then
           pipe row(t);
        end if;
--Итого
        t.rn_prich:=null;
        t.typ:=null;
        t.zex:=null;
        t.nomizm:='Итого';
        t.numosn:=NULL;
        t.rn_osn:=NULL;
        t.rn_podr:=NULL;
        t.kornaim:=NULL;
        t.dtsd:=sd_f;
        t.dtpv_f:=pv_f;
        t.dt_f:=ff_f;
        t.num:=i+1;
        pipe row(t);
RETURN;
end;
--*************************************************************
  --Дельта по извещению смены ПЗ времени в разрезе ДСЕ
PROCEDURE  p_delta_izvtop(p_rntv IN NUMBER,
                         p_dstart IN date,
                         p_dend in date,
                         p_pz in varchar2,
                         p_rnprich in number,
                         p_rnpodr IN NUMBER,
                         p_delta OUT curtyp
) AS
strsd VARCHAR2(7):='tsd';
strpv VARCHAR2(7):='tpv';
strtk VARCHAR2(7):='tk';
strdsd VARCHAR2(7):='dtsd';
strdpv VARCHAR2(7):='dtpv';
strdtk VARCHAR2(7):='dtk';
BEGIN
     IF p_pz='1' THEN
        strsd:='tsd_pz';
        strpv:='tpv_pz';
        strtk:='tk_pz';        

        strdsd:='dtsd_pz';
        strdpv:='dtpv_pz';
        strdtk:='dtk_pz';        
     END IF;                                             

open p_delta for 
'SELECT aw.rn_prich,rntv,round(zap_b/:x1,:x27) as ap/*,nvl2(tr.RN,''Т'',''М'') as typ,nvl(to_char(tr.NOMIZM105) ,ps.NOMIZM) as nomizm,
nvl(trspr.PODR_RSPR_FK,mspr.rn_podr) as rn_podr,nvl(tpd.kornaim,mpd.kornaim) as kornaim*/,
io.obozn,tv.vi,
round(sum(tsd/60),:x22) as tsd,
round(sum( (tpv+tk)/60),:x23) as tpv_f,
round(sum(tpv/60),:x24) as tpv,round(sum(tk/60),:x25) as tk,
round(sum((tsd+tpv+tk)/60),:x26) as t_f,
round(SUM(dtsd)/:x2/60,:x3) AS dtsd,
round((SUM(dtpv)+sum(dtk)) /:x4/60,:x5) AS dtpv_f,
round(SUM(dtpv) /:x6/60,:x7) AS dtpv, round(SUM(dtk)/:x8/60,:x9) AS dtk,
round((SUM(dtsd)+SUM(dtpv)+sum(dtk)) /:x10/60,:x11) AS dt_f
--INTO vSd2, vPv2, vK2
FROM
(SELECT * FROM (
select golova,''3'' AS prizn,dstart,farid,rntv,t.rn_podr,rn_prich,p1.date_istate,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS delta,
first_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_b,
last_value(nvl(ap,0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS zap_s, --Запуск стало
last_value(nvl('|| strsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY                 dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS tsd,
last_value(nvl('|| strdsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY                 dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strdsd ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtsd,
last_value(nvl('|| strpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS tpv,
last_value(nvl('|| strdpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strdpv ||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtpv,
last_value(nvl('|| strtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS tk,
last_value(nvl('|| strdtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding)-
first_value(nvl('|| strdtk||',0))  over (PARTITION BY t.rn,golova,rntv,t.rn_podr,t.rn_prich,dstart,farid ORDER BY dstart,farid,base ROWS 1 preceding) AS dtk

 from tb_res_rstr t LEFT JOIN w_otk.v_tb_prich_Tr p1 ON t.rn_prich =p1.RN
 WHERE /*2=(SELECT COUNT(*) FROM tb_res_rstr p WHERE p.rn=t.rn and p.golova=t.golova AND p.dstart=t.dstart AND p.farid=t.farid AND nvl(p.rntv,-1)=nvl(t.rntv,-1)
       AND p.rn_podr=t.rn_podr AND p.rn_prich=t.rn_prich
 ) AND*/ t.rn in (select p2.rn from v_res_ex_p1m p2 where p2.RN_TV=:x12 /*305625*/ 
 and p2.dstart>=:x13 and p2.dstart<:x131
 and dend>:x14 and dend<=:x141)
 and t.rn_prich=:x17 and t.rn_podr=:x30
  --WHERE delta<>0
) d JOIN w_mp.tb_podr pdd ON d.rn_podr=pdd.rn
--WHERE dtsd<>0 OR dtpv<>0 OR dtk<>0
ORDER BY 1,3,4,5,6,2
)aw /*left join (w_otk.v_tb_prich_tr tr
    join w_otk.v_rspr trspr on tr.rn=trspr.RN_PRICH
    join w_mp.tb_podr tpd on trspr.PODR_RSPR_FK=tpd.rn
    ) on aw.rn_prich=tr.RN
    left join (w_ktsg.v_per_sogl ps
    join w_ktsg.tb_doly_vig mspr on ps.rn=mspr.rn_persogl
    join w_mp.tb_podr mpd on mspr.rn_podr=mpd.rn
    )on aw.rn_prich=ps.RN*/
    join w_ktsg.tb_tv tv on aw.rntv=tv.rn
    join w_ktsg.v0_isp_ob_s io on tv.rn_ispob=io.RN_ISPOB
GROUP BY golova,aw.rn_prich,rntv,zap_b,io.obozn,tv.vi/*,nvl2(tr.RN,''Т'',''М'') ,nvl(to_char(tr.NOMIZM105) ,ps.NOMIZM) ,nvl(trspr.PODR_RSPR_FK,mspr.rn_podr),*/
order by 4,5'
using vPart,vRnd,vRnd,vRnd,vRnd,vRnd,vRnd,
vPart,vRnd,vPart,vRnd,vPart,vRnd/*7*/,vPart,vRnd,vPart,vRnd,p_rntv,p_dstart,p_dend,p_dstart,p_dend,p_rnprich,p_rnpodr/*15*//*,p_rntv,p_dstart,p_dend,p_rnprich*/;
end;
--*************************************************************    
   --Заполняется таблица плановых цен на материалы
PROCEDURE p_zapoln_plcen(p_date IN date) as
begin
--Установим дату актуальности
w_ktsg.pk_values.Set_CURDATE(p_date);

-- Добавим в таблицу цены на изделия
insert into tb_plancen_year(data_actual,rn_izd,snz,id_prod,
                            rn_mat,ez,plcen_izd,plcen_snz,plcen,
                            avtor_izm,data_izm)
   select distinct p_date,p.rn_tv,h.snz,
          case when h.po in ('0','1') then
                    2 -- спец.
               else
                    1 -- гражд.      
          end,           
          p.rn_mat,null,p.plcen,null,null,
          'Процедура W_MMKT.PK_DELTA.P_ZAPOLN_PLCEN',SYSDATE
     from w_plancen.tb_plancen_plcen_izd p
          join w_ktsg.tb_tv t on t.rn=p.rn_tv
          join w_ktsg.v0_isp_ob_s t1 on t.rn_ispob=t1.RN_ISPOB
          left join w_kts.h1shifr h on t1.OBOZN=h.ind,
          w_plancen.tb_audi ap
      where p.att_arid=ap.att_arid and
            p.objtype=ap.att_objtype and
            p_date<ap.att_arend and
            p_date>=ap.att_arstart and
            ap.att_arver=0 and ap.att_var=0;
commit;
-- Добавим цены на материалы по заказам
-- 1) Изменим строки, если такие уже есть
update tb_plancen_year t
 set t.plcen_snz=(select p.plcen
                   from w_plancen.tb_plancen_plcen_zakaz p,
                        w_plancen.tb_audi ap
                     where p.att_arid=ap.att_arid and
                           p.objtype=ap.att_objtype and
                           p_date<ap.att_arend and
                           p_date>=ap.att_arstart and
                           ap.att_arver=0 and ap.att_var=0 and
                           t.data_actual=p_date and
                           p.rn_mat=t.rn_mat and
                           p.zakaz=t.snz);
commit;                           
-- 2) Добавим новые строки                                     
insert into tb_plancen_year(data_actual,rn_izd,snz,id_prod,
                            rn_mat,ez,plcen_izd,plcen_snz,plcen,
                            avtor_izm,data_izm)
   select distinct p_date,null,p.zakaz,
          case when h.po in ('0','1') then
                    2 -- спец.
               else
                    1 -- гражд.      
          end,
          p.rn_mat,null,null,p.plcen,null,
          'Процедура W_MMKT.PK_DELTA.P_ZAPOLN_PLCEN',SYSDATE
     from w_plancen.tb_plancen_plcen_zakaz p
          left join w_kts.h1shifr h on p.zakaz=h.snz,
          w_plancen.tb_audi ap
       where 0=(select count(*)
                  from tb_plancen_year t
                    where t.data_actual=p_date and
                          t.rn_mat=p.rn_mat and
                          t.snz=p.zakaz) and
             p.att_arid=ap.att_arid and
             p.objtype=ap.att_objtype and
             p_date<ap.att_arend and
             p_date>=ap.att_arstart and
             ap.att_arver=0 and ap.att_var=0;                          
commit;
-- Добавим Общие цены на материалы 
-- 1) Изменим строки, если такие уже есть
update tb_plancen_year t
 set t.plcen=(select p.plcen
                from w_plancen.tb_plancen_plcen p,
                     w_plancen.tb_audi ap
                  where p.att_arid=ap.att_arid and
                        p.objtype=ap.att_objtype and
                        p_date<ap.att_arend and
                        p_date>=ap.att_arstart and
                        ap.att_arver=0 and ap.att_var=0 and
                        t.data_actual=p_date and
                        p.rn_mat=t.rn_mat and
                        p.id_prod=t.id_prod);
commit;
-- 2) Добавим новые строки                                     
insert into tb_plancen_year(data_actual,rn_izd,snz,id_prod,
                            rn_mat,ez,plcen_izd,plcen_snz,plcen,
                            avtor_izm,data_izm)
   select distinct p_date,null,null,p.id_prod,
          p.rn_mat,null,null,null,p.plcen,
          'Процедура W_MMKT.PK_DELTA.P_ZAPOLN_PLCEN',SYSDATE
     from w_plancen.tb_plancen_plcen p,
          w_plancen.tb_audi ap
       where 0=(select count(*)
                  from tb_plancen_year t
                    where t.data_actual=p_date and
                          t.rn_mat=p.rn_mat and
                          t.id_prod=p.id_prod) and
             p.att_arid=ap.att_arid and
             p.objtype=ap.att_objtype and
             p_date<ap.att_arend and
             p_date>=ap.att_arstart and
             ap.att_arver=0 and ap.att_var=0;                          
commit;
-- Добавим основную единицу измерения (цена расчитана на её основе)
update tb_plancen_year t
 set t.ez=(select t1.unit
             from w_sprmat.tb_mat_unit_alt t1
               where t1.material_rn=t.rn_mat and
                     t1.is_active=1);
commit;                     
end;
--*************************************************************
--Дельта по МАТЕРИАЛАМ в разрезе тех.отделов, извещений
PROCEDURE    p_delta_matizv(
                  p_par in varchar2, -- = 'КПП' или 'ШНЗ' или 'ДСЕ' или 'ОТМ'
                  p_value in varchar2, -- Условие для поиска(Обозначение ДСЕ, кпп, шнз)
                  p_tehotd in varchar2, -- Если=000, по всем Тех.Отделам
                  p_dstart in date, -- Дата начала заданного периода
                  p_dend in date, -- Дата конца заданного периода
                  p_data in date, -- Дата, на которую брать цены 
                  p_delta OUT curtyp
) AS
str_select varchar2(10000);
select_begin varchar2(10000);
select_end varchar2(10000);
select_body varchar2(10000);

begin
-- Начало у всех запросов общее
select_begin:='select --+ first_rows
                   v.snz, v.kpp, v.golova,v.obozn,
                   v.rn as rn_mat, v.name_full as name_mat, 
                   v.teh,v.gk,v.nn, v.nomizm, v.rn_izm, v.ez as ez_osn, 
                   v.ap, v.id_prod, 
                   nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0))) as plcen,
                   nvl2(v.plcen_izd,''Цена на изделие'',nvl2(v.plcen_snz,''Цена на заказ'',nvl2(v.plcen,''Общая цена'',''Нет цены''))) as tip_plcen,
                   v.ez_cen,
                   case when v.ez=v.ez_cen then
                          round(v.ap*(nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0)))),4)
                   else
                       -- перейдем к основной ед. изм.
                      (select round(v.ap*decode(av.is_active,1,(nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0)))),(nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0))))*av.recalc_value),4) 
                         from w_sprmat.tb_mat_unit_alt av
                          where av.material_rn=v.rn and 
                                av.unit=v.ez_cen)
                   end cen_ap_osn -- стоимость с учетом изменения применяемости на актуальную ед. изм.         
from(
select distinct  osn.*,
      pl1.plcen_izd, pl2.plcen_snz,pl3.plcen,pl3.ez as ez_cen
from(' ;
select_end:=' left join w_mmkt.tb_plancen_year pl1
        on pl1.rn_mat=osn.rn and pl1.rn_izd=osn.golova and pl1.data_actual=:x51
left join (select distinct c2.snz, c2.rn_mat, c2.plcen_snz
             from w_mmkt.tb_plancen_year c2
              where c2.data_actual=:x52) pl2 
         on pl2.rn_mat=osn.rn and pl2.snz=osn.snz
left join (select distinct c3.rn_mat,c3.id_prod,c3.plcen, c3.ez
             from w_mmkt.tb_plancen_year c3
              where c3.data_actual=:x53) pl3 
         on pl3.rn_mat=osn.rn and pl3.id_prod=osn.id_prod
) v
where ((:x77=''000'') or (v.teh=:x88))
order by v.id_prod,v.kpp,v.teh,v.nn,v.nomizm         
';
-- Если нужны данные на все заказы из плана ОТМ
if p_par='ОТМ' then
  select_body:=' select sh.snz, sh.kpp, sh.ind,w.golova,w.obozn,w.rn, w.name_full, w.teh, w.gk, w.nn,w.nomizm,w.rn_izm,   
         (select decode(w.is_active,1,w.ez,a.unit) 
          from w_sprmat.tb_mat_unit_alt a
            where a.material_rn=w.rn and a.is_active=1) ez,
         (select round(decode(w.is_active,1,w.ap,w.ap/a.recalc_value),4) 
           from w_sprmat.tb_mat_unit_alt a
             where a.material_rn=w.rn and a.unit=w.ez) ap,
          case when sh.po in (''0'',''1'') then
                    2
               else
                    1
               end id_prod                          
from( 
select --+ use_nl(p p1 p2 p3) 
      p.golova,p.obozn,p2.rn,p2.name_full,p.kornaim as teh,p2.gruppa_calc as gk,p2.nn,
       p.ez, p3.is_active,
       round(sum(p.ap*p.dolypodr),4) as ap, p.nomizm,p.rn_izm
from
(select --+ use_nl (otm t t1 t2 t3 t4 t5 e) 
   t.rn_tv as golova,otm.obozn,t1.rn_res,t1.rnisp,t1.rntv, t1.farid,
   t1.base, e.kornaim as ez, 
   max(decode(t1.base,''1'',t1.ap*(-1),t1.ap)/t.part) as ap,
   t3.nomizm,t3.rn as rn_izm,t5.kornaim,t4.dolypodr
from w_otk.tb_otm_kpp otm
     join w_mmkt.tb_res_ex t on otm.rn_tv=t.rn_tv
     join w_mmkt.tb_res_pr1_2 t1 on t.rn=t1.rn_res
     join w_mmkt.tb_auth_farid t2 on t1.farid=t2.farid
     join w_ktsg.tb_per_sogl t3 on t2.att_auth=t3.rn
     join w_ktsg.tb_doly_vig t4 on t3.rn=t4.rn_persogl
     join w_mp.tb_podr t5 on t4.rn_podr=t5.rn
     join w_ei.v_ei0 e on t1.ez=e.rn
where t.dstart>=:x11 and t.dend>:x12 and 
      t.dstart<:x13 and t.dend<=:x14 and
      t.part=1000000 and otm.year=(select extract(year from to_date(:x15))+1 FROM dual)
group by  t.rn_tv,otm.obozn,t1.rn_res,t1.rnisp,t1.rntv, t1.farid,t1.base, e.kornaim,
t3.nomizm,t3.rn,t5.kornaim,t4.dolypodr) p
  join w_ktsg.tb_isp_ob p1 on p.rnisp=p1.rn
  join w_sprmat.tb_mat_spr p2 on p1.rn_mat=p2.rn
  left join w_sprmat.tb_mat_unit_alt p3 on p2.rn=p3.material_rn and p.ez=p3.unit
group by p.golova,p.obozn,p2.rn,p2.name_full,p.kornaim,p2.gruppa_calc,p2.rn,p2.nn,p.ez,p3.is_active,p.nomizm, p.rn_izm 
) w
left join w_kts.h1shifr sh on w.OBOZN=sh.ind) osn ';
else
  select_body:=' select w.snz, w.kpp, w.golova,w.obozn,w.rn, w.name_full, w.teh, w.gk, w.nn,w.nomizm,w.rn_izm,   
         (select decode(w.is_active,1,w.ez,a.unit) 
          from w_sprmat.tb_mat_unit_alt a
            where a.material_rn=w.rn and a.is_active=1) ez,
         (select round(decode(w.is_active,1,w.ap,w.ap/a.recalc_value),4) 
           from w_sprmat.tb_mat_unit_alt a
             where a.material_rn=w.rn and a.unit=w.ez) ap,
          case when w.po in (''0'',''1'') then
                    2
               else
                    1
               end id_prod                          
from( 
select 
      p.snz, p.kpp,p.po,p.golova,p.OBOZN,p2.rn,p2.name_full,p.kornaim as teh,p2.gruppa_calc as gk,p2.nn,
       p.ez, p3.is_active,
       round(sum(p.ap*p.dolypodr),4) as ap, p.nomizm,p.rn_izm
from
(select --+ star 
   sh.snz,sh.kpp,sh.po,t.rn_tv as golova,isp.OBOZN,t1.rn_res,t1.rnisp,t1.rntv, t1.farid,
   t1.base, e.kornaim as ez, 
   max(decode(t1.base,''1'',t1.ap*(-1),t1.ap)/t.part) as ap,
   t3.nomizm,t3.rn as rn_izm,t5.kornaim,t4.dolypodr ';
  if p_par='ШНЗ' then
    select_body:=select_body || ' from w_kts.h1shifr sh
     join w_ktsg.v0_isp_ob_s isp on isp.OBOZN=sh.ind  
     join w_ktsg.tb_tv tv on tv.rn_ispob=isp.RN_ISPOB
     join w_mmkt.tb_res_ex t on t.rn_tv=tv.rn
     join w_mmkt.tb_res_pr1_2 t1 on t.rn=t1.rn_res
     join w_mmkt.tb_auth_farid t2 on t1.farid=t2.farid
     join w_ktsg.tb_per_sogl t3 on t2.att_auth=t3.rn
     join w_ktsg.tb_doly_vig t4 on t3.rn=t4.rn_persogl
     join w_mp.tb_podr t5 on t4.rn_podr=t5.rn
     join w_ei.v_ei0 e on t1.ez=e.rn
          where sh.snz like :x21||''%'' and ';
  elsif p_par='КПП' then
    select_body:=select_body || ' from w_kts.h1shifr sh
     join w_ktsg.v0_isp_ob_s isp on isp.OBOZN=sh.ind  
     join w_ktsg.tb_tv tv on tv.rn_ispob=isp.RN_ISPOB
     join w_mmkt.tb_res_ex t on t.rn_tv=tv.rn
     join w_mmkt.tb_res_pr1_2 t1 on t.rn=t1.rn_res
     join w_mmkt.tb_auth_farid t2 on t1.farid=t2.farid
     join w_ktsg.tb_per_sogl t3 on t2.att_auth=t3.rn
     join w_ktsg.tb_doly_vig t4 on t3.rn=t4.rn_persogl
     join w_mp.tb_podr t5 on t4.rn_podr=t5.rn
     join w_ei.v_ei0 e on t1.ez=e.rn
          where sh.kpp like :x22||''%'' and ';
  else -- По обозначению
    select_body:=select_body || ' from w_ktsg.v0_isp_ob_s isp
     left join w_kts.h1shifr sh on isp.OBOZN=sh.ind  
     join w_ktsg.tb_tv tv on tv.rn_ispob=isp.RN_ISPOB
     join w_mmkt.tb_res_ex t on t.rn_tv=tv.rn
     join w_mmkt.tb_res_pr1_2 t1 on t.rn=t1.rn_res
     join w_mmkt.tb_auth_farid t2 on t1.farid=t2.farid
     join w_ktsg.tb_per_sogl t3 on t2.att_auth=t3.rn
     join w_ktsg.tb_doly_vig t4 on t3.rn=t4.rn_persogl
     join w_mp.tb_podr t5 on t4.rn_podr=t5.rn
     join w_ei.v_ei0 e on t1.ez=e.rn
          where isp.pack_obozn like w_ktsg.f_pack_str(:x23)||''%'' and ';
  end if;
    select_body:=select_body || ' t.dstart>=:x31 and t.dend>:x32 and 
                                  t.dstart<:x33 and t.dend<=:x34 and
                                  t.part=1000000 
            group by sh.snz,sh.kpp, sh.po,t.rn_tv,isp.OBOZN,t1.rn_res,t1.rnisp,t1.rntv, t1.farid,t1.base, e.kornaim,
            t3.nomizm,t3.rn,t5.kornaim,t4.dolypodr) p
              join w_ktsg.tb_isp_ob p1 on p.rnisp=p1.rn
              join w_sprmat.tb_mat_spr p2 on p1.rn_mat=p2.rn
              left join w_sprmat.tb_mat_unit_alt p3 on p2.rn=p3.material_rn and p.ez=p3.unit
            group by p.snz, p.kpp,p.po,p.golova,p.OBOZN,p2.rn,p2.name_full,p.kornaim,p2.gruppa_calc,p2.rn,
                     p2.nn,p.ez,p3.is_active,p.nomizm, p.rn_izm ) w
            ) osn ';    
end if;
str_select:=select_begin||select_body||select_end;
--w_otk.p_load_log(str_select);
if p_par='ОТМ' then
   OPEN p_delta FOR str_select
   USING p_dstart,p_dstart,p_dend,p_dend,p_data,p_data,p_data,p_data,p_tehotd,p_tehotd;
else
  OPEN p_delta FOR str_select
   USING p_value,p_dstart,p_dstart,p_dend,p_dend,p_data,p_data,p_data,p_tehotd,p_tehotd;    
end if;         
/*if p_rntv >= 0 then 
 str_select:='select --+ first_rows
                   v.snz, v.kpp, v.golova,v.obozn,
                   v.rn as rn_mat, v.name_full as name_mat, 
                   v.teh,v.gk,v.nn, v.nomizm, v.rn_izm, v.ez as ez_osn, 
                   v.ap, v.id_prod, 
                   nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0))) as plcen,
                   nvl2(v.plcen_izd,''Цена на изделие'',nvl2(v.plcen_snz,''Цена на заказ'',nvl2(v.plcen,''Общая цена'',''Нет цены''))) as tip_plcen,
                   v.ez_cen,
                   case when v.ez=v.ez_cen then
                          round(v.ap*(nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0)))),4)
                   else
                       -- перейдем к основной ед. изм.
                      (select round(v.ap*decode(av.is_active,1,(nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0)))),(nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0))))*av.recalc_value),4) 
                         from w_sprmat.tb_mat_unit_alt av
                          where av.material_rn=v.rn and 
                                av.unit=v.ez_cen)
                   end cen_ap_osn -- стоимость с учетом изменения применяемости на актуальную ед. изм.         
from(
select distinct  osn.*,
      pl1.plcen_izd, pl2.plcen_snz,pl3.plcen,pl3.ez as ez_cen
from(
select sh.snz, sh.kpp, sh.ind,w.golova,w.obozn,w.rn, w.name_full, w.teh, w.gk, w.nn,w.nomizm,w.rn_izm,   
         (select decode(w.is_active,1,w.ez,a.unit) 
          from w_sprmat.tb_mat_unit_alt a
            where a.material_rn=w.rn and a.is_active=1) ez,
         (select round(decode(w.is_active,1,w.ap,w.ap/a.recalc_value),4) 
           from w_sprmat.tb_mat_unit_alt a
             where a.material_rn=w.rn and a.unit=w.ez) ap,
          case when sh.po in (''0'',''1'') then
                    2
               else
                    1
               end id_prod                          
from( 
select --+ use_nl(p p1 p2 p3) 
      p.golova,isp.OBOZN,p2.rn,p2.name_full,p.kornaim as teh,p2.gruppa_calc as gk,p2.nn,
       p.ez, p3.is_active,
       round(sum(p.ap*p.dolypodr),4) as ap, p.nomizm,p.rn_izm
from
(select --+ use_nl (t t1 t2 t3 t4 t5 e) 
   t.rn_tv as golova,t1.rn_res,t1.rnisp,t1.rntv, t1.farid,
   t1.base, e.kornaim as ez, 
   max(decode(t1.base,''1'',t1.ap*(-1),t1.ap)/t.part) as ap,
   t3.nomizm,t3.rn as rn_izm,t5.kornaim,t4.dolypodr
from w_mmkt.tb_res_ex t 
     join w_mmkt.tb_res_pr1_2 t1 on t.rn=t1.rn_res
     join w_mmkt.tb_auth_farid t2 on t1.farid=t2.farid
     join w_ktsg.tb_per_sogl t3 on t2.att_auth=t3.rn
     join w_ktsg.tb_doly_vig t4 on t3.rn=t4.rn_persogl
     join w_mp.tb_podr t5 on t4.rn_podr=t5.rn
     join w_ei.v_ei0 e on t1.ez=e.rn
where t.dstart>=:x1 and t.dend>:x2 and 
      t.dstart<:x3 and t.dend<=:x4 and
      t.part=1000000 and t.rn_tv=:x5
group by  t.rn_tv,t1.rn_res,t1.rnisp,t1.rntv, t1.farid,t1.base, e.kornaim,
t3.nomizm,t3.rn,t5.kornaim,t4.dolypodr) p
  join w_ktsg.tb_tv tv on p.golova=tv.rn
  join w_ktsg.v0_isp_ob_s isp on tv.rn_ispob=isp.RN_ISPOB
  join w_ktsg.tb_isp_ob p1 on p.rnisp=p1.rn
  join w_sprmat.tb_mat_spr p2 on p1.rn_mat=p2.rn
  left join w_sprmat.tb_mat_unit_alt p3 on p2.rn=p3.material_rn and p.ez=p3.unit
group by p.golova,isp.OBOZN,p2.rn,p2.name_full,p.kornaim,p2.gruppa_calc,p2.rn,p2.nn,p.ez,p3.is_active,p.nomizm, p.rn_izm 
) w
left join w_kts.h1shifr sh on w.OBOZN=sh.ind) osn
left join w_mmkt.tb_plancen_year pl1
        on pl1.rn_mat=osn.rn and pl1.rn_izd=osn.golova and pl1.data_actual=:x6
left join (select distinct c2.snz, c2.rn_mat, c2.plcen_snz
             from w_mmkt.tb_plancen_year c2
              where c2.data_actual=:x7) pl2 
         on pl2.rn_mat=osn.rn and pl2.snz=osn.snz
left join (select distinct c3.rn_mat,c3.id_prod,c3.plcen, c3.ez
             from w_mmkt.tb_plancen_year c3
              where c3.data_actual=:x8) pl3 
         on pl3.rn_mat=osn.rn and pl3.id_prod=osn.id_prod
) v
order by v.id_prod,v.kpp,v.teh,v.nn,v.nomizm';
 OPEN p_delta FOR str_select
 USING p_dstart,p_dstart,p_dend,p_dend,p_rntv,p_data,p_data,p_data;
else -- Если RN_TV не задан, показываем все ДСЕ из плана ОТМ
  OPEN p_delta FOR 'select --+ first_rows
                   v.snz, v.kpp, v.golova,v.obozn,
                   v.rn as rn_mat, v.name_full as name_mat, 
                   v.teh,v.gk,v.nn, v.nomizm, v.rn_izm, v.ez as ez_osn, 
                   v.ap, v.id_prod, 
                   nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0))) as plcen,
                   nvl2(v.plcen_izd,''Цена на изделие'',nvl2(v.plcen_snz,''Цена на заказ'',nvl2(v.plcen,''Общая цена'',''Нет цены''))) as tip_plcen,
                   v.ez_cen,
                   case when v.ez=v.ez_cen then
                          round(v.ap*(nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0)))),4)
                   else
                       -- перейдем к основной ед. изм.
                      (select round(v.ap*decode(av.is_active,1,(nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0)))),(nvl(v.plcen_izd,nvl(v.plcen_snz,nvl(v.plcen,0))))*av.recalc_value),4) 
                         from w_sprmat.tb_mat_unit_alt av
                          where av.material_rn=v.rn and 
                                av.unit=v.ez_cen)
                   end cen_ap_osn -- стоимость с учетом изменения применяемости на актуальную ед. изм.         
from(
select distinct  osn.*,
      pl1.plcen_izd, pl2.plcen_snz,pl3.plcen,pl3.ez as ez_cen
from(
select sh.snz, sh.kpp, sh.ind,w.golova,w.obozn,w.rn, w.name_full, w.teh, w.gk, w.nn,w.nomizm,w.rn_izm,   
         (select decode(w.is_active,1,w.ez,a.unit) 
          from w_sprmat.tb_mat_unit_alt a
            where a.material_rn=w.rn and a.is_active=1) ez,
         (select round(decode(w.is_active,1,w.ap,w.ap/a.recalc_value),4) 
           from w_sprmat.tb_mat_unit_alt a
             where a.material_rn=w.rn and a.unit=w.ez) ap,
          case when sh.po in (''0'',''1'') then
                    2
               else
                    1
               end id_prod                          
from( 
select --+ use_nl(p p1 p2 p3) 
      p.golova,p.obozn,p2.rn,p2.name_full,p.kornaim as teh,p2.gruppa_calc as gk,p2.nn,
       p.ez, p3.is_active,
       round(sum(p.ap*p.dolypodr),4) as ap, p.nomizm,p.rn_izm
from
(select --+ use_nl (otm t t1 t2 t3 t4 t5 e) 
   t.rn_tv as golova,otm.obozn,t1.rn_res,t1.rnisp,t1.rntv, t1.farid,
   t1.base, e.kornaim as ez, 
   max(decode(t1.base,''1'',t1.ap*(-1),t1.ap)/t.part) as ap,
   t3.nomizm,t3.rn as rn_izm,t5.kornaim,t4.dolypodr
from w_otk.tb_otm_kpp otm
     join w_mmkt.tb_res_ex t on otm.rn_tv=t.rn_tv
     join w_mmkt.tb_res_pr1_2 t1 on t.rn=t1.rn_res
     join w_mmkt.tb_auth_farid t2 on t1.farid=t2.farid
     join w_ktsg.tb_per_sogl t3 on t2.att_auth=t3.rn
     join w_ktsg.tb_doly_vig t4 on t3.rn=t4.rn_persogl
     join w_mp.tb_podr t5 on t4.rn_podr=t5.rn
     join w_ei.v_ei0 e on t1.ez=e.rn
where t.dstart>=:x1 and t.dend>:x2 and 
      t.dstart<:x3 and t.dend<=:x4 and
      t.part=1000000 and otm.year=(select extract(year from to_date(:x5))\*+1*\ FROM dual)
group by  t.rn_tv,otm.obozn,t1.rn_res,t1.rnisp,t1.rntv, t1.farid,t1.base, e.kornaim,
t3.nomizm,t3.rn,t5.kornaim,t4.dolypodr) p
  join w_ktsg.tb_isp_ob p1 on p.rnisp=p1.rn
  join w_sprmat.tb_mat_spr p2 on p1.rn_mat=p2.rn
  left join w_sprmat.tb_mat_unit_alt p3 on p2.rn=p3.material_rn and p.ez=p3.unit
group by p.golova,p.obozn,p2.rn,p2.name_full,p.kornaim,p2.gruppa_calc,p2.rn,p2.nn,p.ez,p3.is_active,p.nomizm, p.rn_izm 
) w
left join w_kts.h1shifr sh on w.OBOZN=sh.ind) osn
left join w_mmkt.tb_plancen_year pl1
        on pl1.rn_mat=osn.rn and pl1.rn_izd=osn.golova and pl1.data_actual=:x6
left join (select distinct c2.snz, c2.rn_mat, c2.plcen_snz
             from w_mmkt.tb_plancen_year c2
              where c2.data_actual=:x7) pl2 
         on pl2.rn_mat=osn.rn and pl2.snz=osn.snz
left join (select distinct c3.rn_mat,c3.id_prod,c3.plcen, c3.ez
             from w_mmkt.tb_plancen_year c3
              where c3.data_actual=:x8) pl3 
         on pl3.rn_mat=osn.rn and pl3.id_prod=osn.id_prod
) v
order by v.id_prod,v.kpp,v.teh,v.nn,v.nomizm'
 USING p_dstart,p_dstart,p_dend,p_dend,p_data,p_data,p_data,p_data;
end if;*/
end;  
END PK_DELTA;
/
----------------------------------------
--  Changed package body pk_mmk_info  --
----------------------------------------
CREATE OR REPLACE PACKAGE BODY W_MMKT.PK_MMK_INFO IS

sql_tv VARCHAR2(2500):='
select /*+star*/io.OBOZN, t.VI,p.tvnaim,
CASE io.TIP_ISPOB
    WHEN ''С'' THEN ''Свой''
    WHEN ''П'' THEN ''Покупной''
    WHEN ''М'' THEN ''Мусор''
    WHEN ''О'' THEN ''Ограничитель материалов''
    WHEN ''Д'' THEN ''Материал с доработкой''
  END AS TIP_NAIM,
  io.tip_ispob,
  vio.naim AS VID_NAIM,
  vio.kornaim as kvid,
  p.tvmassa,
  i.rn_mat,
nvl(w_mmkt.pk_mmk_info.F_trud(p.rn_tv,-1,:x0),'' '') tr,
p.tvnote,
f_ismmk(t.rn) as IND_MMK,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=t.rn and p.pornom_tv>=0)>0 then
(SELECT MAX(ps.NOMIZM) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv itv WHERE ps.RN = itv.rn_persogl AND ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'') AND itv.rn_tv = t.rn)
else
''  ''
end as IND_PS,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=t.rn and p.pornom_tv>=0)>0 then
(SELECT MAX(ps.rn) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv itv WHERE ps.RN = itv.rn_persogl AND ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'') AND itv.rn_tv = t.rn)
else
null
end as RN_PS,
case when ind_nalcomp=1 then
     ''+''
when ind_nalcomp is null then
        ''Нет данных''     
else
     ''-''
end as IND_NC
from
     w_ktsg.v0_isp_ob_s io
     join w_ktsg.v_isp_ob i on io.rn_ispob=i.rn
     join w_ktsg.tb_tv t on io.rn_ispob=t.rn_ispob
     left join w_ktsg.v0_tv_s p on t.rn=p.rn_tv
     JOIN w_ktsg.v_vid_isp_ob vio ON i.rn_vid_ispob=vio.rn
     where t.RN = :x1';
sql_tv_mv VARCHAR2(2500):='
select /*+star*/io.OBOZN, t.VI,t.tvnaim,
CASE io.TIP_ISPOB
    WHEN ''С'' THEN ''Свой''
    WHEN ''П'' THEN ''Покупной''
    WHEN ''М'' THEN ''Мусор''
    WHEN ''О'' THEN ''Ограничитель материалов''
    WHEN ''Д'' THEN ''Материал с доработкой''
  END AS TIP_NAIM,
  io.tip_ispob,
  vio.naim AS VID_NAIM,
  vio.kornaim as kvid,
  t.tvmassa,
  io.rn_mat,
nvl(w_mmkt.pk_mmk_info.F_trud(t.rn,-1,:x0),'' '') tr,
t.tvnote,
f_ismmk(t.rn) as IND_MMK,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=t.rn and p.pornom_tv>=0)>0 then
(SELECT MAX(ps.NOMIZM) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv itv WHERE ps.RN = itv.rn_persogl AND ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'') AND itv.rn_tv = t.rn)
else
''  ''
end as IND_PS,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=t.rn and p.pornom_tv>=0)>0 then
(SELECT MAX(ps.rn) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv itv WHERE ps.RN = itv.rn_persogl AND ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'') AND itv.rn_tv = t.rn)
else
null
end as RN_PS,
case when ind_nalcomp=1 then
     ''+''
     when ind_nalcomp is null then
        ''Нет данных''
else
     ''-''
end as IND_NC
from
     w_ktsg.mv_isp_ob io
     left join w_ktsg.mv_tv t on io.rn=t.rn_ispob
     join w_ktsg.tb_tv t1 on io.rn=t1.rn_ispob
     JOIN w_ktsg.v_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
     where t1.RN = :x1';
sql_ps varchar2(5000) :=
'select t.NOMIZM,t.OSNOVANIE,
case
     when instr(subject_of_audit,'' '')=0 then
     subject_of_audit
else
substr(subject_of_audit,
                                       1,

                                       instr(subject_of_audit, '' '')) ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '') + 1,
                                       1) || ''.'' ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '', 1, 2) + 1,
                                       1) || ''.''
                                       end AS SOA,
t.IND_STEXIST,
case when t.IND_STEXIST =''Р'' then ''Разработка''
when t.IND_STEXIST =''У'' then ''Утверждено''
when t.IND_STEXIST =''С'' then ''Согласование''
when t.IND_STEXIST =''Н'' then ''Унаследованный''
else ''Неизвестен''
end as IND_STEXIST_L,
t.DT_IZMSTEXIST,
p.SHORTNAME ||'' - '' || p.FULLNAME as TNAME,nvl(t.isp_zadel,-1) as isp_zadel,t.srok_vnedr,
t.psnote,
f_get_str_rspr(t.rn) as rspr
from
w_ktsg.v_per_sogl t
join w_osnov.v_tb_typedoc p on t.rn_typedoc=p.RN
left join w_ad.v_subject_of_audit a on t.RN_SOTR_AVT=a.GUID
where t.rn=:x1
';
sql_mo_mv VARCHAR2(5000):='
    SELECT
          NULL AS TEHNDOBSTRING,
           mos.att_arid AS arid,
           mos.pornom,
           mos.kpodr AS podr,
           mos.kvo AS VO,
           vn.NAIM || '' ('' || mos.kvo || '')''  AS VONAIM,
           mos.POZMONOTE
    FROM
         w_ktsg.mv_poz_mo mos
         LEFT JOIN w_vo.tb_vo_naim vn ON mos.rn_vo=vn.rn
    WHERE
          mos.rn_Tv= :x1
          order by mos.pornom';
sql_mo VARCHAR2(5000):='SELECT
          NULL AS TEHNDOBSTRING,
           mos.att_arid AS arid,
           mo.pornom,
           p.kornaim AS podr,
           v.kornaim AS VO,
           vn.NAIM || '' ('' || v.kornaim || '')''  AS VONAIM,
           mos.POZMONOTE
    FROM
         w_ktsg.v0_poz_mo_s mos
         JOIN w_ktsg.v_poz_mo mo ON mos.RN_POZMO=mo.rn
         JOIN w_mp.tb_podr p ON mos.rn_podr=p.rn
         JOIN w_vo.tb_vo v ON mos.RN_VO=v.rn
         LEFT JOIN w_vo.tb_vo_naim vn ON v.rn=vn.rn
    WHERE
          mos.rn_Tv= :x1
          order by mo.pornom';

sql_zag_mv VARCHAR2(5000):='SELECT --+star
  ios.obozn AS OBOZN,
  vio.naim AS VID_NAIM,
  vio.kornaim as kvid,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''изготавливаемый''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
  tz.NORMRASH,
  tz.KOLDETZAG,
  tz.VESZAG,
  tz.GEOMR_DL,
  tz.GEOMR_SH,
  tz.kornaim,
  tz.VIDZAG || case when vz.naim_vid is not null then '' ('' || vz.naim_vid || '')'' end AS VIDZAG_NAME,
  tz.TZAGNOTE,
  tv.rn as rntv_z,
  ios.rn_mat,
  ios.rn,
  ma.nn,
  ma.name_full
FROM
     w_ktsg.mv_t_zag tz
     JOIN w_ktsg.mv_isp_ob ios ON tz.RN_ISPOB_ZAG=ios.RN
     left join w_ktsg.mv_tv tv on tz.rn_ispob_zag=tv.rn_ispob
     JOIN w_ktsg.v_vid_isp_ob vio ON ios.rn_vid_ispob=vio.rn
     LEFT JOIN W_VIDZAG.TB_VID_ZAG vz ON vz.id_vid=tz.VIDZAG
     LEFT JOIN w_sprmat.tb_mat_spr ma ON ios.rn_mat=ma.rn
WHERE tz.RN_TV=  :x1
';
sql_zag VARCHAR2(5000):='SELECT --+star
ios.obozn AS OBOZN,
  vio.naim AS VID_NAIM,
  vio.kornaim as kvid,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''свой''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
  tz.NORMRASH,
  tz.KOLDETZAG,
  tz.VESZAG,
  tz.GEOMR_DL,
  tz.GEOMR_SH,
  ei.kornaim,
  tz.VIDZAG || case when vz.naim_vid is not null then '' ('' || vz.naim_vid || '')'' end AS VIDZAG_NAME,
  tz.TZAGNOTE,
  tv.rn as rntv_z,
  io.rn_mat,
  io.rn,
  ma.nn,
  ma.name_full
FROM
     w_ktsg.v0_t_zag_s tz
     JOIN w_ktsg.v0_isp_ob_s ios ON tz.RN_ISPOB_ZAG=ios.RN_ISPOB
     left join w_ktsg.v_tv tv on tz.rn_ispob_zag=tv.rn_ispob
     JOIN w_ktsg.v_isp_ob io ON io.rn=tz.RN_ISPOB_ZAG
     JOIN w_ktsg.v_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
     LEFT JOIN W_VIDZAG.TB_VID_ZAG vz ON vz.id_vid=tz.VIDZAG
     JOIN w_ei.tb_ei  ei ON tz.RN_EI=ei.rn
     LEFT JOIN w_sprmat.tb_mat_spr ma ON io.rn_mat=ma.rn
WHERE tz.RN_TV=  :x1';
sql_izm VARCHAR2(5000) :='select t.*,
p.ind_stexist,
CASE WHEN p.ind_stexist=''Н'' THEN ''Унаследованный''
     WHEN p.ind_stexist=''Р'' THEN ''Разработка''
     WHEN p.ind_stexist=''С'' THEN ''Согласование''
     WHEN p.ind_stexist=''У'' THEN ''Утверждено''
     ELSE ''Неизвестно''
     END AS i_state
from TABLE ( cast(w_mmkt.pk_mmk_info.F_GET_IZMTV(:x1,:x2) as w_mmkt.tb_izmtv)) t
JOIN w_ktsg.tb_per_sogl p ON t.rn=p.rn
order by t.dt_izmstexist desc';

   -- Function and procedure implementations
   FUNCTION F_GET_IZMTV (p_rntv IN NUMBER, p_date IN DATE DEFAULT NULL) RETURN tb_izmtv PIPELINED
   AS
   tmp rec_tb_izmtv;
   rn_ps NUMBER :=0;
   vDate DATE;
   vCnt PLS_INTEGER;
   BEGIN
   vDate:=p_date;
   IF p_date IS NULL THEN
      vDate:=trunc(SYSDATE);
   END IF;
tmp:=rec_tb_izmtv(NULL,NULL,NULL,NULL,NULL);
SELECT COUNT(*) INTO vCnt FROM mv_persogl_tv;
IF vDate=trunc(SYSDATE) AND vCnt<>0 THEN
FOR c IN (SELECT --+star
p.NOMIZM,p.RN, t.DT_IZMSTEXIST AS dstart,p.DT_IZMSTEXIST,
--f_isaudistates(t.rn_persogl,t.rn_tv) as kolstate
case when f_isaudistates(t.rn_persogl,t.rn_tv)>0 then '+'
else '-'
end  as kolstate
from mv_persogl_tv t
JOIN w_ktsg.v_per_sogl p ON t.rn_persogl=p.RN
JOIN w_osnov.v_tb_prich pr ON p.RN=pr.RN
 WHERE t.rn_tv=p_rntv
 ORDER BY t.DT_IZMSTEXIST DESC,p.DT_IZMSTEXIST desc
 ) LOOP
       IF rn_ps  <> c.rn THEN
          tmp.nomizm:=nvl(trim(c.nomizm),'...');
          tmp.rn:=c.rn;
          tmp.dt_izmstexist:=c.dt_izmstexist;
          tmp.kolstate:=c.kolstate;
          tmp.att_arstart:=c.dstart;
          PIPE ROW (tmp);
          rn_ps:=c.rn;
       END IF;
 END LOOP;
ELSIF vDate=trunc(SYSDATE) AND vCnt=0 THEN
FOR c IN (SELECT --+star
p.NOMIZM,p.RN, t.dt_zavrazr AS dstart,p.DT_IZMSTEXIST,
--f_isaudistates(t.rn_persogl,t.rn_tv) as kolstate
case when f_isaudistates(t.rn_persogl,t.rn_tv)>0 then '+'
else '-'
end  as kolstate
from w_ktsg.tb_izm_tv t
JOIN w_ktsg.v_per_sogl p ON t.rn_persogl=p.RN
JOIN w_osnov.v_tb_prich pr ON p.RN=pr.RN
 WHERE t.rn_tv=p_rntv
 ORDER BY t.dt_zavrazr DESC,p.DT_IZMSTEXIST desc
 ) LOOP
       IF rn_ps  <> c.rn THEN
          tmp.nomizm:=nvl(trim(c.nomizm),'...');
          tmp.rn:=c.rn;
          tmp.dt_izmstexist:=c.dt_izmstexist;
          tmp.kolstate:=c.kolstate;
          tmp.att_arstart:=c.dstart;
          PIPE ROW (tmp);
          rn_ps:=c.rn;
       END IF;
 END LOOP; 
ELSE
FOR c IN (SELECT --+star
p.NOMIZM,p.RN, t.DT_IZMSTEXIST AS dstart,p.DT_IZMSTEXIST,
--f_isaudistates(t.rn_persogl,t.rn_tv) as kolstate
case when f_isaudistates(t.rn_persogl,t.rn_tv)>0 then '+'
else '-'
end  as kolstate
from --mv_persogl_tv t
v_persogl_tv_onlyizmtv t
JOIN w_ktsg.v_per_sogl p ON t.rn_persogl=p.RN
JOIN w_osnov.v_tb_prich pr ON p.RN=pr.RN
 WHERE t.rn_tv=p_rntv
 ORDER BY t.DT_IZMSTEXIST DESC
 ) LOOP
       IF rn_ps  <> c.rn THEN
          tmp.nomizm:=nvl(trim(c.nomizm),'...');
          tmp.rn:=c.rn;
          tmp.dt_izmstexist:=c.dt_izmstexist;
          tmp.kolstate:=c.kolstate;
          tmp.att_arstart:=c.dstart;
          PIPE ROW (tmp);
          rn_ps:=c.rn;
       END IF;
 END LOOP;
END IF;
 RETURN;
END;

   PROCEDURE P_FIND(P_OBOZN  IN VARCHAR2,
                    P_CONT   IN VARCHAR2,
                    P_KOL    IN INTEGER,
                    P_CURSEL OUT curtyp) AS
      str VARCHAR2(255);
   BEGIN
      str := p_obozn || '%';
      IF P_CONT = 'Y' THEN
         str := '%' || str;
      END IF;

      OPEN p_cursel FOR 'SELECT
       tv.rn,
       t.OBOZN,
       tv.vi,
       tv0.TVNAIM
FROM
       w_ktsg.v0_tv_s tv0,
       w_ktsg.tb_tv tv,
       w_ktsg.v0_isp_ob_s t
WHERE
      t.RN_ISPOB=tv.rn_ispob(+) AND
      tv0.RN_TV(+)=tv.rn AND t.obozn LIKE :x1'
         USING str;
   END;

   FUNCTION F_MO(P_RN IN INTEGER) RETURN VARCHAR2 IS
      -- Функция выдает маршрут (цехвоцехво) по RN
      CURSOR s1 IS
         SELECT t.PORNOM, t1.kornaim, lower(t2.kornaim) vobr
           FROM v_poz_mo0 t, w_mp.v_podr t1, w_vo.v_vo t2
          WHERE t.RN_TV = P_RN
            AND t.RN_PODR = t1.rn
            AND t.RN_VO = t2.rn
          ORDER BY t.PORNOM;

      RS1 s1%ROWTYPE;
      s   VARCHAR2(1024);
      f   BOOLEAN; -- показывает, есть ли отрицательные позиции в маршруте
      i   PLS_INTEGER; -- номер (по счету) отрицательной позиции
      y   PLS_INTEGER; -- номер (по счету) положительной позиции

   BEGIN
      f := FALSE;
      i := 0;
      y := 0;
      OPEN s1;
      LOOP
         FETCH s1
            INTO rs1;
         EXIT WHEN s1%NOTFOUND;
         IF rs1.pornom < 0 THEN
            f := TRUE;
            IF i = 0 THEN
               s := s || '(' || rs1.kornaim || rs1.vobr || ' ';
               i := 1;
            ELSE
               s := s || rs1.kornaim || rs1.vobr || ' ';
            END IF;
         ELSE
            IF f = FALSE THEN
               s := s || rs1.kornaim || rs1.vobr || ' ';
            ELSE
               IF y = 0 THEN
                  s := substr(s, 1, length(s) - 1) || ') ' || rs1.kornaim ||
                       rs1.vobr || ' ';
                  y := 1;
               ELSE
                  s := s || rs1.kornaim || rs1.vobr || ' ';
               END IF;
            END IF;
         END IF;
      END LOOP;
      CLOSE s1;
      IF i = 1 AND y = 0 THEN
         s := substr(s, 1, length(s) - 1) || ') ';
      END IF;
      RETURN(s);
   END;

   FUNCTION F_TRUD(P_RN IN NUMBER,
            p_dst IN INTEGER DEFAULT 0/*0-только вед, 1-тетрадные, -1 - определение*/,
            p_date IN DATE DEFAULT w_ktsg.pk_values.curdate) RETURN VARCHAR2 IS
      -- Функция выдает цеха с трудом  по RN
      s VARCHAR2(1024) := '';
      v_Department VARCHAR2(3):= SUBSTR(w_ad.f_ad_get_attrvalue_by_login(w_ad.f_get_current_aduser_login,'physicalDeliveryOfficeName'),1,3);
      cur DATE;
   BEGIN
   IF p_dst=-1 THEN
      IF v_Department IN ('105','140') THEN
          SELECT
                      t.trud_str_tip  INTO s
          FROM table( cast(f_mv_tv_inf_str(p_rn,p_date) AS t_mv_tv_inf_set)) t;
      ELSE
          SELECT
               t.trud_str  INTO s
          FROM table( cast(f_mv_tv_inf_str(p_rn, p_date) AS t_mv_tv_inf_set)) t;
      END IF;
   ELSE
          SELECT
      decode(p_dst,0,t.trud_str,1,t.trud_str_tip,t.trud_str)  INTO s
          FROM table( cast(f_mv_tv_inf_str(p_rn,p_date) AS t_mv_tv_inf_set)) t;
   END iF;
      RETURN(s);
   END;

   /* PROCEDURE P_FIND_1(P_OBOZN  IN VARCHAR2,
                         P_CONT   IN VARCHAR2,
                         P_KOL    IN INTEGER,
                         P_CURSEL OUT curtyp) AS
         str  VARCHAR2(255);
         p_mater number;     -- Признак материала

      BEGIN
         p_mater:=1005;
         str := p_obozn || '%';
         IF P_CONT = 'Y' THEN
            str := '%' || str;
         END IF;

         OPEN p_cursel FOR 'with DET as (SELECT tv.rn,
                        t.OBOZN||chr(125)||tv.vi||chr(32)||
                        case
                        when tv0.doly is not null
                           then chr(40)||tv0.doly*100||chr(37)||chr(41)
                        end
                        ||chr(125)||tv0.TVNAIM OBOZN,
                        tv.vi,
                        tv0.TVNAIM,
                        w_mmkt.pk_mmk_info.F_MO(tv.rn) m,
                        tv.ind_nalComp
                 FROM
                        w_ktsg.v0_tv_s tv0,
                        w_ktsg.tb_tv tv,
                        w_ktsg.v0_isp_ob_s t
                 WHERE
                       t.RN_ISPOB=tv.rn_ispob(+) AND
                       tv0.RN_TV(+)=tv.rn AND t.obozn like :x1)
   SELECT DET.rn, DET.OBOZN, DET.vi, DET.TVNAIM, DET.m||chr(125)||
                case
                  when io.rn_vid_ispob=:x2 and mat.rn is not null
                     then mat.nn
                  when io.rn_vid_ispob=:x3 and mat.rn is null
                     then rpad(chr(48),15,chr(48))
                  else
                     null
                end ||chr(125)||
                case
                when (tz.OBOZN is null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                      then case
                           when  DET.ind_nalComp = 0
                                then chr(45)||chr(45)
                           when  DET.ind_nalComp = 1
                                then chr(45)
                           end
                when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                      then tz.OBOZN
                when (tz.OBOZN is not null) and (z.GEOMR_DL is not null) and (z.GEOMR_SH is null)
                      then tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL
                when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is not null)
                      then tz.OBOZN||chr(32)||chr(83)||chr(61)||z.GEOMR_SH
                else
                     tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL||chr(42)||z.GEOMR_SH
                end  m,
                case
                  when io.rn_vid_ispob=:x4 and mat.rn is not null
                     then mat.nn
                  when io.rn_vid_ispob=:x5 and mat.rn is null
                     then rpad(chr(48),15,chr(48))
                  else
                     null
                end nom_num,
                case
                when (tz.OBOZN is null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                      then case
                           when  DET.ind_nalComp = 0
                                then chr(45)||chr(45)
                           when  DET.ind_nalComp = 1
                                then chr(45)
                           end
                when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                      then tz.OBOZN
                when (tz.OBOZN is not null) and (z.GEOMR_DL is not null) and (z.GEOMR_SH is null)
                      then tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL
                when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is not null)
                      then tz.OBOZN||chr(32)||chr(83)||chr(61)||z.GEOMR_SH
                else
                     tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL||chr(42)||z.GEOMR_SH
                end z
   FROM   DET,
          w_ktsg.v0_t_zag_s z,
          w_ktsg.v0_isp_ob_s tz,
          w_ktsg.tb_isp_ob io,
          w_sprmat.tb_mat_spr mat
   WHERE
          DET.rn=z.RN_TV(+) and
          z.RN_ISPOB_ZAG=tz.RN_ISPOB(+) and
          mat.rn(+)=io.rn_mat and
          io.rn(+)=z.RN_ISPOB_ZAG  '
            USING str, p_mater, p_mater, p_mater, p_mater;
      END;
   */
   PROCEDURE P_FIND_1(P_OBOZN  IN VARCHAR2,
                      P_CONT   IN VARCHAR2,
                      P_KOL    IN INTEGER,
                      P_PACKED IN VARCHAR2,
                      P_CURSEL OUT curtyp) AS

      -- P_CONT    - параметр, показывающий поиск с начала строки(N) или по подстроке(Y)
      -- P_PACKED  - показывает поиск по сжатому обозначению или нет

      str      VARCHAR2(255); -- условие поиска по обозначению
      str_pack VARCHAR2(255); -- условие поиска по сжатому обозначению
      p_mater  NUMBER; -- Признак материала

   BEGIN
      p_mater := 1005;
      -- Проверяем, нужен поиск по сжатому обозначению или нет
      IF P_PACKED = 'TRUE' THEN
         str      := '%';
         str_pack := w_common.f_pack_str(p_obozn) || '%';
         IF P_CONT = 'Y' THEN
            str_pack := '%' || str_pack;
         END IF;
      ELSE
         str_pack := '%';
         str      := p_obozn || '%';
         IF P_CONT = 'Y' THEN
            str := '%' || str;
         END IF;
      END IF;

      OPEN p_cursel FOR 'with DET as (SELECT tv.rn,
                     t.OBOZN||chr(125)||tv.vi||chr(32)||
                     case
                     when tv0.doly is not null
                        then chr(40)||tv0.doly*100||chr(37)||chr(41)
                     end
                     ||chr(125)||tv0.TVNAIM OBOZN,
                     tv.vi,
                     tv0.TVNAIM,
                     w_mmkt.pk_mmk_info.F_MO(tv.rn) m,
                     tv.ind_nalComp
              FROM
                     w_ktsg.v0_tv_s tv0,
                     w_ktsg.tb_tv tv,
                     w_ktsg.v0_isp_ob_s t
              WHERE
                    t.RN_ISPOB=tv.rn_ispob(+) AND
                    tv0.RN_TV(+)=tv.rn AND t.obozn like :x1 AND t.pack_obozn like :x2)
SELECT DET.rn, DET.OBOZN, DET.vi, DET.TVNAIM, DET.m||chr(125)||
             case
               when io.rn_vid_ispob=:x3 and mat.rn is not null
                  then mat.nn
               when io.rn_vid_ispob=:x4 and mat.rn is null
                  then rpad(chr(48),15,chr(48))
               else
                  null
             end ||chr(125)||
             case
             when (tz.OBOZN is null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                   then case
                        when  DET.ind_nalComp = 0
                             then chr(45)||chr(45)
                        when  DET.ind_nalComp = 1
                             then chr(45)
                        end
             when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                   then tz.OBOZN
             when (tz.OBOZN is not null) and (z.GEOMR_DL is not null) and (z.GEOMR_SH is null)
                   then tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL
             when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is not null)
                   then tz.OBOZN||chr(32)||chr(83)||chr(61)||z.GEOMR_SH
             else
                  tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL||chr(42)||z.GEOMR_SH
             end  m,
             case
               when io.rn_vid_ispob=:x5 and mat.rn is not null
                  then mat.nn
               when io.rn_vid_ispob=:x6 and mat.rn is null
                  then rpad(chr(48),15,chr(48))
               else
                  null
             end nom_num,
             case
             when (tz.OBOZN is null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                   then case
                        when  DET.ind_nalComp = 0
                             then chr(45)||chr(45)
                        when  DET.ind_nalComp = 1
                             then chr(45)
                        end
             when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                   then tz.OBOZN
             when (tz.OBOZN is not null) and (z.GEOMR_DL is not null) and (z.GEOMR_SH is null)
                   then tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL
             when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is not null)
                   then tz.OBOZN||chr(32)||chr(83)||chr(61)||z.GEOMR_SH
             else
                  tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL||chr(42)||z.GEOMR_SH
             end z
FROM   DET,
       w_ktsg.v0_t_zag_s z,
       w_ktsg.v0_isp_ob_s tz,
       w_ktsg.tb_isp_ob io,
       w_sprmat.tb_mat_spr mat
WHERE
       DET.rn=z.RN_TV(+) and
       z.RN_ISPOB_ZAG=tz.RN_ISPOB(+) and
       mat.rn(+)=io.rn_mat and
       io.rn(+)=z.RN_ISPOB_ZAG  '
         USING str, str_pack, p_mater, p_mater, p_mater, p_mater;
   END;
--*************************************************************
PROCEDURE    p_tv_info(p_rntv IN NUMBER,
                                      p_date IN DATE,
                                      p_tv OUT curtyp) AS
BEGIN
w_ktsg.pk_values.set_curdate(p_date);
IF p_date=trunc(SYSDATE) THEN -- Материализованное представление
-- Тех вариант
OPEN p_tv FOR sql_tv_mv
         USING p_date,p_rntv;
ELSE
OPEN p_tv FOR sql_tv
         USING p_date,p_rntv;
END IF;
END;
--*************************************************************
PROCEDURE    p_izd_cexs(p_rntv IN NUMBER,
                                      p_date IN DATE,
                                      p_cur OUT curtyp) AS
BEGIN
OPEN p_cur FOR
'SELECT
  DISTINCT p.rn,p.kornaim
FROM TABLE(f_mmk_raskomp_kalc(:x1,:x2,1000000)) t
JOIN w_mp.tb_podr p ON t.cex=p.rn
order by p.kornaim
' USING p_rntv,p_date;

END;
--*************************************************************
PROCEDURE    p_izd_dce_by_cex(p_rntv IN NUMBER,
                        p_cex IN VARCHAR2,
                        p_date IN DATE,
                        p_cur OUT curtyp) AS
BEGIN
IF p_date=trunc(SYSDATE) THEN
OPEN p_cur FOR '
  SELECT
    DISTINCT t.kdce_ch,t.tv_ch,p.rn AS rn_podr,io.obozn,tv.vi,tvs.TVNAIM,round(ap1/1000000,5) AS ap,
    CASE WHEN instr(mv.mo_str,''('')<>0 THEN
         substr(mv.mo_str,1,instr(mv.mo_str,''('')-2)
    ELSE
         mv.mo_str
    END AS mo_str,
  w_otkv.f_istrud_podr(tv.rn,p.rn,0) AS Trud_Oper,
  w_otkv.f_istrud_podr(tv.rn,p.rn,1) AS Trud_Tetr
  FROM (
  SELECT kdce_ch,tv_ch,cex,ind,
  CASE WHEN ind=0 THEN MAX(kol) over (PARTITION BY kdce_ch,ind,ez)
             ELSE SUM(kol) over (PARTITION BY kdce_ch,ind,ez) END kol1,
        CASE WHEN ind=0 THEN MAX(ap) over (PARTITION BY kdce_ch,ind,ez)
             ELSE SUM(ap) over (PARTITION BY kdce_ch,ind,ez) END ap1
   FROM
  TABLE(f_mmk_raskomp_kalc(:x1,:x2,1000000))
  ) t
  JOIN w_mp.tb_podr p ON t.cex=p.rn
  JOIN w_ktsg.v0_isp_ob_s io ON t.kdce_ch=io.RN_ISPOB
  LEFT JOIN w_ktsg.tb_tv tv ON t.tv_ch=tv.rn
  LEFT JOIN w_ktsg.v0_tv_s tvs ON t.tv_ch=tvs.RN_TV
  LEFT JOIN w_mmkt.mv_Tv_inf mv ON t.tv_ch=mv.rn
  WHERE p.kornaim=:x3 AND t.ind=0
  ORDER BY io.obozn' USING p_rntv,p_date,p_cex;
ELSE
OPEN p_cur FOR '
  SELECT
    DISTINCT t.kdce_ch,t.tv_ch,p.rn AS rn_podr,io.obozn,tv.vi,tvs.TVNAIM,ap1/1000000 AS ap,
    f_mo_str(t.tv_ch,0,:x01) AS mo_str,
  w_otkv.f_istrud_podr(tv.rn,p.rn,0,:x02) AS Trud_Oper,
  w_otkv.f_istrud_podr(tv.rn,p.rn,1,:x03) AS Trud_Tetr
  FROM (
  SELECT kdce_ch,tv_ch,cex,ind,
  CASE WHEN ind=0 THEN MAX(kol) over (PARTITION BY kdce_ch,ind,ez)
             ELSE SUM(kol) over (PARTITION BY kdce_ch,ind,ez) END kol1,
        CASE WHEN ind=0 THEN MAX(ap) over (PARTITION BY kdce_ch,ind,ez)
             ELSE SUM(ap) over (PARTITION BY kdce_ch,ind,ez) END ap1
   FROM
  TABLE(f_mmk_raskomp_kalc(:x1,:x2,1000000))
  ) t
  JOIN w_mp.tb_podr p ON t.cex=p.rn
  JOIN w_ktsg.v0_isp_ob_s io ON t.kdce_ch=io.RN_ISPOB
  LEFT JOIN w_ktsg.tb_tv tv ON t.tv_ch=tv.rn
  LEFT JOIN w_ktsg.v0_tv_s tvs ON t.tv_ch=tvs.RN_TV
  LEFT JOIN w_mmkt.mv_Tv_inf mv ON t.tv_ch=mv.rn
  WHERE p.kornaim=:x3 AND t.ind=0
  ORDER BY io.obozn' USING p_date,p_date,p_date,p_rntv,p_date,p_cex;

END IF;
END;
--*************************************************************
PROCEDURE    p_zag(p_rntv IN NUMBER,
                                             p_rzr IN NUMBER DEFAULT 0,
                                             p_zag OUT curtyp
) AS
                                             BEGIN
IF p_rzr=1 THEN
--Заготовка
OPEN p_zag FOR '
SELECT --+star
CASE vio.kornaim
    WHEN ''М'' THEN
         (SELECT ms.NAME_FULL FROM W_SPRMAT.VW_MAT_SPR_EX_WITH_MAT118 ms WHERE ms.rn = io.RN_MAT)
    ELSE
         ios.OBOZN
  END AS OBOZN,
  ios.obozn as oboznio,
  vio.naim AS VID_NAIM,
  vio.kornaim as kvid,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''свой''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
  tz.NORMRASH,
  tz.KOLDETZAG,
  tz.VESZAG,
  tz.GEOMR_DL,
  tz.GEOMR_SH,
  ei.kornaim,
  tz.VIDZAG || case when vz.naim_vid is not null then '' ('' || vz.naim_vid || '')'' end AS VIDZAG_NAME,
  tz.TZAGNOTE,
  tv.rn as rntv_z,
  w_mmkt.F_GET_MO_TO_STR(1,NULL,tz.RN_TV) as MO
FROM
     w_ktsg.v1_t_zag_s tz
     JOIN w_ktsg.v0_isp_ob_s ios ON tz.RN_ISPOB_ZAG=ios.RN_ISPOB
     left join w_ktsg.v_tv tv on tz.rn_ispob_zag=tv.rn_ispob
     JOIN w_ktsg.v_isp_ob io ON io.rn=tz.RN_ISPOB_ZAG
     JOIN w_ktsg.v_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
     LEFT JOIN W_VIDZAG.TB_VID_ZAG vz ON vz.id_vid=tz.VIDZAG
     JOIN w_ei.tb_ei  ei ON tz.RN_EI=ei.rn
WHERE tz.RN_TV=  :x1'
         USING p_rntv;
END IF;
END;
--*************************************************************
PROCEDURE    p_all(p_rntv IN NUMBER,
                                       p_date IN DATE,
                                             p_tv OUT curtyp,
                                             p_mo OUT curtyp,
                                             p_zag OUT curtyp,
                                             p_obr OUT curtyp,
                                             p_sost OUT curtyp,
                                             p_vhod OUT curtyp,
                                             p_izmtv OUT curtyp,
                                             p_oinfo OUT curtyp) AS

                                             BEGIN
w_ktsg.pk_values.set_curdate(p_date);
w_konfig.pk_values.set_curdate(p_date);
IF p_date=trunc(SYSDATE) THEN -- Материализованное представление
-- Тех вариант
OPEN p_tv FOR sql_tv_mv
         USING p_date,p_rntv;
-- Маршрут
OPEN p_mo FOR sql_mo_mv USING p_rntv;
--Заготовка
OPEN p_zag FOR sql_zag_mv USING p_rntv;
-- Образцы
OPEN p_obr FOR '
SELECT iono.obozn || '' (Вар. изг.'' || tvno.vi || '')'' as OBOZN_TV_OBR,
o.rn_tv_obr,
ionzo.OBOZN || '' (Вар. изг.'' || tvnzo.vi || '')''as obozn_tv_protect,
o.TEHNKOL,
round(o.MAXPART,6) as maxpart,
o.podrisp as podr_isp,
o.podrtd  as podr_inittd,
o.INFOBRNOTE,
m.PORNOM ,
 pd.kornaim || '''' || lower(vo.kornaim) as poz_z,
(SELECT count(*) FROM w_ktsg.mv_poz_mo mmm WHERE mmm.att_arid=mo.att_arid) AS act
FROM w_ktsg.mv_obr o
JOIN w_ktsg.mv_tv tvno  ON o.RN_TV_OBR=tvno.rn
JOIN w_ktsg.mv_isp_ob iono ON tvno.rn_ispob=iono.RN
JOIN w_ktsg.v_poz_mo_s_wa mo ON o.ARID_POZMO=mo.att_arid
JOIN w_mp.tb_podr pd ON mo.rn_podr=pd.rn
JOIN w_vo.tb_vo vo ON mo.rn_vo=vo.rn
JOIN w_ktsg.v_poz_mo m ON mo.rn_pozmo=m.RN
JOIN w_ktsg.v_tv tvnzo ON mo.rn_tv=tvnzo.rn
JOIN w_ktsg.mv_isp_ob ionzo ON ionzo.RN=tvnzo.rn_ispob

WHERE o.RN_TV_IZG= :x1'
         USING p_rntv;

-- Состав
      OPEN p_sost FOR '
SELECT --+star
t.rn_tv,
tvs.rn as RN_TV_CH,
k.obozn,
replace(
case when mod(t.kol,round(t.kol) ) <>0 then
to_char(t.kol,''FM99999990.099999999'')
else
to_char(t.kol)
end
,''.'','','')  || '' '' || replace(ei.kornaim,''ШТ'','''') AS kol,
 tvs.TVNAIM,
 t.rn_pozmo,
 m.rn_podr,
 m. kpodr as kornaim,
decode(NVL(tvs.IND_NALCOMP, ''555''),''0'',''-'',''1'',''+'',''Нет ТВ'') Ind_Has_comp,
case when tvs.rn is null then ''-''
when
(
select --+star
COUNT(1)
from w_mmkt.mv_persogl_tv t
WHERE t.rn_tv=tvs.rn AND t.rn_typedoc=1008)
>0 then ''GC'' else
''ММВ''
end
as Ind_is_tv,
t.ustcompnote,
case when tvs.rn is null then ''Нет ТВ''
else
   f_ismmk(tvs.rn)
end as IND_MMK,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=tvs.rn and p.pornom_tv>=0)>0 then
''ПС''
else
''  ''
end as IND_PS,
ei.kornaim AS eikor
FROM
w_ktsg.mv_ust_comp t
LEFT JOIN w_ktsg.mv_tv tvs ON t.RN_ISPOB_CH=tvs.RN_ISPOB
JOIN w_ktsg.mv_isp_ob k ON k.rn=t.rn_ispob_ch
JOIN w_ei.tb_ei ei ON t.rn_ei_ust=ei.rn
/*LEFT*/ JOIN w_ktsg.mv_Poz_MO m ON m.rn=t.rn_pozmo
WHERE t.rn_tv = :x1
order by f_get_tv_spr(k.kornaim,k.tip_ispob,tvs.ind_nalcomp),k.obozn'
         USING p_rntv;
-- Входимость
OPEN p_vhod FOR '
SELECT --+star
tv_ch.rn AS RN_TV_CH,
cs.RN_TV AS RN_TV_KUDA,
cs.VI,
cs.TVNAIM,
ios.OBOZN || '' (Вар. изг. '' || cs.vi || '')'' as obozn,
vio.naim AS VID_NAIM,
/*CASE vio.kornaim
    WHEN ''М'' THEN (SELECT ms.NAME_FULL FROM W_SPRMAT.VW_MAT_SPR_EX_WITH_MAT118 ms WHERE ms.rn = ios.RN_MAT)
    ELSE ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')''
  END AS OBOZN_KUDA,*/
  ios.OBOZN || '' (Вар. изг. '' || cs.vi || '')'' AS OBOZN_KUDA,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''свой''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
replace(
case when mod(cs.kol,round(cs.kol) ) <>0 then
to_char(cs.kol,''FM99999990.099999999'')
else
to_char(cs.kol)
end
,''.'','','')  || '' '' || replace(ei.kornaim,''ШТ'','''') AS kol,
  nvl(m.kpodr,kp.kornaim) AS podr,
  nvl(m.kvo,kv.kornaim) AS vo
FROM
       w_ktsg.v_tv tv_ch
       JOIN (SELECT tv_k.ind_nalcomp,tv_k.rn_ispob AS rn,tv_k.tvnaim,tv_k.vi,u.rn_tv,u.rn_ispob_ch,u.rn_ei_ust,u.rn_pozmo,u.kol FROM w_ktsg.mv_ust_comp u
                                                                       JOIN w_ktsg.mv_tv tv_k ON u.rn_tv=tv_k.RN
       UNION ALL
             SELECT null,uk.rn_k,       kk.naim,null,   uk.RN_K,uk.RN_CH,uk.RN_ED,uk.RN_POZ_MO,uk.kol FROM w_konfig.v0_ust_comp_s uk 
                                                                                                  JOIN w_konfig.tb_konf kk ON uk.RN_K=kk.rn
             WHERE uk.kol<>0 )             
       cs ON cs.RN_ISPOB_CH=tv_ch.RN_ISPOB
       JOIN w_ei.tb_ei ei ON cs.rn_ei_ust=ei.rn       
       JOIN w_ktsg.mv_isp_ob ios ON cs.RN=ios.RN
       JOIN w_ktsg.v_vid_isp_ob vio ON ios.rn_vid_ispob=vio.rn
       LEFT JOIN w_ktsg.mv_poz_mo m ON m.rn=cs.rn_pozmo
       LEFT JOIN w_konfig.v0_poz_mo_s mk ON mk.RN_POZ_MO=cs.rn_pozmo
       LEFT JOIN w_mp.tb_podr kp ON mk.RN_POD=kp.rn
       LEFT JOIN w_vo.tb_vo kv ON mk.RN_VO=kv.rn
WHERE tv_ch.RN=:x1
order by f_get_tv_spr(vio.kornaim,ios.tip_ispob,cs.ind_nalcomp),ios.obozn' USING p_rntv;
/*'         
SELECT --+star
tv_ch.rn AS RN_TV_CH,
cs.RN_TV AS RN_TV_KUDA,
tv_k.VI,
tv_k.TVNAIM,
ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')'' as obozn,
vio.naim AS VID_NAIM,
\*CASE vio.kornaim
    WHEN ''М'' THEN (SELECT ms.NAME_FULL FROM W_SPRMAT.VW_MAT_SPR_EX_WITH_MAT118 ms WHERE ms.rn = ios.RN_MAT)
    ELSE ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')''
  END AS OBOZN_KUDA,*\
  ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')'' AS OBOZN_KUDA,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''свой''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
replace(
case when mod(cs.kol,round(cs.kol) ) <>0 then
to_char(cs.kol,''FM99999990.099999999'')
else
to_char(cs.kol)
end
,''.'','','')  || '' '' || replace(ei.kornaim,''ШТ'','''') AS kol,
  m.kpodr AS podr,
  m.kvo AS vo
FROM
       w_ktsg.v_tv tv_ch
       JOIN w_ktsg.mv_ust_comp cs ON cs.RN_ISPOB_CH=tv_ch.RN_ISPOB
       JOIN w_ei.tb_ei ei ON cs.rn_ei_ust=ei.rn
       JOIN w_ktsg.mv_tv tv_k ON cs.RN_TV=tv_k.RN
       JOIN w_ktsg.mv_isp_ob ios ON tv_k.RN_ISPOB=ios.RN
       JOIN w_ktsg.v_vid_isp_ob vio ON ios.rn_vid_ispob=vio.rn
       LEFT JOIN w_ktsg.mv_poz_mo m ON m.rn=cs.rn_pozmo
WHERE tv_ch.RN=:x1
order by f_get_tv_spr(vio.kornaim,ios.tip_ispob,tv_k.ind_nalcomp),ios.obozn
'
         USING p_rntv;*/

OPEN p_oinfo FOR
         'SELECT --+star
tv.RN AS rn_tv_izg,
ioizg.OBOZN || '' (Вар.изг. '' || tv.vi || '')''AS obozn_izg,
tvz.RN AS rn_Tv_z,
ioz.OBOZN || '' (Вар.изг. '' ||  tvz.vi || '')'' AS obozn_z,
to_char(round(t.TEHNKOL,2)) ||''/'' || to_char(round(t.MAXPART)) AS kolpart,
t.podrisp AS podri,
t.podrtd AS podrii,
mo.kpodr || '' '' || mo.kvo as poz
FROM w_ktsg.mv_obr t
JOIN w_ktsg.v_tv tv ON t.RN_TV_IZG=tv.RN
JOIN w_ktsg.mv_isp_ob ioizg ON tv.RN_ISPOB=ioizg.RN
JOIN w_ktsg.mv_poz_mo mo ON t.ARID_POZMO=mo.att_ARID
JOIN w_ktsg.v_tv tvz oN mo.RN_TV=tvz.RN
JOIN w_ktsg.mv_isp_ob ioz ON tvz.RN_ISPOB=ioz.RN

WHERE t.RN_TV_OBR=:x1

' USING p_rntv;

ELSE -- ********************  По историческим таблицам
OPEN p_tv FOR sql_tv
         USING p_date,p_rntv;
-- Маршрут
OPEN p_mo FOR sql_mo USING p_rntv;
--Заготовка
OPEN p_zag FOR sql_zag
         USING p_rntv;
-- Образцы
OPEN p_obr FOR '
SELECT iono.obozn || '' (Вар. изг.'' || tvno.vi || '')'' as OBOZN_TV_OBR,
o.rn_tv_obr,
ionzo.OBOZN || '' (Вар. изг.'' || tvnzo.vi || '')''as obozn_tv_protect,o.TEHNKOL,round(o.MAXPART,6) as maxpart,pisp.kornaim as podr_isp,pii.kornaim as podr_inittd,o.INFOBRNOTE,
m.PORNOM,
to_char(pd.kornaim) || '''' || lower(vo.kornaim) as poz_z,
(SELECT count(*) FROM w_ktsg.v0_poz_mo_s mmm WHERE mmm.att_arid=mo.att_arid) AS act
FROM w_ktsg.v0_obr_s o
JOIN w_ktsg.v_tv tvno  ON o.RN_TV_OBR=tvno.rn
JOIN w_ktsg.v0_isp_ob_s iono ON tvno.rn_ispob=iono.RN_ISPOB
JOIN w_ktsg.v_poz_mo_b mo ON o.ARID_POZMO=mo.att_arid and mo.att_arver=0 and mo.att_var=0
JOIN w_mp.tb_podr pd ON mo.rn_podr=pd.rn
JOIN w_vo.tb_vo vo ON mo.rn_vo=vo.rn
JOIN w_ktsg.v_poz_mo m ON mo.rn_pozmo=m.RN
JOIN w_ktsg.v_tv tvnzo ON mo.rn_tv=tvnzo.rn
JOIN w_ktsg.v0_isp_ob_s ionzo ON ionzo.RN_ISPOB=tvnzo.rn_ispob
JOIN w_mp.tb_podr pisp ON o.RN_PODR_ISP=pisp.rn
JOIN w_mp.tb_podr pii ON o.RN_PODR_INITTD=pii.rn

WHERE o.RN_TV_IZG= :x1'
         USING p_rntv;
-- Состав
      OPEN p_sost FOR '
SELECT --+star
t.rn_tv, tv2.rn as RN_TV_CH, k.obozn,
replace(
case when mod(t.kol,round(t.kol) ) <>0 then
to_char(t.kol,''FM99999990.099999999'')
else
to_char(t.kol)
end
,''.'','','')
|| '' '' || replace(ei.kornaim,''ШТ'','''') AS kol,
tvs.TVNAIM, t.rn_pozmo, m.rn_podr,p.kornaim,
decode(NVL(tv2.IND_NALCOMP, ''555''),''0'',''-'',''1'',''+'',''Нет ТВ'') Ind_Has_comp,
case when tv2.rn is null then ''-''
when
(
select --+star
COUNT(1)
from V_PERSOGL_TV_ONLYIZMTV t
WHERE t.rn_tv=tv2.rn AND t.rn_typedoc=1008)
>0 then ''ПС'' else
''ММВ''
end
as Ind_is_tv,
t.ustcompnote,
case when tv2.rn is null then ''Нет ТВ''
else
f_ismmk(tv2.rn)
end as IND_MMK,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=tv2.rn and p.pornom_tv>=0)>0 then
''ПС''
else
''  ''
end as IND_PS,
ei.kornaim AS eikor
FROM
w_ktsg.v0_ust_comp_s t
JOIN w_ei.tb_ei ei ON t.rn_ei_ust=ei.rn
LEFT JOIN (w_ktsg.v_tv  tv2
     JOIN w_ktsg.v0_tv_s tvs ON tv2.RN=tvs.RN_TV
                       )ON t.RN_ISPOB_CH=tv2.RN_ISPOB
JOIN w_ktsg.v0_isp_ob_s k ON k.rn_ispob=t.rn_ispob_ch
join w_ktsg.v_isp_ob io on k.rn_ispob=io.rn
join w_ktsg.v_vid_isp_ob vio on io.rn_vid_ispob=vio.rn

/*LEFT*/ JOIN (w_ktsg.V0_Poz_MO_S m
          JOIN w_mp.tb_podr p ON  p.rn=m.rn_podr
                            )ON m.rn_pozmo=t.rn_pozmo
WHERE t.rn_tv = :x1
order by f_get_tv_spr(vio.kornaim,k.tip_ispob,tv2.ind_nalcomp),k.obozn'
         USING p_rntv;
-- Входимость
OPEN p_vhod FOR '
SELECT --+star
tv_ch.rn AS RN_TV_CH,
cs.RN_TV AS RN_TV_KUDA,
tv_k.VI,
tvs.TVNAIM,
ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')'' as obozn,
vio.naim AS VID_NAIM,
/*CASE vio.kornaim
    WHEN ''М'' THEN (SELECT ms.NAME_FULL FROM W_SPRMAT.VW_MAT_SPR_EX_WITH_MAT118 ms WHERE ms.rn = io.RN_MAT)
    ELSE ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')''
  END AS OBOZN_KUDA,*/
ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')'' AS OBOZN_KUDA,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''свой''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
replace(
case when mod(cs.kol,round(cs.kol) ) <>0 then
to_char(cs.kol,''FM99999990.099999999'')
else
to_char(cs.kol)
end
,''.'','','')  || '' '' || replace(ei.kornaim,''ШТ'','''') AS kol,
  p.kornaim AS podr,
  v.kornaim AS vo

FROM
       w_ktsg.v_tv tv_ch
       JOIN w_ktsg.v0_ust_comp_s cs ON cs.RN_ISPOB_CH=tv_ch.RN_ISPOB
       JOIN w_ei.tb_ei ei ON cs.rn_ei_ust=ei.rn
       JOIN w_ktsg.v_tv tv_k ON cs.RN_TV=tv_k.RN
       JOIN w_ktsg.v0_tv_s tvs ON tv_k.RN=tvs.RN_TV
       JOIN w_ktsg.v0_isp_ob_s ios ON tv_k.RN_ISPOB=ios.RN_ISPOB
       JOIN w_ktsg.v_isp_ob io ON tv_k.RN_ISPOB=io.rn
       JOIN w_ktsg.v_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
       LEFT JOIN (w_ktsg.V0_Poz_MO_S m
            JOIN w_mp.tb_podr p ON  p.rn=m.rn_podr
            JOIN w_vo.tb_vo v ON v.rn=m.RN_PODR
       )ON m.rn_pozmo=cs.rn_pozmo

WHERE tv_ch.RN=:x1
order by f_get_tv_spr(vio.kornaim,ios.tip_ispob,tv_k.ind_nalcomp),ios.obozn
'
         USING p_rntv;
--Образец-информация
OPEN p_oinfo FOR
         'SELECT --+star
tv.RN AS rn_tv_izg,ioizg.OBOZN || '' (Вар.изг. '' || tv.vi || '')''AS obozn_izg,tvz.RN AS rn_Tv_z, ioz.OBOZN || '' (Вар.изг. '' ||  tvz.vi || '')'' AS obozn_z,
to_char(round(t.TEHNKOL,2)) ||''/'' || to_char(round(t.MAXPART)) AS kolpart,
pi.kornaim AS podri,
pii.kornaim AS podrii,
pz.kornaim || '' '' || v.kornaim as poz
FROM w_ktsg.v0_obr_s t
JOIN w_ktsg.v_tv tv ON t.RN_TV_IZG=tv.RN
JOIN w_ktsg.v0_isp_ob_s ioizg ON tv.RN_ISPOB=ioizg.RN_ISPOB
JOIN w_ktsg.v0_poz_mo_s mo ON t.ARID_POZMO=mo.att_ARID
JOIN w_ktsg.v_tv tvz oN mo.RN_TV=tvz.RN
JOIN w_ktsg.v0_isp_ob_s ioz ON tvz.RN_ISPOB=ioz.RN_ISPOB
join w_mp.tb_podr pz on mo.rn_podr = pz.rn
join w_vo.tb_vo v on mo.rn_vo=v.rn
join w_mp.tb_podr pi on t.RN_PODR_ISP=pi.rn
join w_mp.tb_podr pii on t.RN_PODR_INITTD=pii.rn

WHERE t.RN_TV_OBR=:x1' USING p_rntv;
END IF;
--Изменения
/*OPEN p_izmtv FOR '
select --+star
p.NOMIZM,p.RN, p.DT_IZMSTEXIST,
--f_isaudistates(t.rn_persogl,t.rn_tv) as kolstate
case when f_isaudistates(t.rn_persogl,t.rn_tv)>0 then ''+''
else ''-''
end  as kolstate
from mv_persogl_tv t
JOIN w_ktsg.v_per_sogl p ON t.rn_persogl=p.RN
JOIN w_osnov.v_tb_prich pr ON p.RN=pr.RN

 WHERE t.rn_tv=:x1
 ORDER BY p.DT_IZMSTEXIST DESC'
         USING p_rntv;*/
OPEN p_izmtv FOR sql_izm
USING p_rntv,p_date;
END;
--*************************************************************
PROCEDURE    p_info_mo(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_mo OUT curtyp
                         ) AS
BEGIN
w_ktsg.pk_values.set_curdate(p_date);
IF p_date=trunc(SYSDATE) THEN -- Материализованное представление
    -- Маршрут
    OPEN p_mo FOR sql_mo_mv USING p_rntv;
ELSE -- ********************  По историческим таблицам
    -- Маршрут
    OPEN p_mo FOR sql_mo USING p_rntv;
END IF;
END;
--*************************************************************
PROCEDURE    p_info_zag(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_zag OUT curtyp
                         ) AS
BEGIN
w_ktsg.pk_values.set_curdate(p_date);
IF p_date=trunc(SYSDATE) THEN -- Материализованное представление
    -- Заготовка
    OPEN p_zag FOR sql_zag_mv USING p_rntv;
ELSE -- ********************  По историческим таблицам
    -- Заготовка
    OPEN p_zag FOR sql_zag USING p_rntv;
END IF;
END;
--**************************************************************
PROCEDURE    p_info_izm(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_izm OUT curtyp
                         ) AS 
                         
BEGIN
  OPEN p_izm FOR sql_izm
  USING p_rntv,p_date;
END;
PROCEDURE    p_act_td(p_arid IN NUMBER,
                                       p_DATE IN DATE,
                                       p_td out curtyp)
                                       AS
                                       pd DATE;
                                       BEGIN

w_ktsg.pk_values.set_curdate(p_date);
IF p_date =trunc(SYSDATE) THEN
OPEN p_td FOR 'SELECT
  mo.rn_tv,
  td.att_arid AS arid,
  td.arid_pozmo,
  td.tehndob,
  td.tehnkol,
  td.maxpart,
  td.Minpart,
  td.rn_podr_inittd,
  td.podrtd AS podr_inittd,
  td.rn_podr_isp,
  td.podrisp AS podr_isp,
  td.ind_sadka,
  td.tehndobnote,
  F_GET_TEHNDOB_STRING(td.att_arid) AS TEHNDOBSTRING
FROM
  w_ktsg.mv_tehn_dob td,
  w_ktsg.mv_poz_mo mo
WHERE
  td.arid_pozmo = mo.att_ARID
  and ARID_POZMO = :x1
' USING p_arid;
ELSE
OPEN p_td FOR 'select *
     from w_mmkt.v_mmk0_tehn_dob t
     WHERE ARID_POZMO = :x1'
USING p_arid;
END IF;
END;

--**************************************************************
PROCEDURE    p_findizm(p_nomizm IN varchar2,
                                             p_typ IN INTEGER DEFAULT -1, --Тип извещения: -1  - все извещения
                                             p_status IN VARCHAR2 DEFAULT 'РСУН', --Извещения с какими статусами искать - по умолчанию все
                                             p_aut IN VARCHAR2 DEFAULT NULL, -- Автор извещений - по умолчанию все
                                             p_ncompl IN INTEGER DEFAULT 0, -- Необработанные
                                             p_psh out curtyp
                                       ) AS
                                       nomizm varchar2(100);
                                       aut NUMBER;
BEGIN
nomizm:='%' || p_nomizm || '%';
IF p_aut='-1' THEN
   aut:=NULL;
ELSE
    aut:=w_ad.To_Numberguid(p_aut);
END IF;
--Изменения
open p_psh for 'select t.NOMIZM,t.OSNOVANIE,
case
     when instr(subject_of_audit,'' '')=0 then
     subject_of_audit
else
substr(subject_of_audit,
                                       1,

                                       instr(subject_of_audit, '' '')) ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '') + 1,
                                       1) || ''.'' ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '', 1, 2) + 1,
                                       1) || ''.''
                                       end AS SOA,
t.IND_STEXIST,t.DT_IZMSTEXIST,p.SHORTNAME ||'' - '' || p.FULLNAME as TNAME,nvl(t.isp_zadel,-1) as isp_zadel,t.srok_vnedr,
t.psnote,t.rn,
case when (t.rn_typedoc=1008 and t.ind_stexist in (''У'',''Р'')) or (t.rn_typedoc=1010 and t.ind_stexist in (''Н''))then
''1''
else
''0''
end  AS ind_vygr,
p1.dlog,
(select count(distinct t1.rn_tv) from mv_persogl_tv t1 where t1.rn_persogl=t.rn) as cnt_tv,
(select count(distinct t1.rn_ispob) from mv_persogl_tv t1 where t1.rn_persogl=t.rn)as cnt_io,
t.ind_stexist as status

from
w_ktsg.v_per_sogl t
join w_osnov.v_tb_typedoc p on t.rn_typedoc=p.RN
left join w_ad.v_subject_of_audit a on t.RN_SOTR_AVT=a.GUID
LEFT JOIN w_mmkt.tb_ps_bnh p1 ON t.rn=p1.rn
where /*t.ind_stexist in (''У'',''Н'') and*/ t.nomizm  like :x1
and (:x2=-1 or (t.rn_typedoc=:x3) )
and :x4 like ''%'' ||t.ind_stexist || ''%''
and (:x5=0 or ( :x6=1 and p1.dlog is null))
and (:x7 is null or ( :x8=t.rn_sotr_avt ))
' USING nomizm,p_typ,p_typ,p_status,p_ncompl, p_ncompl,aut,aut;
end;
--**************************************************************
PROCEDURE    p_izmdce(p_rnps IN number,
                                       p_dce out curtyp) AS
vDate DATE ;
BEGIN
SELECT t.dt_izmstexist INTO vDate FROM w_ktsg.tb_per_sogl t WHERE t.rn=p_rnps;
IF trunc(vDate,'DD')<>trunc(SYSDATE,'DD') THEN
--Изменения
open p_dce for '
select * from
(
select distinct t.obozn,t1.VI,t1.RN
from
w_ktsg.tb_izm_tv p
JOIN w_ktsg.tb_tv tp ON p.rn_tv=tp.rn
join w_ktsg.v0_isp_ob_s t on t.rn_ispob=tp.rn_ispob
left join w_ktsg.v_tv t1 on p.rn_Tv=t1.RN
where p.rn_persogl=:x1
order by 1,2
)
' USING p_rnps;
ELSE
--Изменения
open p_dce for '
select * from (
select   distinct t.obozn,t1.VI,t1.RN
from
mv_persogl_tv p
join w_ktsg.v0_isp_ob_s t on t.rn_ispob=p.rn_ispob
left join w_ktsg.v_tv t1 on p.rn_Tv=t1.RN
where p.rn_persogl=:x1
order by 1,2)
' USING p_rnps;
END IF;
end;
--**************************************************************
PROCEDURE    p_getpsh(p_rnps in number,
                      p_psh out curtyp) AS
BEGIN
--Изменения
open p_psh for sql_ps USING p_rnps;
end;
--**************************************************************
PROCEDURE    p_izmdata(p_rntv IN NUMBER,
                                       p_rnps IN NUMBER,
                                       p_psh out curtyp,
                                       p_tv out curtyp,
                                       p_mo OUT curtyp,
                                       p_zag OUT curtyp,
                                       p_obr OUT curtyp,
                                       p_sost OUT curtyp,
                                       p_vhod OUT curtyp,
                                       p_isp OUT curtyp,
                                       p_td OUT curtyp) AS
vVar NUMBER;
ssE CHAR(1);
BEGIN
SELECT MAX(t.att_var) INTO vVar FROM w_ktsg.v_audi t WHERE t.att_auth=p_rnps;
vVar:=nvl(vVar,0);
SELECT MAX(t.ind_stexist) INTO ssE FROM w_ktsg.tb_per_sogl t WHERE t.rn=p_rnps;
--Изменения
open p_psh for sql_ps USING p_rnps;
--Технологический вариант
open p_tv for
'
SELECT * FROM (
SELECT a.*,   count(*) over (PARTITION BY doly_p,tvnaim_p,tvmassa_p,tvnote_p) AS cnt
FROM
(
SELECT ''Было'' as state,
                 t.t_start,
                 t.t_end,
                 t.tv_doly_b as doly_p,
                 t.tv_naim_b as tvnaim_p,
                 t.tv_massa_b as tvmassa_p,
                 t.tv_note_b as tvnote_p,
                 t.att_auth
       FROM
TABLE( cast (pk_mmk_izms.F_TV(:x1,:x2) as T_TB_IZMS_TV)) t
union all
SELECT ''Стало'' as state,
                 t.t_start,
                 t.t_end,
                 t.tv_doly_s as doly_p,
                 t.tv_naim_s as tvnaim_p,
                 t.tv_massa_s as tvmassa_p,
                 t.tv_note_s as tvnote_p,
                 t.att_auth
       FROM
TABLE(cast(pk_mmk_izms.F_TV(:x3,:x4) as T_TB_IZMS_TV)) t
)a
) WHERE cnt<2
                  order by 1
                  ' using p_rntv,p_rnps,p_rntv,p_rnps;


-- Маршрут
OPEN p_mo FOR '
SELECT
t.dizm,
t.pornom,
pb.rn AS rn_podr_b,
pb.kornaim AS kornaim_b,
vb.kornaim AS korv_b,
ps.kornaim AS kornaim_s,
vs.kornaim AS korv_s,
ps.rn AS rn_podr_s,
pb.kornaim || vb.kornaim as mo_b,
ps.kornaim || vs.kornaim as mo_s,
vnb.NAIM || '' ('' || vb.kornaim || '')''  AS VONAIM_b,
vns.NAIM || '' ('' || vs.kornaim || '')''  AS VONAIM_s,
t.pozmonote_b,
t.pozmonote_s,
t.ARIDMO_B,
t.ARIDMO_S
FROM
TABLE(pk_mmk_izms.F_MO_TV(:x1,:x2 )) t,
--TABLE(pk_mmk_izms.F_MO( :x1,:x2 )) t,
w_mp.tb_podr pb,
w_mp.tb_podr ps,
w_vo.tb_vo vb,
w_vo.tb_vo vs,
w_vo.tb_vo_naim  vnb,
w_vo.tb_vo_naim vns
WHERE
      t.rnpodr_b = pb.rn(+) AND
      t.rnpodr_s = ps.rn(+) AND
      vb.rn(+) = t.rnvo_b AND
      vs.rn(+) = t.rnvo_s and
      vnb.rn(+)=vb.rn and
      vns.rn(+)=vs.rn

ORDER BY t.dizm, pornom'
         USING p_rnps,p_rntv;

IF ssE IN('У','Н') THEN
open p_zag for  'SELECT t.t_start AS dizm,
                        rn_ei_b,
                        rn_ei_s,
                        eb.kornaim AS ei_b,
                        es.kornaim AS ei_s,
                        t.normrash_b,
                        t.normrash_s,
                        t.veszag_b,
                        t.veszag_s,
                        t.koldetzag_b,
                        t.koldetzag_s,
                        t.geomr_sh_s,
                        t.geomr_sh_b,
                        t.geomr_dl_s,
                        t.geomr_dl_b,
                        t.tzagnote_b,
                        t.tzagnote_s,
                        t.vidzag_b,
                        t.vidzag_s,
                        --vb.NAIM AS vbn,
                        --vs.naim AS vsn,
                        vzb.naim_vid AS vzb,
                        vzs.naim_vid AS vzs,
                        t.VIDZAG_b || case when vzb.naim_vid is not null then '' ('' || vzb.naim_vid || '')'' end AS VIDZAG_NAME_B,
                        t.VIDZAG_s || case when vzs.naim_vid is not null then '' ('' || vzs.naim_vid || '')'' end AS VIDZAG_NAME_S,
                        iob.obozn as obozn_b,
                        ios.obozn as obozn_s,
                        (select rn from w_ktsg.v_tv tvb where tvb.rn_ispob=t.rn_ispob_zag_b and rownum<2) as rntv_b,
                        (select rn from w_ktsg.v_tv tvs where tvs.rn_ispob=t.rn_ispob_zag_s and rownum<2) as rntv_s
                   FROM
                        --TABLE(pk_report2.F_GET_IZM_tzag(:x1, :x2)) t
                        table(pk_mmk_izms.f_zag(:x1, :x2) )t
                   left join  w_ei.tb_ei eb on t.rn_ei_b = eb.rn
                   left join  w_ei.tb_ei es on t.rn_ei_s = es.rn
--                   left join  w_ktsg.tb_vid_isp_ob vb on t.rn_vid_ispob_b = vb.rn
--                   left join  w_ktsg.tb_vid_isp_ob vs on t.rn_vid_ispob_s = vs.rn
                   left join w_vidzag.tb_vid_zag vzb on t.vidzag_b = vzb.id_vid
                   left join w_vidzag.tb_vid_zag vzs on t.vidzag_s = vzs.id_vid


                   left join (w_ktsg.v_isp_ob_s_wa  iob

                   join w_ktsg.v_audi ab on   iob.att_arid=ab.att_arid AND
                    ab.att_var=0 and ab.att_arver=0) on iob.rn_ispob=t.rn_ispob_zag_b
                    and t.t_start<ab.att_arend
                    and t.t_start>=ab.att_arstart

                  left join  (w_ktsg.v_isp_ob_s_wa  ios
                  join w_ktsg.v_audi as1 on
                        ios.att_arid=as1.att_arid and
                         as1.att_var=0 and as1.att_arver=0) on ios.rn_ispob=t.rn_ispob_zag_s
                    and t.t_start<as1.att_arend
                    and t.t_start>=as1.att_arstart
              WHERE (rn_ei_b<>rn_ei_s) OR (normrash_b<>normrash_s) OR ( nvl(veszag_b,-1)<>nvl(veszag_s,-1) ) OR ( nvl(koldetzag_b,-1)<>nvl(koldetzag_s,-1) )
                  OR ( nvl(geomr_sh_b,-1)<>nvl(geomr_sh_s,-1) )  OR ( nvl(geomr_dl_b,-1)<>nvl(geomr_dl_s,-1) ) OR ( nvl(tzagnote_b,''@NULL'')<>nvl(tzagnote_s,''@NULL'') )
                  OR ( nvl(rn_ispob_zag_b,-1)<>nvl(rn_ispob_zag_s,-1) ) OR ( nvl(vidzag_b,''@NULL'')<>nvl(vidzag_s,''@NULL'') )
'
                    USING p_rntv,p_rnps;
    ELSE
open p_zag for
'SELECT                  t.t_start AS dizm,
                        nvl(ei.rn,null) AS rn_ei_b,
                        rn_ei_s,
                        ei.kornaim AS ei_b,
                        es.kornaim AS ei_s,
                        nvl(zz.normrash,null)as  normrash_b,
                        t.normrash_s,
                        zz.veszag veszag_b,
                        t.veszag_s,
                        zz.koldetzag koldetzag_b,
                        t.koldetzag_s,
                        t.geomr_sh_s,
                        zz.geomr_sh geomr_sh_b,
                        t.geomr_dl_s,
                        zz.geomr_dl geomr_dl_b,
                        zz.tzagnote tzagnote_b,
                        t.tzagnote_s,
                        zz.vidzag vidzag_b,
                        t.vidzag_s,
                        --vb.NAIM AS vbn,
                        --vs.naim AS vsn,
                        vzbz.naim_vid AS vzb,
                        vzs.naim_vid AS vzs,
                        zz.vidzag  || case when vzbz.naim_vid is not null then '' ('' || vzbz.naim_vid || '')'' end AS VIDZAG_NAME_B,
                        t.VIDZAG_s || case when vzs.naim_vid  is not null then '' ('' || vzs.naim_vid  || '')'' end AS VIDZAG_NAME_S,
                        io.obozn as obozn_b,
                        ios.obozn as obozn_s,
                        (select rn from w_ktsg.v_tv tvb where tvb.rn_ispob=zz.RN_ISPOB_ZAG and rownum<2) as rntv_b,
                        (select rn from w_ktsg.v_tv tvs where tvs.rn_ispob=t.rn_ispob_zag_s and rownum<2) as rntv_s
                   FROM
                        --TABLE(pk_report2.F_GET_IZM_tzag(:x1, :x2)) t
                        table(pk_mmk_izms.f_zag(:x1, :x2) )t
                   left join  w_ei.tb_ei eb on t.rn_ei_b = eb.rn
                   left join  w_ei.tb_ei es on t.rn_ei_s = es.rn
--                   left join  w_ktsg.tb_vid_isp_ob vb on t.rn_vid_ispob_b = vb.rn
--                   left join  w_ktsg.tb_vid_isp_ob vs on t.rn_vid_ispob_s = vs.rn
                   left join w_vidzag.tb_vid_zag vzb on t.vidzag_b = vzb.id_vid
                   left join w_vidzag.tb_vid_zag vzs on t.vidzag_s = vzs.id_vid


                   left join (w_ktsg.v_isp_ob_s_wa  iob

                   join w_ktsg.v_audi ab on   iob.att_arid=ab.att_arid AND
                    ab.att_var=0 and ab.att_arver=0) on iob.rn_ispob=t.rn_ispob_zag_b
                    and t.t_start<ab.att_arend
                    and t.t_start>=ab.att_arstart

                  left join  (w_ktsg.v_isp_ob_s_wa  ios
                  join w_ktsg.v_audi as1 on
                        ios.att_arid=as1.att_arid and
                         as1.att_var=0 and as1.att_arver=0) on ios.rn_ispob= t.rn_ispob_zag_s
                    and t.t_start<as1.att_arend
                    and t.t_start>=as1.att_arstart
                  LEFT JOIN w_ktsg.v0_t_zag_s zz ON t.rn_tv=zz.rn_tv
                   left join w_ei.tb_ei ei on zz.RN_EI = ei.rn
                   left join w_vidzag.tb_vid_zag vzbz on zz.RN_VID_ISPOB_ZAG = vzbz.id_vid
                   left join (w_ktsg.v_isp_ob_s_wa  io
                   join w_ktsg.v_audi a on   io.att_arid=a.att_arid AND
                    a.att_var=0 and a.att_arver=0) on io.rn_ispob=zz.RN_ISPOB_ZAG
                    and t.t_start<a.att_arend
                    and t.t_start>=a.att_arstart
              WHERE (ei.rn<>rn_ei_s) OR (zz.normrash<>normrash_s) OR ( nvl(zz.veszag,-1)<>nvl(veszag_s,-1) ) OR ( nvl(zz.koldetzag,-1)<>nvl(koldetzag_s,-1) )
                  OR ( nvl(zz.geomr_sh,-1)<>nvl(geomr_sh_s,-1) )  OR ( nvl(zz.geomr_dl,-1)<>nvl(geomr_dl_s,-1) ) OR ( nvl(zz.tzagnote,''@NULL'')<>nvl(tzagnote_s,''@NULL''))
                  OR ( nvl(zz.RN_ISPOB_ZAG,-1)<>nvl(rn_ispob_zag_s,-1) ) OR ( nvl(zz.vidzag,''@NULL'')<>nvl(vidzag_s,''@NULL'') )
    ' USING p_rntv,p_rnps;
    END IF ;
/* 'SELECT t.dizm,
                        rn_ei_b,
                        rn_ei_s,
                        eb.kornaim AS ei_b,
                        es.kornaim AS ei_s,
                        t.normrash_b,
                        t.normrash_s,
                        t.veszag_b,
                        t.veszag_s,
                        t.koldetzag_b,
                        t.koldetzag_s,
                        t.geomr_sh_s,
                        t.geomr_sh_b,
                        t.geomr_dl_s,
                        t.geomr_dl_b,
                        t.tzagnote_b,
                        t.tzagnote_s,
                        t.rnispob_b,
                        t.rnispob_s,
                        t.vidzag_b,
                        t.vidzag_s,
                        vb.NAIM AS vbn,
                        vs.naim AS vsn,
                        vzb.naim_vid AS vzb,
                        vzs.naim_vid AS vzs,
                        iob.obozn as obozn_b,
                        ios.obozn as obozn_s,
                        t.VIDZAG_b || case when vzb.naim_vid is not null then '' ('' || vzb.naim_vid || '')'' end AS VIDZAG_NAME_B,
                        t.VIDZAG_s || case when vzs.naim_vid is not null then '' ('' || vzs.naim_vid || '')'' end AS VIDZAG_NAME_S,
                        to_number(tvb.rn) as rntv_b,
                        to_number(tvs.rn) as rntv_s
                   FROM TABLE(pk_report2.F_GET_IZM_tzag(:x1, :x2)) t
                   left join  w_ei.tb_ei eb on t.rn_ei_b = eb.rn
                   left join  w_ei.tb_ei es on t.rn_ei_s = es.rn
                   left join  w_ktsg.tb_vid_isp_ob vb on t.rn_vid_ispob_b = vb.rn
                   left join  w_ktsg.tb_vid_isp_ob vs on t.rn_vid_ispob_s = vs.rn
                   left join w_vidzag.tb_vid_zag vzb on t.vidzag_b = vzb.id_vid
                   left join w_vidzag.tb_vid_zag vzs on t.vidzag_s = vzs.id_vid
                   left join w_ktsg.v_isp_ob_s_wa  iob on iob.rn_ispob=t.rnispob_b
                   LEFT join w_ktsg.v_audi ab on   iob.att_arid=ab.att_arid AND
                    ab.att_var=0 and ab.att_arver=0
                    and t.dizm<ab.att_arend
                    and t.dizm>=ab.att_arstart
                   left join w_ktsg.v_tv tvb on t.rnispob_b=tvb.rn_ispob
                  left join  w_ktsg.v_isp_ob_s_wa  ios  on ios.rn_ispob=t.rnispob_s
                  LEFT join w_ktsg.v_audi as1 on
                        ios.att_arid=as1.att_arid and
                         as1.att_var=0 and as1.att_arver=0
                    and t.dizm<as1.att_arend
                    and t.dizm>=as1.att_arstart
                    left join w_ktsg.v_tv tvs on t.rnispob_s=tvs.rn_ispob

                  ORDER BY t.dizm'  USING p_rnps,p_rntv;
*/
open p_obr FOR '
SELECT p2.*
                    FROM (SELECT t.*,

                                 piip.kornaim AS koriip,
                                 piin.kornaim AS koriin,
                                 pip.kornaim  AS korip,
                                 pin.kornaim  AS korin,
                                 zmo.kornaim  AS zpodr,
                                 zvo.kornaim  AS zvo,
                                 ob.obozn || '' (Вар. изг. '' || tv1.vi || '')''  AS ObrObozn,
                                 tv1.vi       AS ObrVI,
                                 obp.obozn  || '' (Вар. изг. '' || sip.vi || '')''  AS soboznp,
                                 sip.vi       AS vip
                            FROM (SELECT
                                  --v2.0.20060831
                                  --Показывает модификации,
                                  -- внесенные актуальными изменениями таблицы TB_OBR_S
                                   rn_tv_za,
                                   RN_TV_OBR,
                                   ARID_POZMO,
                                   NULL AS T_ACTUAL,
                                   NULL AS T_VAR,
                                   NULL AS T_DIS,
                                   dizm AS T_CorDate,
                                   T_Start AS dizm,
                                   T_End,
                                   --att_ALT,
                                   att_ALTTYPE,
                                   att_AUTH,
                                   att_AUTHTYPE,
                                   rn_podr,
                                   rn_vo,
                                   RN_TV_IZG,
                                   RN_PODR_ISP_B AS RN_PODR_ISP_P,
                                   RN_PODR_ISP_S AS RN_PODR_ISP_N,
                                   RN_PODR_INITTD_B AS RN_PODR_INITTD_P,
                                   RN_PODR_INITTD_S AS RN_PODR_INITTD_N,
                                   TEHNKOL_B AS TEHNKOL_P,
                                   TEHNKOL_S AS TEHNKOL_N,
                                   MAXPART_B AS MAXPART_P,
                                   MAXPART_S AS MAXPART_N,
                                   INFOBRNOTE_B AS INFOBRNOTE_P,
                                   INFOBRNOTE_S AS INFOBRNOTE_N
                                    FROM
                              table(CAST (pk_mmk_izms.f_obr(:x1, :x2) AS t_tb_izms_obr) )
                              )t
                           INNER JOIN(w_ktsg.tb_tv sip
                           INNER JOIN w_ktsg.tb_isp_ob_s obp ON sip.rn_ispob =
                                                                obp.rn_ispob
                           INNER JOIN w_ktsg.tb_audi ap ON obp.att_arid =
                                                           ap.att_arid
                                                       AND ap.att_arver = 0
                                                       AND ap.att_var = 0) ON t.RN_TV_ZA = sip.rn AND t.dizm < ap.att_arend AND t.dizm >= ap.att_arstart
                            LEFT JOIN w_mp.tb_podr pin ON t.RN_PODR_ISP_N =
                                                          pin.rn
                            LEFT JOIN w_mp.tb_podr pip ON t.RN_PODR_ISP_P =
                                                          pip.rn
                            LEFT JOIN w_mp.tb_podr piin ON t.RN_PODR_INITTD_N =
                                                           piin.rn
                            LEFT JOIN w_mp.tb_podr piip ON t.RN_PODR_INITTD_P =
                                                           piip.rn,
                           w_mp.tb_podr zmo,
                           w_vo.tb_vo zvo,
                           w_ktsg.tb_tv tv1,
                           w_ktsg.tb_isp_ob_s ob,
                           w_ktsg.tb_audi a

                           WHERE
                             t.RN_TV_OBR = tv1.rn
                             AND tv1.rn_ispob = ob.rn_ispob
                             AND ob.att_arid = a.att_arid
                             AND a.att_arver = 0
                             AND a.att_var = 0
                             AND t.dizm < a.att_arend
                             AND t.dizm >= a.att_arstart

                             AND zmo.rn = t.rn_podr
                             AND zvo.rn = t.rn_vo) p2

                  --Убираем переподвязку

                   ORDER BY dizm,
                            nvl2(RN_PODR_ISP_P, -1, 1),
                            nvl2(RN_PODR_ISP_N, 1, -1),
                            obrobozn
' USING p_rntv,p_rnps;

OPEN p_sost FOR 'SELECT p2.*,
                         tva.rn AS rntv1
                    FROM (SELECT p.*,
                                 eip.kornaim AS eib,
                                 ein.kornaim AS eis,
                                 io.obozn,
                                 mpr.kornaim AS zex,
                                 vov.kornaim AS vo,
                                 mpr2.kornaim AS zex2,
                                 vov2.kornaim AS vo2,
                                 io.rn_ispob
                            FROM (SELECT
                                  --v2.0.20060831
                                  --Показывает модификации,
                                  -- внесенные актуальными изменениями таблицы TB_UST_COMP_S
                                   RN_POZMO,
                                   RN_ISPOB_CH,
                                   dizm,
                                   t_start,
                                   T_End,
                                   att_ALT,
                                   att_ALTTYPE,
                                   att_AUTH,
                                   att_AUTHTYPE,
                                   RN_TV,
                                   kol_s KOL_N,
                                   KOL_b AS kol_p,
                                   IND1_VARIANT_s AS IND1_VARIANT_N,
                                   IND1_VARIANT_b AS IND1_VARIANT_P,
                                   IND2_NEUST_s AS IND2_NEUST_N,
                                   IND2_NEUST_b AS IND2_NEUST_P,
                                   USTCOMPNOTE_s AS USTCOMPNOTE_N,
                                   USTCOMPNOTE_b AS USTCOMPNOTE_P,
                                   rn_ei_ust_s AS RN_EI_UST_N,
                                   RN_EI_UST_b AS RN_EI_UST_P
                                    --FROM w_ktsg.V_UST_COMP_S_HISTORY t
                                    FROM TABLE(CAST (pk_mmk_izms.F_SOSTAV(:x1,:x2) AS T_TB_IZMS_UST) )
                                    ) p
                            LEFT JOIN(w_ktsg.tb_isp_ob_s io
                           INNER JOIN w_ktsg.tb_audi a ON io.att_arid =
                                                          a.att_arid
                                                      AND a.att_arver = 0
                                                      AND a.att_var = CASE WHEN :x3=0 THEN 0 ELSE
                                                      w_ktsg.f_get_maxv1_ISP_OB(io.RN_ISPOB)
                                                      END  ) ON (p.rn_ispob_ch = io.rn_ispob) AND
                                                      p.dizm < a.att_arend AND dizm >= a.att_arstart
                            LEFT JOIN w_ei.tb_ei eip ON p.RN_EI_UST_P =
                                                        eip.rn
                            LEFT JOIN w_ei.tb_ei ein ON p.RN_EI_UST_N =
                                                        ein.rn
                            LEFT JOIN(w_ktsg.v_poz_mo_s_wa mo
                           INNER JOIN w_mp.tb_podr mpr ON mo.RN_PODR = mpr.rn
                           INNER JOIN w_vo.tb_vo vov ON mo.RN_VO = vov.rn
                           INNER JOIN w_ktsg.tb_audi aa ON mo.att_arid =
                                                           aa.att_arid
                                                       AND aa.att_arver = 0
                                                       AND aa.att_var = CASE WHEN :x4=0 THEN 0 ELSE
                                                       --w_ktsg.f_get_maxv1_pozmo_s(mo.RN_pozmo)
                                                       w_ktsg.f_get_maxv1_pozmo_sd(mo.RN_pozmo,f_get_min_dstart(:x5) - 0.0000058)
                                                       END  ) ON p.rn_pozmo = mo.RN_POZMO AND
                                                       --p.dizm < aa.att_arend AND p.dizm >= aa.att_arstart
                                                       f_get_min_dstart(p.att_auth )  - 0.0000058< aa.att_arend AND f_get_min_dstart(p.att_auth )  - 0.0000058  >= aa.att_arstart
                            LEFT JOIN(w_ktsg.v_poz_mo_s_wa mo2
                           INNER JOIN w_mp.tb_podr mpr2 ON mo2.RN_PODR =
                                                           mpr2.rn
                           INNER JOIN w_vo.tb_vo vov2 ON mo2.RN_VO = vov2.rn
                           INNER JOIN w_ktsg.tb_audi aa2 ON mo2.att_arid =
                                                            aa2.att_arid
                                                        AND aa2.att_arver = 0
                                                        AND aa2.att_var =  CASE WHEN :x6=0 THEN 0 ELSE
                                                        --w_ktsg.f_get_maxv1_pozmo_s(mo2.RN_pozmo)
                                                        w_ktsg.f_get_maxv1_pozmo_sd(mo2.RN_pozmo,f_get_max_dstart(:x7))
                                                         END
                                                        ) ON p.rn_pozmo = mo2.RN_POZMO AND
                                                        --p.dizm < aa2.att_arend AND p.dizm >= aa2.att_arstart
                                                        f_get_max_dstart(p.att_auth )  < aa2.att_arend AND f_get_max_dstart(p.att_auth ) >= aa2.att_arstart
                           ) p2
                    LEFT JOIN w_ktsg.tb_tv tva ON p2.rn_ispob = tva.rn_ispob
                   --отключение неизмененных
                  WHERE ( nvl(kol_p,-1) <> nvl(kol_n,-1) OR nvl(IND1_VARIANT_P,''@NULL'')<>nvl(IND1_VARIANT_N,''@NULL'') OR nvl(IND2_NEUST_P,''@NULL'')<>nvl(IND2_NEUST_N,''@NULL'') OR
                      nvl(ustcompnote_p,''@NULL'')<>nvl(ustcompnote_n,''@NULL'') OR nvl(eib,''@NULL'')<>nvl(eis,''@NULL'')
                      )
                   ORDER BY dizm,
                            nvl2(kol_p, -1, 1),
                            nvl2(kol_n, 1, -1),
                            obozn' USING p_rntv,p_rnps,vVar,vVar,p_rnps,vVar,p_rnps;--,p_rntv,p_rnps,p_rntv,p_rnps;
OPEN p_vhod FOR
'SELECT p.*,
                                 eip.kornaim AS eib,
                                 ein.kornaim AS eis,
                                 io.obozn,
                                 mpr.kornaim AS zex,
                                 vov.kornaim AS vo,
                                 mpr2.kornaim AS zex2,
                                 vov2.kornaim AS vo2,
                                 io.rn_ispob
                            FROM (SELECT
                                  --v2.0.20060831
                                  --Показывает модификации,
                                  -- внесенные актуальными изменениями таблицы TB_UST_COMP_S
                                   RN_POZMO,
                                   RN_ISPOB_CH,
                                   dizm,
                                   t_start,
                                   T_End,
                                   att_ALT,
                                   att_ALTTYPE,
                                   att_AUTH,
                                   att_AUTHTYPE,
                                   RN_TV,
                                   kol_s KOL_N,
                                   KOL_b AS kol_p,
                                   IND1_VARIANT_s AS IND1_VARIANT_N,
                                   IND1_VARIANT_b AS IND1_VARIANT_P,
                                   IND2_NEUST_s AS IND2_NEUST_N,
                                   IND2_NEUST_b AS IND2_NEUST_P,
                                   USTCOMPNOTE_s AS USTCOMPNOTE_N,
                                   USTCOMPNOTE_b AS USTCOMPNOTE_P,
                                   rn_ei_ust_s AS RN_EI_UST_N,
                                   RN_EI_UST_b AS RN_EI_UST_P
FROM TABLE(CAST (pk_mmk_izms.F_VHODIM_UST(:x1,:x2) AS T_TB_IZMS_UST) ) )p
                            LEFT JOIN w_ktsg.tb_tv tv ON p.rn_tv=tv.rn
                            LEFT JOIN(w_ktsg.tb_isp_ob_s io
                           INNER JOIN w_ktsg.tb_audi a ON io.att_arid =
                                                          a.att_arid
                                                      AND a.att_arver = 0
                                                      AND a.att_var = CASE WHEN :x3=0 THEN 0 ELSE
                                                      w_ktsg.f_get_maxv1_ISP_OB(io.RN_ISPOB)
                                                      END  ) ON (tv.rn_ispob = io.rn_ispob) AND
                                                      p.dizm < a.att_arend AND dizm >= a.att_arstart
                            LEFT JOIN w_ei.tb_ei eip ON p.RN_EI_UST_P =
                                                        eip.rn
                            LEFT JOIN w_ei.tb_ei ein ON p.RN_EI_UST_N =
                                                        ein.rn
                            LEFT JOIN(w_ktsg.v_poz_mo_s_wa mo
                           INNER JOIN w_mp.tb_podr mpr ON mo.RN_PODR = mpr.rn
                           INNER JOIN w_vo.tb_vo vov ON mo.RN_VO = vov.rn
                           INNER JOIN w_ktsg.tb_audi aa ON mo.att_arid =
                                                           aa.att_arid
                                                       AND aa.att_arver = 0
                                                       AND aa.att_var = CASE WHEN :x4=0 THEN 0 ELSE
                                                       --w_ktsg.f_get_maxv1_pozmo_s(mo.RN_pozmo)
                                                       w_ktsg.f_get_maxv1_pozmo_sd(mo.RN_pozmo,f_get_min_dstart(:x5) - 0.0000058)
                                                       END  ) ON p.rn_pozmo = mo.RN_POZMO AND
                                                       --p.dizm < aa.att_arend AND p.dizm >= aa.att_arstart
                                                       f_get_min_dstart(p.att_auth )  - 0.0000058< aa.att_arend AND f_get_min_dstart(p.att_auth )  - 0.0000058  >= aa.att_arstart
                            LEFT JOIN(w_ktsg.v_poz_mo_s_wa mo2
                           INNER JOIN w_mp.tb_podr mpr2 ON mo2.RN_PODR =
                                                           mpr2.rn
                           INNER JOIN w_vo.tb_vo vov2 ON mo2.RN_VO = vov2.rn
                           INNER JOIN w_ktsg.tb_audi aa2 ON mo2.att_arid =
                                                            aa2.att_arid
                                                        AND aa2.att_arver = 0
                                                        AND aa2.att_var =  CASE WHEN :x6=0 THEN 0 ELSE
                                                        --w_ktsg.f_get_maxv1_pozmo_s(mo2.RN_pozmo)
                                                        w_ktsg.f_get_maxv1_pozmo_sd(mo2.RN_pozmo,f_get_max_dstart(:x7))
                                                         END
                                                        ) ON p.rn_pozmo = mo2.RN_POZMO AND
                                                        --p.dizm < aa2.att_arend AND p.dizm >= aa2.att_arstart
                                                        f_get_max_dstart(p.att_auth )  < aa2.att_arend AND f_get_max_dstart(p.att_auth ) >= aa2.att_arstart
WHERE ( nvl(kol_p,-1) <> nvl(kol_n,-1) OR nvl(IND1_VARIANT_P,''@NULL'')<>nvl(IND1_VARIANT_N,''@NULL'') OR nvl(IND2_NEUST_P,''@NULL'')<>nvl(IND2_NEUST_N,''@NULL'') OR
                      nvl(ustcompnote_p,''@NULL'')<>nvl(ustcompnote_n,''@NULL'') OR nvl(eip.kornaim,''@NULL'')<>nvl(ein.kornaim,''@NULL'')
)        ORDER BY dizm,
                            nvl2(kol_p, -1, 1),
                            nvl2(kol_n, 1, -1),
                            obozn' USING f_get_isp(p_rntv),p_rnps,vVar,vVar,p_rnps,vVar,p_rnps;

OPEN p_isp FOR'
SELECT * FROM (
SELECT z.*,count(*) over (PARTITION BY obozn_p,tip_ispob_p,PACK_OBOZN_P) AS cnt FROM
(SELECT ''Было'' AS state,rn_ispob,dizm,att_auth,obozn_p,tip_ispob_p,PACK_OBOZN_P,obozn_n,tip_ispob_n,PACK_OBOZN_n FROM 
(SELECT t.* FROM (select
--v2.0.20060831
--Показывает модификации,
-- внесенные актуальными изменениями таблицы TB_ISP_OB_S
       RN_ISPOB,
--       T_ACTUAL,
--       T_VAR,
--       T_DIS,
--       T_CorDate,
       T_Start AS dizm,
--       T_End,
--       att_ALT,
--       att_ALTTYPE,
       att_AUTH,
--       att_AUTHTYPE,
--       att_ARID,
--       OBJTYPE,
       NVL2(T_DIS,null,OBOZN) as "OBOZN_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,OBOZN)) OVER(partition by RN_ISPOB order by T_Start)
       end as "OBOZN_P",
       NVL2(T_DIS,null,TIP_ISPOB) as "TIP_ISPOB_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,TIP_ISPOB)) OVER(partition by RN_ISPOB order by T_Start)
       end as "TIP_ISPOB_P",
       NVL2(T_DIS,null,PACK_OBOZN) as "PACK_OBOZN_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,PACK_OBOZN)) OVER(partition by RN_ISPOB order by T_Start)
       end as "PACK_OBOZN_P"
from w_ktsg.V_ISP_OB_S_HISTORY
 WHERE rn_ispob = :x1) t
                  WHERE t.att_auth = :x2
                  ORDER BY t.dizm) WHERE ROWNUM <2
UNION ALL
SELECT ''Стало'',rn_ispob,dizm,att_auth,obozn_n,tip_ispob_n,PACK_OBOZN_n,obozn_n,tip_ispob_n,PACK_OBOZN_n FROM 
(SELECT t.* FROM (select
--v2.0.20060831
--Показывает модификации,
-- внесенные актуальными изменениями таблицы TB_ISP_OB_S
       RN_ISPOB,
--       T_ACTUAL,
--       T_VAR,
--       T_DIS,
--       T_CorDate,
       T_Start AS dizm,
--       T_End,
--       att_ALT,
--       att_ALTTYPE,
       att_AUTH,
--       att_AUTHTYPE,
--       att_ARID,
--       OBJTYPE,
       NVL2(T_DIS,null,OBOZN) as "OBOZN_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,OBOZN)) OVER(partition by RN_ISPOB order by T_Start)
       end as "OBOZN_P",
       NVL2(T_DIS,null,TIP_ISPOB) as "TIP_ISPOB_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,TIP_ISPOB)) OVER(partition by RN_ISPOB order by T_Start)
       end as "TIP_ISPOB_P",
       NVL2(T_DIS,null,PACK_OBOZN) as "PACK_OBOZN_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,PACK_OBOZN)) OVER(partition by RN_ISPOB order by T_Start)
       end as "PACK_OBOZN_P"
from w_ktsg.V_ISP_OB_S_HISTORY
 WHERE rn_ispob = :x3) t
                  WHERE t.att_auth = :x4
                  ORDER BY t.dizm DESC) WHERE ROWNUM <2
)                  
 z ) WHERE cnt<2
ORDER BY 1                  
' USING f_get_isp(p_rntv),p_rnps,f_get_isp(p_rntv),p_rnps;
-- Технологическая добавка
IF ssE IN('У','Н') THEN
OPEN p_td FOR 'SELECT rn_tv,
                        att_arid,
                        dizm,
                        korii,
                        arid_p,
                        arid_n,
                        f_get_tehndob_string(arid_p) as td_p,
                        f_get_tehndob_string(arid_n) as td_n,
                        TEHNDOB_P,
                        TEHNDOB_N,
                        TEHNKOL_P,
                        TEHNKOL_N,
                        MAXPART_P,
                        MAXPART_N,
                        MINPART_P,
                        MINPART_N,
                        RN_PODR_ISP_P,
                        RN_PODR_ISP_N,
                        kornaim,
                        korv,
                        pornom || '' '' ||kornaim || '' '' || korv as poz,
                        pkor,
                        nkor,
                        IND_SADKA_P,
                        IND_SADKA_N,
                        tehndobnote_p,
                        tehndobnote_n,
                        rn_pozmo
                   FROM (SELECT a.rn_tv,
                   pm.pornom,
                                 att_arid,
                                 td_arid_b AS arid_p,
                                 td_arid_s AS arid_n,
                                 dizm,
                                 pii.kornaim AS korii,
                                 TEHNDOB_B AS TEHNDOB_P,
                                 TEHNDOB_N,
                                 TEHNKOL_B AS TEHNKOL_P,
                                 TEHNKOL_S AS TEHNKOL_N,
                                 MAXPART_b AS MAXPART_P,
                                 MAXPART_s AS MAXPART_N,
                                 MINPART_b AS MINPART_P,
                                 MINPART_s AS MINPART_N,
                                 RN_PODR_ISP_b AS RN_PODR_ISP_p,
                                 RN_PODR_ISP_s AS RN_PODR_ISP_n,
                                 mop.kornaim,
                                 mov.kornaim korv,
                                 pp.kornaim AS pkor,
                                 pn.kornaim AS nkor,
                                 IND_SADKA_b AS IND_SADKA_p,
                                 IND_SADKA_s AS IND_SADKA_n,
                                 tehndobnote_b AS tehndobnote_p,
                                 tehndobnote_s AS tehndobnote_n,
                                 a.rn_pozmo
                            FROM (select * FROM table(pk_mmk_izms.F_TD(:x1,:x2,0))) a
                                   JOIN w_ktsg.v_poz_mo_b mo ON
                                          a.ARID_POZMO = mo.att_ARID
                                          --AND a.T_VAR = 0
                                          and mo.att_var=0 and mo.att_arver=0
                                     and t_start<mo.att_arend
                                     and t_start>=mo.att_arstart
                                   JOIN w_vo.tb_vo mov ON mo.rn_vo = mov.rn
                                   JOIN w_mp.tb_podr mop ON mo.rn_podr=mop.rn

                                   JOIN w_mp.tb_podr pii ON a.RN_PODR_INITTD = pii.rn

                                   LEFT JOIN w_mp.tb_podr pn ON a.rn_podr_isp_s = pn.rn
                                   left JOIN w_mp.tb_podr pp ON a.RN_PODR_ISP_B = pp.rn

                                 JOIN w_ktsg.tb_poz_mo pm ON a.rn_pozmo=pm.rn
)
                  ORDER BY pornom, dizm, att_arid' USING p_rntv,p_rnps;
ELSE
OPEN p_td FOR 'SELECT rn_tv,
                        att_arid,
                        dizm,
                        korii,
                        arid_p,
                        arid_n,
                        f_get_tehndob_string(arid_p) as td_p,
                        f_get_tehndob_string(arid_n) as td_n,
                        TEHNDOB_P,
                        TEHNDOB_N,
                        TEHNKOL_P,
                        TEHNKOL_N,
                        MAXPART_P,
                        MAXPART_N,
                        MINPART_P,
                        MINPART_N,
                        RN_PODR_ISP_P,
                        RN_PODR_ISP_N,
                        kornaim,
                        korv,
                        pornom || '' '' ||kornaim || '' '' || korv as poz,
                        pkor,
                        nkor,
                        IND_SADKA_P,
                        IND_SADKA_N,
                        tehndobnote_p,
                        tehndobnote_n,
                        rn_pozmo
                   FROM (SELECT a.rn_tv,
                                 pm.pornom,
                                 att_arid,
                                 td_arid_b AS arid_p,
                                 td_arid_s AS arid_n,
                                 dizm,
                                 pii.kornaim AS korii,
                                 TEHNDOB_B AS TEHNDOB_P,
                                 TEHNDOB_N,
                                 TEHNKOL_B AS TEHNKOL_P,
                                 TEHNKOL_S AS TEHNKOL_N,
                                 MAXPART_b AS MAXPART_P,
                                 MAXPART_s AS MAXPART_N,
                                 MINPART_b AS MINPART_P,
                                 MINPART_s AS MINPART_N,
                                 RN_PODR_ISP_b AS RN_PODR_ISP_p,
                                 RN_PODR_ISP_s AS RN_PODR_ISP_n,
                                 mop.kornaim,
                                 mov.kornaim korv,
                                 pp.kornaim AS pkor,
                                 pn.kornaim AS nkor,
                                 IND_SADKA_b AS IND_SADKA_p,
                                 IND_SADKA_s AS IND_SADKA_n,
                                 tehndobnote_b AS tehndobnote_p,
                                 tehndobnote_s AS tehndobnote_n,
                                 a.rn_pozmo
                            FROM (select * FROM table(pk_mmk_izms.F_TD(:x1,:x2,1))) a
                                   JOIN w_ktsg.v_poz_mo_b mo ON
                                          a.ARID_POZMO = mo.att_ARID
                                          --AND a.T_VAR = 0
                                          and mo.att_var=0 and mo.att_arver=0
                                     and t_start<mo.att_arend
                                     and t_start>=mo.att_arstart
                                   JOIN w_vo.tb_vo mov ON mo.rn_vo = mov.rn
                                   JOIN w_mp.tb_podr mop ON mo.rn_podr=mop.rn

                                   JOIN w_mp.tb_podr pii ON a.RN_PODR_INITTD = pii.rn

                                   LEFT JOIN w_mp.tb_podr pn ON a.rn_podr_isp_s = pn.rn
                                   left JOIN w_mp.tb_podr pp ON a.RN_PODR_ISP_B = pp.rn

                                 JOIN w_ktsg.tb_poz_mo pm ON a.rn_pozmo=pm.rn
                                 -- Если был вариант 0
                                 --LEFT JOIN w_ktsg.v0_tehn_dob_s tdt ON a.arid_pozmo=tdt.arid_pozmo AND a.rn_podr_inittd = tdt.RN_PODR_INITTD
                                 --Отдел испытатель после в0
                                 --left JOIN w_mp.tb_podr pp0 ON tdt.RN_PODR_ISP = pp0.rn
                                 
)
                  ORDER BY pornom, dizm, att_arid' USING p_rntv,p_rnps;
END IF;
END;
PROCEDURE    p_td(p_arid IN NUMBER,
                                       p_DATE IN VARCHAR2,
                                       p_old IN VARCHAR2 DEFAULT NULL,
                                       p_td out curtyp)
                                       AS
                                       pd DATE;
                                       i INTEGER;
                                       BEGIN
                                       pd:=to_date(p_date,'DD.MM.YYYY HH24:MI:SS');
IF p_old IS NULL THEN
SELECT
COUNT(*) INTO i
FROM
w_ktsg.v_tehn_dob_b  tdb
WHERE  tdb.att_var=0 AND tdb.att_arver=0
AND pd - 0.0000058<tdb.att_arend
and pd - 0.0000058>=tdb.att_arstart
and tdb.arid_pozmo=p_arid;
IF TRUE THEN
  OPEN p_td FOR '
  SELECT
  F_GET_TEHNDOB_STRING(tdb.att_arid) AS TEHNDOBSTRING
  FROM
  w_ktsg.v_tehn_dob_b  tdb
  WHERE  tdb.att_var=0 AND tdb.att_arver=0
  AND :x1<tdb.att_arend
  and :x2>=tdb.att_arstart
  and tdb.arid_pozmo=:x3
  '
  USING                 pd - 0.0000058,pd - 0.0000058,p_arid;
END IF;
ELSE
SELECT
COUNT(*) INTO i
 FROM
w_ktsg.v_tehn_dob_b  tdb
WHERE  tdb.att_var=0 AND tdb.att_arver=0
AND pd<tdb.att_arend
and pd>=tdb.att_arstart
and tdb.arid_pozmo=p_arid;
IF TRUE THEN
    OPEN p_td FOR '
    SELECT
    F_GET_TEHNDOB_STRING(tdb.att_arid) AS TEHNDOBSTRING
     FROM
    w_ktsg.v_tehn_dob_b  tdb
    WHERE  tdb.att_var=0 AND tdb.att_arver=0
    AND :x1<tdb.att_arend
    and :x2>=tdb.att_arstart
    and tdb.arid_pozmo=:x3
    '
    USING                 pd,pd,p_arid;
END IF;

END IF;
                                       END;

--**************************************************************
PROCEDURE    p_matizm(p_rnmat IN NUMBER,
                                       p_psh out curtyp) AS
BEGIN
-- Список изменений в разработке где используется данный материал - для согласования со 112 отделом
open p_psh for
'select distinct ps.NOMIZM,ps.OSNOVANIE,io.obozn,b.name_full,
case
     when instr(subject_of_audit,'' '')=0 then
     subject_of_audit
else
substr(subject_of_audit,
                                       1,

                                       instr(subject_of_audit, '' '')) ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '') + 1,
                                       1) || ''.'' ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '', 1, 2) + 1,
                                       1) || ''.''
                                       end AS SOA,
ps.IND_STEXIST,ps.DT_IZMSTEXIST,p.SHORTNAME ||'' - '' || p.FULLNAME as TNAME,nvl(ps.isp_zadel,-1) as isp_zadel,ps.srok_vnedr,
ps.psnote,ps.rn,
(select count(distinct t1.rn_tv) from mv_persogl_tv t1 where t1.rn_persogl=t.rn) as cnt_tv,
(select count(distinct t1.rn_ispob) from mv_persogl_tv t1 where t1.rn_persogl=t.rn)as cnt_io
from
w_ktsg.v_isp_ob t
join w_ktsg.v0_isp_ob_s io on t.rn=io.rn_ispob
JOIN v_select_mat b ON t.RN_MAT=b.RN
JOIN w_ktsg.v1_t_zag_s z ON t.rn=z.RN_ISPOB_ZAG
JOIN w_ktsg.v_izm_tv it ON z.RN_TV=it.rn_tv
JOIN w_ktsg.v_per_sogl ps ON it.rn_persogl=ps.rn
join w_osnov.tb_typedoc p on ps.rn_typedoc=p.RN
left join w_ad.v_subject_of_audit a on ps.RN_SOTR_AVT=a.GUID
WHERE t.rn_mat= :x1
AND ps.ind_stexist=''Р''
' USING p_rnmat;
end;
--**************************************************************
PROCEDURE    p_matizmdce(p_rnps IN number,
                                                    p_rnmat IN NUMBER,
                                                    p_dce out curtyp) AS
BEGIN
--Изменения
open p_dce for 'select   t.obozn,t1.VI,t1.RN
from
mv_persogl_tv p
join w_ktsg.v0_isp_ob_s t on t.rn_ispob=p.rn_ispob
left join w_ktsg.v_tv t1 on p.rn_Tv=t1.RN
join w_ktsg.v1_t_zag_s z on p.rn_tv=z.rn_tv
join w_ktsg.v_isp_ob ob on ob.rn=z.rn_ispob_zag
where
      p.rn_persogl=:x1
      and ob.rn_mat=:x2
' USING p_rnps,p_rnmat;
end;
--**************************************************************
PROCEDURE p_rel_cursor(p_cur IN CURtyp) AS
BEGIN
          CLOSE p_cur;
END;
END PK_MMK_INFO;
/
--------------------------------------
--  New package body pk_mmk_info_r  --
--------------------------------------
CREATE OR REPLACE PACKAGE BODY W_MMKT.PK_MMK_INFO_R IS

sql_tv VARCHAR2(2500):='
select /*+star*/io.OBOZN, t.VI,p.tvnaim,
CASE io.TIP_ISPOB
    WHEN ''С'' THEN ''Свой''
    WHEN ''П'' THEN ''Покупной''
    WHEN ''М'' THEN ''Мусор''
    WHEN ''О'' THEN ''Ограничитель материалов''
    WHEN ''Д'' THEN ''Материал с доработкой''
  END AS TIP_NAIM,
  io.tip_ispob,
  vio.naim AS VID_NAIM,
  vio.kornaim as kvid,
  p.tvmassa,
  i.rn_mat,
nvl(w_mmkt.pk_mmk_info.F_trud(p.rn_tv,-1,:x0),'' '') tr,
p.tvnote,
f_ismmk(t.rn) as IND_MMK,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=t.rn and p.pornom_tv>=0)>0 then
(SELECT MAX(ps.NOMIZM) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv itv WHERE ps.RN = itv.rn_persogl AND ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'') AND itv.rn_tv = t.rn)
else
''  ''
end as IND_PS,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=t.rn and p.pornom_tv>=0)>0 then
(SELECT MAX(ps.rn) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv itv WHERE ps.RN = itv.rn_persogl AND ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'') AND itv.rn_tv = t.rn)
else
null
end as RN_PS,
case when ind_nalcomp=1 then
     ''+''
when ind_nalcomp is null then
        ''Нет данных''     
else
     ''-''
end as IND_NC
from
     w_ktsg.v0_isp_ob_s io
     join w_ktsg.v_isp_ob i on io.rn_ispob=i.rn
     join w_ktsg.tb_tv t on io.rn_ispob=t.rn_ispob
     left join w_ktsg.v0_tv_s p on t.rn=p.rn_tv
     JOIN w_ktsg.v_vid_isp_ob vio ON i.rn_vid_ispob=vio.rn
     where t.RN = :x1';
sql_tv_mv VARCHAR2(2500):='
select /*+star*/io.OBOZN, t.VI,t.tvnaim,
CASE io.TIP_ISPOB
    WHEN ''С'' THEN ''Свой''
    WHEN ''П'' THEN ''Покупной''
    WHEN ''М'' THEN ''Мусор''
    WHEN ''О'' THEN ''Ограничитель материалов''
    WHEN ''Д'' THEN ''Материал с доработкой''
  END AS TIP_NAIM,
  io.tip_ispob,
  vio.naim AS VID_NAIM,
  vio.kornaim as kvid,
  t.tvmassa,
  io.rn_mat,
nvl(w_mmkt.pk_mmk_info.F_trud(t.rn,-1,:x0),'' '') tr,
t.tvnote,
f_ismmk(t.rn) as IND_MMK,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=t.rn and p.pornom_tv>=0)>0 then
(SELECT MAX(ps.NOMIZM) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv itv WHERE ps.RN = itv.rn_persogl AND ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'') AND itv.rn_tv = t.rn)
else
''  ''
end as IND_PS,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=t.rn and p.pornom_tv>=0)>0 then
(SELECT MAX(ps.rn) FROM w_ktsg.tb_per_sogl ps, w_ktsg.tb_izm_tv itv WHERE ps.RN = itv.rn_persogl AND ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'') AND itv.rn_tv = t.rn)
else
null
end as RN_PS,
case when ind_nalcomp=1 then
     ''+''
     when ind_nalcomp is null then
        ''Нет данных''
else
     ''-''
end as IND_NC
from
     w_ktsg.mv_isp_ob io
     left join w_ktsg.mv_tv t on io.rn=t.rn_ispob
     join w_ktsg.tb_tv t1 on io.rn=t1.rn_ispob
     JOIN w_ktsg.v_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
     where t1.RN = :x1';
sql_ps varchar2(5000) :=
'select t.NOMIZM,t.OSNOVANIE,
case
     when instr(subject_of_audit,'' '')=0 then
     subject_of_audit
else
substr(subject_of_audit,
                                       1,

                                       instr(subject_of_audit, '' '')) ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '') + 1,
                                       1) || ''.'' ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '', 1, 2) + 1,
                                       1) || ''.''
                                       end AS SOA,
t.IND_STEXIST,
case when t.IND_STEXIST =''Р'' then ''Разработка''
when t.IND_STEXIST =''У'' then ''Утверждено''
when t.IND_STEXIST =''С'' then ''Согласование''
when t.IND_STEXIST =''Н'' then ''Унаследованный''
else ''Неизвестен''
end as IND_STEXIST_L,
t.DT_IZMSTEXIST,
p.SHORTNAME ||'' - '' || p.FULLNAME as TNAME,nvl(t.isp_zadel,-1) as isp_zadel,t.srok_vnedr,
t.psnote,
f_get_str_rspr(t.rn) as rspr
from
w_ktsg.v_per_sogl t
join w_osnov.v_tb_typedoc p on t.rn_typedoc=p.RN
left join w_ad.v_subject_of_audit a on t.RN_SOTR_AVT=a.GUID
where t.rn=:x1
';
sql_mo_mv VARCHAR2(5000):='
    SELECT
          NULL AS TEHNDOBSTRING,
           mos.att_arid AS arid,
           mos.pornom,
           mos.kpodr AS podr,
           mos.kvo AS VO,
           vn.NAIM || '' ('' || mos.kvo || '')''  AS VONAIM,
           mos.POZMONOTE
    FROM
         w_ktsg.mv_poz_mo mos
         LEFT JOIN w_vo.tb_vo_naim vn ON mos.rn_vo=vn.rn
    WHERE
          mos.rn_Tv= :x1
          order by mos.pornom';
sql_mo VARCHAR2(5000):='SELECT
          NULL AS TEHNDOBSTRING,
           mos.att_arid AS arid,
           mo.pornom,
           p.kornaim AS podr,
           v.kornaim AS VO,
           vn.NAIM || '' ('' || v.kornaim || '')''  AS VONAIM,
           mos.POZMONOTE
    FROM
         w_ktsg.v0_poz_mo_s mos
         JOIN w_ktsg.v_poz_mo mo ON mos.RN_POZMO=mo.rn
         JOIN w_mp.tb_podr p ON mos.rn_podr=p.rn
         JOIN w_vo.tb_vo v ON mos.RN_VO=v.rn
         LEFT JOIN w_vo.tb_vo_naim vn ON v.rn=vn.rn
    WHERE
          mos.rn_Tv= :x1
          order by mo.pornom';

sql_zag_mv VARCHAR2(5000):='SELECT --+star
  ios.obozn AS OBOZN,
  vio.naim AS VID_NAIM,
  vio.kornaim as kvid,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''изготавливаемый''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
  tz.NORMRASH,
  tz.KOLDETZAG,
  tz.VESZAG,
  tz.GEOMR_DL,
  tz.GEOMR_SH,
  tz.kornaim,
  tz.VIDZAG || case when vz.naim_vid is not null then '' ('' || vz.naim_vid || '')'' end AS VIDZAG_NAME,
  tz.TZAGNOTE,
  tv.rn as rntv_z,
  ios.rn_mat,
  ios.rn,
  ma.nn,
  ma.name_full
FROM
     w_ktsg.mv_t_zag tz
     JOIN w_ktsg.mv_isp_ob ios ON tz.RN_ISPOB_ZAG=ios.RN
     left join w_ktsg.mv_tv tv on tz.rn_ispob_zag=tv.rn_ispob
     JOIN w_ktsg.v_vid_isp_ob vio ON ios.rn_vid_ispob=vio.rn
     LEFT JOIN W_VIDZAG.TB_VID_ZAG vz ON vz.id_vid=tz.VIDZAG
     LEFT JOIN w_sprmat.tb_mat_spr ma ON ios.rn_mat=ma.rn
WHERE tz.RN_TV=  :x1
';
sql_zag VARCHAR2(5000):='SELECT --+star
ios.obozn AS OBOZN,
  vio.naim AS VID_NAIM,
  vio.kornaim as kvid,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''свой''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
  tz.NORMRASH,
  tz.KOLDETZAG,
  tz.VESZAG,
  tz.GEOMR_DL,
  tz.GEOMR_SH,
  ei.kornaim,
  tz.VIDZAG || case when vz.naim_vid is not null then '' ('' || vz.naim_vid || '')'' end AS VIDZAG_NAME,
  tz.TZAGNOTE,
  tv.rn as rntv_z,
  io.rn_mat,
  io.rn,
  ma.nn,
  ma.name_full
FROM
     w_ktsg.v0_t_zag_s tz
     JOIN w_ktsg.v0_isp_ob_s ios ON tz.RN_ISPOB_ZAG=ios.RN_ISPOB
     left join w_ktsg.v_tv tv on tz.rn_ispob_zag=tv.rn_ispob
     JOIN w_ktsg.v_isp_ob io ON io.rn=tz.RN_ISPOB_ZAG
     JOIN w_ktsg.v_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
     LEFT JOIN W_VIDZAG.TB_VID_ZAG vz ON vz.id_vid=tz.VIDZAG
     JOIN w_ei.tb_ei  ei ON tz.RN_EI=ei.rn
     LEFT JOIN w_sprmat.tb_mat_spr ma ON io.rn_mat=ma.rn
WHERE tz.RN_TV=  :x1';
sql_izm VARCHAR2(5000) :='select t.*,
p.ind_stexist,
CASE WHEN p.ind_stexist=''Н'' THEN ''Унаследованный''
     WHEN p.ind_stexist=''Р'' THEN ''Разработка''
     WHEN p.ind_stexist=''С'' THEN ''Согласование''
     WHEN p.ind_stexist=''У'' THEN ''Утверждено''
     ELSE ''Неизвестно''
     END AS i_state
from TABLE ( cast(w_mmkt.pk_mmk_info.F_GET_IZMTV(:x1,:x2) as w_mmkt.tb_izmtv)) t
JOIN w_ktsg.tb_per_sogl p ON t.rn=p.rn
order by t.dt_izmstexist desc';

   -- Function and procedure implementations
   FUNCTION F_GET_IZMTV (p_rntv IN NUMBER, p_date IN DATE DEFAULT NULL) RETURN tb_izmtv PIPELINED
   AS
   tmp rec_tb_izmtv;
   rn_ps NUMBER :=0;
   vDate DATE;
   BEGIN
   vDate:=p_date;
   IF p_date IS NULL THEN
      vDate:=trunc(SYSDATE);
   END IF;
tmp:=rec_tb_izmtv(NULL,NULL,NULL,NULL,NULL);

IF vDate=trunc(SYSDATE) THEN
FOR c IN (SELECT --+star
p.NOMIZM,p.RN, t.DT_IZMSTEXIST AS dstart,p.DT_IZMSTEXIST,
--f_isaudistates(t.rn_persogl,t.rn_tv) as kolstate
case when f_isaudistates(t.rn_persogl,t.rn_tv)>0 then '+'
else '-'
end  as kolstate
from mv_persogl_tv t
JOIN w_ktsg.v_per_sogl p ON t.rn_persogl=p.RN
JOIN w_osnov.v_tb_prich pr ON p.RN=pr.RN
 WHERE t.rn_tv=p_rntv
 ORDER BY t.DT_IZMSTEXIST DESC,p.DT_IZMSTEXIST desc
 ) LOOP
       IF rn_ps  <> c.rn THEN
          tmp.nomizm:=nvl(trim(c.nomizm),'...');
          tmp.rn:=c.rn;
          tmp.dt_izmstexist:=c.dt_izmstexist;
          tmp.kolstate:=c.kolstate;
          tmp.att_arstart:=c.dstart;
          PIPE ROW (tmp);
          rn_ps:=c.rn;
       END IF;
 END LOOP;
ELSE
FOR c IN (SELECT --+star
p.NOMIZM,p.RN, t.DT_IZMSTEXIST AS dstart,p.DT_IZMSTEXIST,
--f_isaudistates(t.rn_persogl,t.rn_tv) as kolstate
case when f_isaudistates(t.rn_persogl,t.rn_tv)>0 then '+'
else '-'
end  as kolstate
from --mv_persogl_tv t
v_persogl_tv_onlyizmtv t
JOIN w_ktsg.v_per_sogl p ON t.rn_persogl=p.RN
JOIN w_osnov.v_tb_prich pr ON p.RN=pr.RN
 WHERE t.rn_tv=p_rntv
 ORDER BY t.DT_IZMSTEXIST DESC
 ) LOOP
       IF rn_ps  <> c.rn THEN
          tmp.nomizm:=nvl(trim(c.nomizm),'...');
          tmp.rn:=c.rn;
          tmp.dt_izmstexist:=c.dt_izmstexist;
          tmp.kolstate:=c.kolstate;
          tmp.att_arstart:=c.dstart;
          PIPE ROW (tmp);
          rn_ps:=c.rn;
       END IF;
 END LOOP;
END IF;
 RETURN;
END;

   PROCEDURE P_FIND(P_OBOZN  IN VARCHAR2,
                    P_CONT   IN VARCHAR2,
                    P_KOL    IN INTEGER,
                    P_CURSEL OUT curtyp) AS
      str VARCHAR2(255);
   BEGIN
      str := p_obozn || '%';
      IF P_CONT = 'Y' THEN
         str := '%' || str;
      END IF;

      OPEN p_cursel FOR 'SELECT
       tv.rn,
       t.OBOZN,
       tv.vi,
       tv0.TVNAIM
FROM
       w_ktsg.v0_tv_s tv0,
       w_ktsg.tb_tv tv,
       w_ktsg.v0_isp_ob_s t
WHERE
      t.RN_ISPOB=tv.rn_ispob(+) AND
      tv0.RN_TV(+)=tv.rn AND t.obozn LIKE :x1'
         USING str;
   END;

   FUNCTION F_MO(P_RN IN INTEGER) RETURN VARCHAR2 IS
      -- Функция выдает маршрут (цехвоцехво) по RN
      CURSOR s1 IS
         SELECT t.PORNOM, t1.kornaim, lower(t2.kornaim) vobr
           FROM v_poz_mo0 t, w_mp.v_podr t1, w_vo.v_vo t2
          WHERE t.RN_TV = P_RN
            AND t.RN_PODR = t1.rn
            AND t.RN_VO = t2.rn
          ORDER BY t.PORNOM;

      RS1 s1%ROWTYPE;
      s   VARCHAR2(1024);
      f   BOOLEAN; -- показывает, есть ли отрицательные позиции в маршруте
      i   PLS_INTEGER; -- номер (по счету) отрицательной позиции
      y   PLS_INTEGER; -- номер (по счету) положительной позиции

   BEGIN
      f := FALSE;
      i := 0;
      y := 0;
      OPEN s1;
      LOOP
         FETCH s1
            INTO rs1;
         EXIT WHEN s1%NOTFOUND;
         IF rs1.pornom < 0 THEN
            f := TRUE;
            IF i = 0 THEN
               s := s || '(' || rs1.kornaim || rs1.vobr || ' ';
               i := 1;
            ELSE
               s := s || rs1.kornaim || rs1.vobr || ' ';
            END IF;
         ELSE
            IF f = FALSE THEN
               s := s || rs1.kornaim || rs1.vobr || ' ';
            ELSE
               IF y = 0 THEN
                  s := substr(s, 1, length(s) - 1) || ') ' || rs1.kornaim ||
                       rs1.vobr || ' ';
                  y := 1;
               ELSE
                  s := s || rs1.kornaim || rs1.vobr || ' ';
               END IF;
            END IF;
         END IF;
      END LOOP;
      CLOSE s1;
      IF i = 1 AND y = 0 THEN
         s := substr(s, 1, length(s) - 1) || ') ';
      END IF;
      RETURN(s);
   END;

   FUNCTION F_TRUD(P_RN IN NUMBER,
            p_dst IN INTEGER DEFAULT 0/*0-только вед, 1-тетрадные, -1 - определение*/,
            p_date IN DATE DEFAULT w_ktsg.pk_values.curdate) RETURN VARCHAR2 IS
      -- Функция выдает цеха с трудом  по RN
      s VARCHAR2(1024) := '';
      v_Department VARCHAR2(3):= SUBSTR(w_ad.f_ad_get_attrvalue_by_login(w_ad.f_get_current_aduser_login,'physicalDeliveryOfficeName'),1,3);
      cur DATE;
   BEGIN
   IF p_dst=-1 THEN
      IF v_Department IN ('105','140') THEN
          SELECT
                      t.trud_str_tip  INTO s
          FROM table( cast(f_mv_tv_inf_str(p_rn,p_date) AS t_mv_tv_inf_set)) t;
      ELSE
          SELECT
               t.trud_str  INTO s
          FROM table( cast(f_mv_tv_inf_str(p_rn, p_date) AS t_mv_tv_inf_set)) t;
      END IF;
   ELSE
          SELECT
      decode(p_dst,0,t.trud_str,1,t.trud_str_tip,t.trud_str)  INTO s
          FROM table( cast(f_mv_tv_inf_str(p_rn,p_date) AS t_mv_tv_inf_set)) t;
   END iF;
      RETURN(s);
   END;

   /* PROCEDURE P_FIND_1(P_OBOZN  IN VARCHAR2,
                         P_CONT   IN VARCHAR2,
                         P_KOL    IN INTEGER,
                         P_CURSEL OUT curtyp) AS
         str  VARCHAR2(255);
         p_mater number;     -- Признак материала

      BEGIN
         p_mater:=1005;
         str := p_obozn || '%';
         IF P_CONT = 'Y' THEN
            str := '%' || str;
         END IF;

         OPEN p_cursel FOR 'with DET as (SELECT tv.rn,
                        t.OBOZN||chr(125)||tv.vi||chr(32)||
                        case
                        when tv0.doly is not null
                           then chr(40)||tv0.doly*100||chr(37)||chr(41)
                        end
                        ||chr(125)||tv0.TVNAIM OBOZN,
                        tv.vi,
                        tv0.TVNAIM,
                        w_mmkt.pk_mmk_info.F_MO(tv.rn) m,
                        tv.ind_nalComp
                 FROM
                        w_ktsg.v0_tv_s tv0,
                        w_ktsg.tb_tv tv,
                        w_ktsg.v0_isp_ob_s t
                 WHERE
                       t.RN_ISPOB=tv.rn_ispob(+) AND
                       tv0.RN_TV(+)=tv.rn AND t.obozn like :x1)
   SELECT DET.rn, DET.OBOZN, DET.vi, DET.TVNAIM, DET.m||chr(125)||
                case
                  when io.rn_vid_ispob=:x2 and mat.rn is not null
                     then mat.nn
                  when io.rn_vid_ispob=:x3 and mat.rn is null
                     then rpad(chr(48),15,chr(48))
                  else
                     null
                end ||chr(125)||
                case
                when (tz.OBOZN is null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                      then case
                           when  DET.ind_nalComp = 0
                                then chr(45)||chr(45)
                           when  DET.ind_nalComp = 1
                                then chr(45)
                           end
                when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                      then tz.OBOZN
                when (tz.OBOZN is not null) and (z.GEOMR_DL is not null) and (z.GEOMR_SH is null)
                      then tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL
                when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is not null)
                      then tz.OBOZN||chr(32)||chr(83)||chr(61)||z.GEOMR_SH
                else
                     tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL||chr(42)||z.GEOMR_SH
                end  m,
                case
                  when io.rn_vid_ispob=:x4 and mat.rn is not null
                     then mat.nn
                  when io.rn_vid_ispob=:x5 and mat.rn is null
                     then rpad(chr(48),15,chr(48))
                  else
                     null
                end nom_num,
                case
                when (tz.OBOZN is null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                      then case
                           when  DET.ind_nalComp = 0
                                then chr(45)||chr(45)
                           when  DET.ind_nalComp = 1
                                then chr(45)
                           end
                when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                      then tz.OBOZN
                when (tz.OBOZN is not null) and (z.GEOMR_DL is not null) and (z.GEOMR_SH is null)
                      then tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL
                when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is not null)
                      then tz.OBOZN||chr(32)||chr(83)||chr(61)||z.GEOMR_SH
                else
                     tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL||chr(42)||z.GEOMR_SH
                end z
   FROM   DET,
          w_ktsg.v0_t_zag_s z,
          w_ktsg.v0_isp_ob_s tz,
          w_ktsg.tb_isp_ob io,
          w_sprmat.tb_mat_spr mat
   WHERE
          DET.rn=z.RN_TV(+) and
          z.RN_ISPOB_ZAG=tz.RN_ISPOB(+) and
          mat.rn(+)=io.rn_mat and
          io.rn(+)=z.RN_ISPOB_ZAG  '
            USING str, p_mater, p_mater, p_mater, p_mater;
      END;
   */
   PROCEDURE P_FIND_1(P_OBOZN  IN VARCHAR2,
                      P_CONT   IN VARCHAR2,
                      P_KOL    IN INTEGER,
                      P_PACKED IN VARCHAR2,
                      P_CURSEL OUT curtyp) AS

      -- P_CONT    - параметр, показывающий поиск с начала строки(N) или по подстроке(Y)
      -- P_PACKED  - показывает поиск по сжатому обозначению или нет

      str      VARCHAR2(255); -- условие поиска по обозначению
      str_pack VARCHAR2(255); -- условие поиска по сжатому обозначению
      p_mater  NUMBER; -- Признак материала

   BEGIN
      p_mater := 1005;
      -- Проверяем, нужен поиск по сжатому обозначению или нет
      IF P_PACKED = 'TRUE' THEN
         str      := '%';
         str_pack := w_common.f_pack_str(p_obozn) || '%';
         IF P_CONT = 'Y' THEN
            str_pack := '%' || str_pack;
         END IF;
      ELSE
         str_pack := '%';
         str      := p_obozn || '%';
         IF P_CONT = 'Y' THEN
            str := '%' || str;
         END IF;
      END IF;

      OPEN p_cursel FOR 'with DET as (SELECT tv.rn,
                     t.OBOZN||chr(125)||tv.vi||chr(32)||
                     case
                     when tv0.doly is not null
                        then chr(40)||tv0.doly*100||chr(37)||chr(41)
                     end
                     ||chr(125)||tv0.TVNAIM OBOZN,
                     tv.vi,
                     tv0.TVNAIM,
                     w_mmkt.pk_mmk_info.F_MO(tv.rn) m,
                     tv.ind_nalComp
              FROM
                     w_ktsg.v0_tv_s tv0,
                     w_ktsg.tb_tv tv,
                     w_ktsg.v0_isp_ob_s t
              WHERE
                    t.RN_ISPOB=tv.rn_ispob(+) AND
                    tv0.RN_TV(+)=tv.rn AND t.obozn like :x1 AND t.pack_obozn like :x2)
SELECT DET.rn, DET.OBOZN, DET.vi, DET.TVNAIM, DET.m||chr(125)||
             case
               when io.rn_vid_ispob=:x3 and mat.rn is not null
                  then mat.nn
               when io.rn_vid_ispob=:x4 and mat.rn is null
                  then rpad(chr(48),15,chr(48))
               else
                  null
             end ||chr(125)||
             case
             when (tz.OBOZN is null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                   then case
                        when  DET.ind_nalComp = 0
                             then chr(45)||chr(45)
                        when  DET.ind_nalComp = 1
                             then chr(45)
                        end
             when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                   then tz.OBOZN
             when (tz.OBOZN is not null) and (z.GEOMR_DL is not null) and (z.GEOMR_SH is null)
                   then tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL
             when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is not null)
                   then tz.OBOZN||chr(32)||chr(83)||chr(61)||z.GEOMR_SH
             else
                  tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL||chr(42)||z.GEOMR_SH
             end  m,
             case
               when io.rn_vid_ispob=:x5 and mat.rn is not null
                  then mat.nn
               when io.rn_vid_ispob=:x6 and mat.rn is null
                  then rpad(chr(48),15,chr(48))
               else
                  null
             end nom_num,
             case
             when (tz.OBOZN is null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                   then case
                        when  DET.ind_nalComp = 0
                             then chr(45)||chr(45)
                        when  DET.ind_nalComp = 1
                             then chr(45)
                        end
             when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is null)
                   then tz.OBOZN
             when (tz.OBOZN is not null) and (z.GEOMR_DL is not null) and (z.GEOMR_SH is null)
                   then tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL
             when (tz.OBOZN is not null) and (z.GEOMR_DL is null) and (z.GEOMR_SH is not null)
                   then tz.OBOZN||chr(32)||chr(83)||chr(61)||z.GEOMR_SH
             else
                  tz.OBOZN||chr(32)||chr(76)||chr(61)||z.GEOMR_DL||chr(42)||z.GEOMR_SH
             end z
FROM   DET,
       w_ktsg.v0_t_zag_s z,
       w_ktsg.v0_isp_ob_s tz,
       w_ktsg.tb_isp_ob io,
       w_sprmat.tb_mat_spr mat
WHERE
       DET.rn=z.RN_TV(+) and
       z.RN_ISPOB_ZAG=tz.RN_ISPOB(+) and
       mat.rn(+)=io.rn_mat and
       io.rn(+)=z.RN_ISPOB_ZAG  '
         USING str, str_pack, p_mater, p_mater, p_mater, p_mater;
   END;
--*************************************************************
PROCEDURE    p_tv_info(p_rntv IN NUMBER,
                                      p_date IN DATE,
                                      p_tv OUT curtyp) AS
BEGIN
w_ktsg.pk_values.set_curdate(p_date);
IF p_date=trunc(SYSDATE) THEN -- Материализованное представление
-- Тех вариант
OPEN p_tv FOR sql_tv_mv
         USING p_date,p_rntv;
ELSE
OPEN p_tv FOR sql_tv
         USING p_date,p_rntv;
END IF;
END;
--*************************************************************
PROCEDURE    p_izd_cexs(p_rntv IN NUMBER,
                                      p_date IN DATE,
                                      p_cur OUT curtyp) AS
BEGIN
OPEN p_cur FOR
'SELECT
  DISTINCT p.rn,p.kornaim
FROM TABLE(f_mmk_raskomp_kalc(:x1,:x2,1000000)) t
JOIN w_mp.tb_podr p ON t.cex=p.rn
order by p.kornaim
' USING p_rntv,p_date;

END;
--*************************************************************
PROCEDURE    p_izd_dce_by_cex(p_rntv IN NUMBER,
                        p_cex IN VARCHAR2,
                        p_date IN DATE,
                        p_cur OUT curtyp) AS
BEGIN
IF p_date=trunc(SYSDATE) THEN
OPEN p_cur FOR '
  SELECT
    DISTINCT t.kdce_ch,t.tv_ch,p.rn AS rn_podr,io.obozn,tv.vi,tvs.TVNAIM,round(ap1/1000000,5) AS ap,
    CASE WHEN instr(mv.mo_str,''('')<>0 THEN
         substr(mv.mo_str,1,instr(mv.mo_str,''('')-2)
    ELSE
         mv.mo_str
    END AS mo_str,
  w_otkv.f_istrud_podr(tv.rn,p.rn,0) AS Trud_Oper,
  w_otkv.f_istrud_podr(tv.rn,p.rn,1) AS Trud_Tetr
  FROM (
  SELECT kdce_ch,tv_ch,cex,ind,
  CASE WHEN ind=0 THEN MAX(kol) over (PARTITION BY kdce_ch,ind,ez)
             ELSE SUM(kol) over (PARTITION BY kdce_ch,ind,ez) END kol1,
        CASE WHEN ind=0 THEN MAX(ap) over (PARTITION BY kdce_ch,ind,ez)
             ELSE SUM(ap) over (PARTITION BY kdce_ch,ind,ez) END ap1
   FROM
  TABLE(f_mmk_raskomp_kalc(:x1,:x2,1000000))
  ) t
  JOIN w_mp.tb_podr p ON t.cex=p.rn
  JOIN w_ktsg.v0_isp_ob_s io ON t.kdce_ch=io.RN_ISPOB
  LEFT JOIN w_ktsg.tb_tv tv ON t.tv_ch=tv.rn
  LEFT JOIN w_ktsg.v0_tv_s tvs ON t.tv_ch=tvs.RN_TV
  LEFT JOIN w_mmkt.mv_Tv_inf mv ON t.tv_ch=mv.rn
  WHERE p.kornaim=:x3 AND t.ind=0
  ORDER BY io.obozn' USING p_rntv,p_date,p_cex;
ELSE
OPEN p_cur FOR '
  SELECT
    DISTINCT t.kdce_ch,t.tv_ch,p.rn AS rn_podr,io.obozn,tv.vi,tvs.TVNAIM,ap1/1000000 AS ap,
    f_mo_str(t.tv_ch,0,:x01) AS mo_str,
  w_otkv.f_istrud_podr(tv.rn,p.rn,0,:x02) AS Trud_Oper,
  w_otkv.f_istrud_podr(tv.rn,p.rn,1,:x03) AS Trud_Tetr
  FROM (
  SELECT kdce_ch,tv_ch,cex,ind,
  CASE WHEN ind=0 THEN MAX(kol) over (PARTITION BY kdce_ch,ind,ez)
             ELSE SUM(kol) over (PARTITION BY kdce_ch,ind,ez) END kol1,
        CASE WHEN ind=0 THEN MAX(ap) over (PARTITION BY kdce_ch,ind,ez)
             ELSE SUM(ap) over (PARTITION BY kdce_ch,ind,ez) END ap1
   FROM
  TABLE(f_mmk_raskomp_kalc(:x1,:x2,1000000))
  ) t
  JOIN w_mp.tb_podr p ON t.cex=p.rn
  JOIN w_ktsg.v0_isp_ob_s io ON t.kdce_ch=io.RN_ISPOB
  LEFT JOIN w_ktsg.tb_tv tv ON t.tv_ch=tv.rn
  LEFT JOIN w_ktsg.v0_tv_s tvs ON t.tv_ch=tvs.RN_TV
  LEFT JOIN w_mmkt.mv_Tv_inf mv ON t.tv_ch=mv.rn
  WHERE p.kornaim=:x3 AND t.ind=0
  ORDER BY io.obozn' USING p_date,p_date,p_date,p_rntv,p_date,p_cex;

END IF;
END;
--*************************************************************
PROCEDURE    p_zag(p_rntv IN NUMBER,
                                             p_rzr IN NUMBER DEFAULT 0,
                                             p_zag OUT curtyp
) AS
                                             BEGIN
IF p_rzr=1 THEN
--Заготовка
OPEN p_zag FOR '
SELECT --+star
CASE vio.kornaim
    WHEN ''М'' THEN
         (SELECT ms.NAME_FULL FROM W_SPRMAT.VW_MAT_SPR_EX_WITH_MAT118 ms WHERE ms.rn = io.RN_MAT)
    ELSE
         ios.OBOZN
  END AS OBOZN,
  ios.obozn as oboznio,
  vio.naim AS VID_NAIM,
  vio.kornaim as kvid,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''свой''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
  tz.NORMRASH,
  tz.KOLDETZAG,
  tz.VESZAG,
  tz.GEOMR_DL,
  tz.GEOMR_SH,
  ei.kornaim,
  tz.VIDZAG || case when vz.naim_vid is not null then '' ('' || vz.naim_vid || '')'' end AS VIDZAG_NAME,
  tz.TZAGNOTE,
  tv.rn as rntv_z,
  w_mmkt.F_GET_MO_TO_STR(1,NULL,tz.RN_TV) as MO
FROM
     w_ktsg.v1_t_zag_s tz
     JOIN w_ktsg.v0_isp_ob_s ios ON tz.RN_ISPOB_ZAG=ios.RN_ISPOB
     left join w_ktsg.v_tv tv on tz.rn_ispob_zag=tv.rn_ispob
     JOIN w_ktsg.v_isp_ob io ON io.rn=tz.RN_ISPOB_ZAG
     JOIN w_ktsg.v_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
     LEFT JOIN W_VIDZAG.TB_VID_ZAG vz ON vz.id_vid=tz.VIDZAG
     JOIN w_ei.tb_ei  ei ON tz.RN_EI=ei.rn
WHERE tz.RN_TV=  :x1'
         USING p_rntv;
END IF;
END;
--*************************************************************
PROCEDURE    p_all(p_rntv IN NUMBER,
                                       p_date IN DATE,
                                             p_tv OUT curtyp,
                                             p_mo OUT curtyp,
                                             p_zag OUT curtyp,
                                             p_obr OUT curtyp,
                                             p_sost OUT curtyp,
                                             p_vhod OUT curtyp,
                                             p_izmtv OUT curtyp,
                                             p_oinfo OUT curtyp) AS

                                             BEGIN
w_ktsg.pk_values.set_curdate(p_date);
IF p_date=trunc(SYSDATE) THEN -- Материализованное представление
-- Тех вариант
OPEN p_tv FOR sql_tv_mv
         USING p_date,p_rntv;
-- Маршрут
OPEN p_mo FOR sql_mo_mv USING p_rntv;
--Заготовка
OPEN p_zag FOR sql_zag_mv USING p_rntv;
-- Образцы
OPEN p_obr FOR '
SELECT iono.obozn || '' (Вар. изг.'' || tvno.vi || '')'' as OBOZN_TV_OBR,
o.rn_tv_obr,
ionzo.OBOZN || '' (Вар. изг.'' || tvnzo.vi || '')''as obozn_tv_protect,
o.TEHNKOL,
round(o.MAXPART,6) as maxpart,
o.podrisp as podr_isp,
o.podrtd  as podr_inittd,
o.INFOBRNOTE,
m.PORNOM ,
 pd.kornaim || '''' || lower(vo.kornaim) as poz_z,
(SELECT count(*) FROM w_ktsg.mv_poz_mo mmm WHERE mmm.att_arid=mo.att_arid) AS act
FROM w_ktsg.mv_obr o
JOIN w_ktsg.mv_tv tvno  ON o.RN_TV_OBR=tvno.rn
JOIN w_ktsg.mv_isp_ob iono ON tvno.rn_ispob=iono.RN
JOIN w_ktsg.v_poz_mo_s_wa mo ON o.ARID_POZMO=mo.att_arid
JOIN w_mp.tb_podr pd ON mo.rn_podr=pd.rn
JOIN w_vo.tb_vo vo ON mo.rn_vo=vo.rn
JOIN w_ktsg.v_poz_mo m ON mo.rn_pozmo=m.RN
JOIN w_ktsg.v_tv tvnzo ON mo.rn_tv=tvnzo.rn
JOIN w_ktsg.mv_isp_ob ionzo ON ionzo.RN=tvnzo.rn_ispob

WHERE o.RN_TV_IZG= :x1'
         USING p_rntv;

-- Состав
      OPEN p_sost FOR '
SELECT --+star
t.rn_tv,
tvs.rn as RN_TV_CH,
k.obozn,
replace(
case when mod(t.kol,round(t.kol) ) <>0 then
to_char(t.kol,''FM99999990.099999999'')
else
to_char(t.kol)
end
,''.'','','')  || '' '' || replace(ei.kornaim,''ШТ'','''') AS kol,
 tvs.TVNAIM,
 t.rn_pozmo,
 m.rn_podr,
 m. kpodr as kornaim,
decode(NVL(tvs.IND_NALCOMP, ''555''),''0'',''-'',''1'',''+'',''Нет ТВ'') Ind_Has_comp,
case when tvs.rn is null then ''-''
when
(
select --+star
COUNT(1)
from w_mmkt.mv_persogl_tv t
WHERE t.rn_tv=tvs.rn AND t.rn_typedoc=1008)
>0 then ''GC'' else
''ММВ''
end
as Ind_is_tv,
t.ustcompnote,
case when tvs.rn is null then ''Нет ТВ''
else
   f_ismmk(tvs.rn)
end as IND_MMK,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=tvs.rn and p.pornom_tv>=0)>0 then
''ПС''
else
''  ''
end as IND_PS,
ei.kornaim AS eikor
FROM
w_ktsg.mv_ust_comp t
LEFT JOIN w_ktsg.mv_tv tvs ON t.RN_ISPOB_CH=tvs.RN_ISPOB
JOIN w_ktsg.mv_isp_ob k ON k.rn=t.rn_ispob_ch
JOIN w_ei.tb_ei ei ON t.rn_ei_ust=ei.rn
/*LEFT*/ JOIN w_ktsg.mv_Poz_MO m ON m.rn=t.rn_pozmo
WHERE t.rn_tv = :x1
order by f_get_tv_spr(k.kornaim,k.tip_ispob,tvs.ind_nalcomp),k.obozn'
         USING p_rntv;
-- Входимость
OPEN p_vhod FOR '
SELECT --+star
tv_ch.rn AS RN_TV_CH,
cs.RN_TV AS RN_TV_KUDA,
tv_k.VI,
tv_k.TVNAIM,
ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')'' as obozn,
vio.naim AS VID_NAIM,
/*CASE vio.kornaim
    WHEN ''М'' THEN (SELECT ms.NAME_FULL FROM W_SPRMAT.VW_MAT_SPR_EX_WITH_MAT118 ms WHERE ms.rn = ios.RN_MAT)
    ELSE ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')''
  END AS OBOZN_KUDA,*/
  ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')'' AS OBOZN_KUDA,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''свой''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
replace(
case when mod(cs.kol,round(cs.kol) ) <>0 then
to_char(cs.kol,''FM99999990.099999999'')
else
to_char(cs.kol)
end
,''.'','','')  || '' '' || replace(ei.kornaim,''ШТ'','''') AS kol,
  m.kpodr AS podr,
  m.kvo AS vo
FROM
       w_ktsg.v_tv tv_ch
       JOIN w_ktsg.mv_ust_comp cs ON cs.RN_ISPOB_CH=tv_ch.RN_ISPOB
       JOIN w_ei.tb_ei ei ON cs.rn_ei_ust=ei.rn
       JOIN w_ktsg.mv_tv tv_k ON cs.RN_TV=tv_k.RN
       JOIN w_ktsg.mv_isp_ob ios ON tv_k.RN_ISPOB=ios.RN
       JOIN w_ktsg.v_vid_isp_ob vio ON ios.rn_vid_ispob=vio.rn
       LEFT JOIN w_ktsg.mv_poz_mo m ON m.rn=cs.rn_pozmo
WHERE tv_ch.RN=:x1
order by f_get_tv_spr(vio.kornaim,ios.tip_ispob,tv_k.ind_nalcomp),ios.obozn
'
         USING p_rntv;

OPEN p_oinfo FOR
         'SELECT --+star
tv.RN AS rn_tv_izg,
ioizg.OBOZN || '' (Вар.изг. '' || tv.vi || '')''AS obozn_izg,
tvz.RN AS rn_Tv_z,
ioz.OBOZN || '' (Вар.изг. '' ||  tvz.vi || '')'' AS obozn_z,
to_char(round(t.TEHNKOL,2)) ||''/'' || to_char(round(t.MAXPART)) AS kolpart,
t.podrisp AS podri,
t.podrtd AS podrii,
mo.kpodr || '' '' || mo.kvo as poz
FROM w_ktsg.mv_obr t
JOIN w_ktsg.v_tv tv ON t.RN_TV_IZG=tv.RN
JOIN w_ktsg.mv_isp_ob ioizg ON tv.RN_ISPOB=ioizg.RN
JOIN w_ktsg.mv_poz_mo mo ON t.ARID_POZMO=mo.att_ARID
JOIN w_ktsg.v_tv tvz oN mo.RN_TV=tvz.RN
JOIN w_ktsg.mv_isp_ob ioz ON tvz.RN_ISPOB=ioz.RN

WHERE t.RN_TV_OBR=:x1

' USING p_rntv;

ELSE -- ********************  По историческим таблицам
OPEN p_tv FOR sql_tv
         USING p_date,p_rntv;
-- Маршрут
OPEN p_mo FOR sql_mo USING p_rntv;
--Заготовка
OPEN p_zag FOR sql_zag
         USING p_rntv;
-- Образцы
OPEN p_obr FOR '
SELECT iono.obozn || '' (Вар. изг.'' || tvno.vi || '')'' as OBOZN_TV_OBR,
o.rn_tv_obr,
ionzo.OBOZN || '' (Вар. изг.'' || tvnzo.vi || '')''as obozn_tv_protect,o.TEHNKOL,round(o.MAXPART,6) as maxpart,pisp.kornaim as podr_isp,pii.kornaim as podr_inittd,o.INFOBRNOTE,
m.PORNOM,
to_char(pd.kornaim) || '''' || lower(vo.kornaim) as poz_z,
(SELECT count(*) FROM w_ktsg.v0_poz_mo_s mmm WHERE mmm.att_arid=mo.att_arid) AS act
FROM w_ktsg.v0_obr_s o
JOIN w_ktsg.v_tv tvno  ON o.RN_TV_OBR=tvno.rn
JOIN w_ktsg.v0_isp_ob_s iono ON tvno.rn_ispob=iono.RN_ISPOB
JOIN w_ktsg.v_poz_mo_b mo ON o.ARID_POZMO=mo.att_arid and mo.att_arver=0 and mo.att_var=0
JOIN w_mp.tb_podr pd ON mo.rn_podr=pd.rn
JOIN w_vo.tb_vo vo ON mo.rn_vo=vo.rn
JOIN w_ktsg.v_poz_mo m ON mo.rn_pozmo=m.RN
JOIN w_ktsg.v_tv tvnzo ON mo.rn_tv=tvnzo.rn
JOIN w_ktsg.v0_isp_ob_s ionzo ON ionzo.RN_ISPOB=tvnzo.rn_ispob
JOIN w_mp.tb_podr pisp ON o.RN_PODR_ISP=pisp.rn
JOIN w_mp.tb_podr pii ON o.RN_PODR_INITTD=pii.rn

WHERE o.RN_TV_IZG= :x1'
         USING p_rntv;
-- Состав
      OPEN p_sost FOR '
SELECT --+star
t.rn_tv, tv2.rn as RN_TV_CH, k.obozn,
replace(
case when mod(t.kol,round(t.kol) ) <>0 then
to_char(t.kol,''FM99999990.099999999'')
else
to_char(t.kol)
end
,''.'','','')
|| '' '' || replace(ei.kornaim,''ШТ'','''') AS kol,
tvs.TVNAIM, t.rn_pozmo, m.rn_podr,p.kornaim,
decode(NVL(tv2.IND_NALCOMP, ''555''),''0'',''-'',''1'',''+'',''Нет ТВ'') Ind_Has_comp,
case when tv2.rn is null then ''-''
when
(
select --+star
COUNT(1)
from V_PERSOGL_TV_ONLYIZMTV t
WHERE t.rn_tv=tv2.rn AND t.rn_typedoc=1008)
>0 then ''ПС'' else
''ММВ''
end
as Ind_is_tv,
t.ustcompnote,
case when tv2.rn is null then ''Нет ТВ''
else
f_ismmk(tv2.rn)
end as IND_MMK,
case when (select count(*) from w_ktsg.tb_izm_tv p
       join w_ktsg.v_per_sogl ps on p.rn_persogl=ps.RN and ps.IND_STEXIST not in (''У'',''Н'') and ps.rn_typedoc=w_osnov.f_getdoctype(''ПС'')
where p.rn_tv=tv2.rn and p.pornom_tv>=0)>0 then
''ПС''
else
''  ''
end as IND_PS,
ei.kornaim AS eikor
FROM
w_ktsg.v0_ust_comp_s t
JOIN w_ei.tb_ei ei ON t.rn_ei_ust=ei.rn
LEFT JOIN (w_ktsg.v_tv  tv2
     JOIN w_ktsg.v0_tv_s tvs ON tv2.RN=tvs.RN_TV
                       )ON t.RN_ISPOB_CH=tv2.RN_ISPOB
JOIN w_ktsg.v0_isp_ob_s k ON k.rn_ispob=t.rn_ispob_ch
join w_ktsg.v_isp_ob io on k.rn_ispob=io.rn
join w_ktsg.v_vid_isp_ob vio on io.rn_vid_ispob=vio.rn

/*LEFT*/ JOIN (w_ktsg.V0_Poz_MO_S m
          JOIN w_mp.tb_podr p ON  p.rn=m.rn_podr
                            )ON m.rn_pozmo=t.rn_pozmo
WHERE t.rn_tv = :x1
order by f_get_tv_spr(vio.kornaim,k.tip_ispob,tv2.ind_nalcomp),k.obozn'
         USING p_rntv;
-- Входимость
OPEN p_vhod FOR '
SELECT --+star
tv_ch.rn AS RN_TV_CH,
cs.RN_TV AS RN_TV_KUDA,
tv_k.VI,
tvs.TVNAIM,
ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')'' as obozn,
vio.naim AS VID_NAIM,
/*CASE vio.kornaim
    WHEN ''М'' THEN (SELECT ms.NAME_FULL FROM W_SPRMAT.VW_MAT_SPR_EX_WITH_MAT118 ms WHERE ms.rn = io.RN_MAT)
    ELSE ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')''
  END AS OBOZN_KUDA,*/
ios.OBOZN || '' (Вар. изг. '' || tv_k.vi || '')'' AS OBOZN_KUDA,
  CASE ios.TIP_ISPOB
    WHEN ''С'' THEN ''свой''
    WHEN ''П'' THEN ''покупной''
  END AS TIP_NAIM,
replace(
case when mod(cs.kol,round(cs.kol) ) <>0 then
to_char(cs.kol,''FM99999990.099999999'')
else
to_char(cs.kol)
end
,''.'','','')  || '' '' || replace(ei.kornaim,''ШТ'','''') AS kol,
  p.kornaim AS podr,
  v.kornaim AS vo

FROM
       w_ktsg.v_tv tv_ch
       JOIN w_ktsg.v0_ust_comp_s cs ON cs.RN_ISPOB_CH=tv_ch.RN_ISPOB
       JOIN w_ei.tb_ei ei ON cs.rn_ei_ust=ei.rn
       JOIN w_ktsg.v_tv tv_k ON cs.RN_TV=tv_k.RN
       JOIN w_ktsg.v0_tv_s tvs ON tv_k.RN=tvs.RN_TV
       JOIN w_ktsg.v0_isp_ob_s ios ON tv_k.RN_ISPOB=ios.RN_ISPOB
       JOIN w_ktsg.v_isp_ob io ON tv_k.RN_ISPOB=io.rn
       JOIN w_ktsg.v_vid_isp_ob vio ON io.rn_vid_ispob=vio.rn
       LEFT JOIN (w_ktsg.V0_Poz_MO_S m
            JOIN w_mp.tb_podr p ON  p.rn=m.rn_podr
            JOIN w_vo.tb_vo v ON v.rn=m.RN_PODR
       )ON m.rn_pozmo=cs.rn_pozmo

WHERE tv_ch.RN=:x1
order by f_get_tv_spr(vio.kornaim,ios.tip_ispob,tv_k.ind_nalcomp),ios.obozn
'
         USING p_rntv;
--Образец-информация
OPEN p_oinfo FOR
         'SELECT --+star
tv.RN AS rn_tv_izg,ioizg.OBOZN || '' (Вар.изг. '' || tv.vi || '')''AS obozn_izg,tvz.RN AS rn_Tv_z, ioz.OBOZN || '' (Вар.изг. '' ||  tvz.vi || '')'' AS obozn_z,
to_char(round(t.TEHNKOL,2)) ||''/'' || to_char(round(t.MAXPART)) AS kolpart,
pi.kornaim AS podri,
pii.kornaim AS podrii,
pz.kornaim || '' '' || v.kornaim as poz
FROM w_ktsg.v0_obr_s t
JOIN w_ktsg.v_tv tv ON t.RN_TV_IZG=tv.RN
JOIN w_ktsg.v0_isp_ob_s ioizg ON tv.RN_ISPOB=ioizg.RN_ISPOB
JOIN w_ktsg.v0_poz_mo_s mo ON t.ARID_POZMO=mo.att_ARID
JOIN w_ktsg.v_tv tvz oN mo.RN_TV=tvz.RN
JOIN w_ktsg.v0_isp_ob_s ioz ON tvz.RN_ISPOB=ioz.RN_ISPOB
join w_mp.tb_podr pz on mo.rn_podr = pz.rn
join w_vo.tb_vo v on mo.rn_vo=v.rn
join w_mp.tb_podr pi on t.RN_PODR_ISP=pi.rn
join w_mp.tb_podr pii on t.RN_PODR_INITTD=pii.rn

WHERE t.RN_TV_OBR=:x1' USING p_rntv;
END IF;
--Изменения
/*OPEN p_izmtv FOR '
select --+star
p.NOMIZM,p.RN, p.DT_IZMSTEXIST,
--f_isaudistates(t.rn_persogl,t.rn_tv) as kolstate
case when f_isaudistates(t.rn_persogl,t.rn_tv)>0 then ''+''
else ''-''
end  as kolstate
from mv_persogl_tv t
JOIN w_ktsg.v_per_sogl p ON t.rn_persogl=p.RN
JOIN w_osnov.v_tb_prich pr ON p.RN=pr.RN

 WHERE t.rn_tv=:x1
 ORDER BY p.DT_IZMSTEXIST DESC'
         USING p_rntv;*/
OPEN p_izmtv FOR sql_izm
USING p_rntv,p_date;
END;
--*************************************************************
PROCEDURE    p_info_mo(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_mo OUT curtyp
                         ) AS
BEGIN
w_ktsg.pk_values.set_curdate(p_date);
IF p_date=trunc(SYSDATE) THEN -- Материализованное представление
    -- Маршрут
    OPEN p_mo FOR sql_mo_mv USING p_rntv;
ELSE -- ********************  По историческим таблицам
    -- Маршрут
    OPEN p_mo FOR sql_mo USING p_rntv;
END IF;
END;
--*************************************************************
PROCEDURE    p_info_zag(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_zag OUT curtyp
                         ) AS
BEGIN
w_ktsg.pk_values.set_curdate(p_date);
IF p_date=trunc(SYSDATE) THEN -- Материализованное представление
    -- Заготовка
    OPEN p_zag FOR sql_zag_mv USING p_rntv;
ELSE -- ********************  По историческим таблицам
    -- Заготовка
    OPEN p_zag FOR sql_zag USING p_rntv;
END IF;
END;
--**************************************************************
PROCEDURE    p_info_izm(p_rntv IN NUMBER,
                         p_date IN DATE,
                         p_izm OUT curtyp
                         ) AS 
                         
BEGIN
  OPEN p_izm FOR sql_izm
  USING p_rntv,p_date;
END;
PROCEDURE    p_act_td(p_arid IN NUMBER,
                                       p_DATE IN DATE,
                                       p_td out curtyp)
                                       AS
                                       pd DATE;
                                       BEGIN

w_ktsg.pk_values.set_curdate(p_date);
IF p_date =trunc(SYSDATE) THEN
OPEN p_td FOR 'SELECT
  mo.rn_tv,
  td.att_arid AS arid,
  td.arid_pozmo,
  td.tehndob,
  td.tehnkol,
  td.maxpart,
  td.Minpart,
  td.rn_podr_inittd,
  td.podrtd AS podr_inittd,
  td.rn_podr_isp,
  td.podrisp AS podr_isp,
  td.ind_sadka,
  td.tehndobnote,
  F_GET_TEHNDOB_STRING(td.att_arid) AS TEHNDOBSTRING
FROM
  w_ktsg.mv_tehn_dob td,
  w_ktsg.mv_poz_mo mo
WHERE
  td.arid_pozmo = mo.att_ARID
  and ARID_POZMO = :x1
' USING p_arid;
ELSE
OPEN p_td FOR 'select *
     from w_mmkt.v_mmk0_tehn_dob t
     WHERE ARID_POZMO = :x1'
USING p_arid;
END IF;
END;

--**************************************************************
PROCEDURE    p_findizm(p_nomizm IN varchar2,
                                             p_typ IN INTEGER DEFAULT -1, --Тип извещения: -1  - все извещения
                                             p_status IN VARCHAR2 DEFAULT 'РСУН', --Извещения с какими статусами искать - по умолчанию все
                                             p_aut IN VARCHAR2 DEFAULT NULL, -- Автор извещений - по умолчанию все
                                             p_ncompl IN INTEGER DEFAULT 0, -- Необработанные
                                             p_psh out curtyp
                                       ) AS
                                       nomizm varchar2(100);
                                       aut NUMBER;
BEGIN
nomizm:='%' || p_nomizm || '%';
IF p_aut='-1' THEN
   aut:=NULL;
ELSE
    aut:=w_ad.To_Numberguid(p_aut);
END IF;
--Изменения
open p_psh for 'select t.NOMIZM,t.OSNOVANIE,
case
     when instr(subject_of_audit,'' '')=0 then
     subject_of_audit
else
substr(subject_of_audit,
                                       1,

                                       instr(subject_of_audit, '' '')) ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '') + 1,
                                       1) || ''.'' ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '', 1, 2) + 1,
                                       1) || ''.''
                                       end AS SOA,
t.IND_STEXIST,t.DT_IZMSTEXIST,p.SHORTNAME ||'' - '' || p.FULLNAME as TNAME,nvl(t.isp_zadel,-1) as isp_zadel,t.srok_vnedr,
t.psnote,t.rn,
case when (t.rn_typedoc=1008 and t.ind_stexist in (''У'',''Р'')) or (t.rn_typedoc=1010 and t.ind_stexist in (''Н''))then
''1''
else
''0''
end  AS ind_vygr,
p1.dlog,
(select count(distinct t1.rn_tv) from mv_persogl_tv t1 where t1.rn_persogl=t.rn) as cnt_tv,
(select count(distinct t1.rn_ispob) from mv_persogl_tv t1 where t1.rn_persogl=t.rn)as cnt_io,
t.ind_stexist as status

from
w_ktsg.v_per_sogl t
join w_osnov.v_tb_typedoc p on t.rn_typedoc=p.RN
left join w_ad.v_subject_of_audit a on t.RN_SOTR_AVT=a.GUID
LEFT JOIN w_mmkt.tb_ps_bnh p1 ON t.rn=p1.rn
where /*t.ind_stexist in (''У'',''Н'') and*/ t.nomizm  like :x1
and (:x2=-1 or (t.rn_typedoc=:x3) )
and :x4 like ''%'' ||t.ind_stexist || ''%''
and (:x5=0 or ( :x6=1 and p1.dlog is null))
and (:x7 is null or ( :x8=t.rn_sotr_avt ))
' USING nomizm,p_typ,p_typ,p_status,p_ncompl, p_ncompl,aut,aut;
end;
--**************************************************************
PROCEDURE    p_izmdce(p_rnps IN number,
                                       p_dce out curtyp) AS
vDate DATE ;
BEGIN
SELECT t.dt_izmstexist INTO vDate FROM w_ktsg.tb_per_sogl t WHERE t.rn=p_rnps;
IF trunc(vDate,'DD')<>trunc(SYSDATE,'DD') THEN
--Изменения
open p_dce for '
select * from
(
select distinct t.obozn,t1.VI,t1.RN
from
w_ktsg.tb_izm_tv p
JOIN w_ktsg.tb_tv tp ON p.rn_tv=tp.rn
join w_ktsg.v0_isp_ob_s t on t.rn_ispob=tp.rn_ispob
left join w_ktsg.v_tv t1 on p.rn_Tv=t1.RN
where p.rn_persogl=:x1
order by 1,2
)
' USING p_rnps;
ELSE
--Изменения
open p_dce for '
select * from (
select   distinct t.obozn,t1.VI,t1.RN
from
mv_persogl_tv p
join w_ktsg.v0_isp_ob_s t on t.rn_ispob=p.rn_ispob
left join w_ktsg.v_tv t1 on p.rn_Tv=t1.RN
where p.rn_persogl=:x1
order by 1,2)
' USING p_rnps;
END IF;
end;
--**************************************************************
PROCEDURE    p_getpsh(p_rnps in number,
                      p_psh out curtyp) AS
BEGIN
--Изменения
open p_psh for sql_ps USING p_rnps;
end;
--**************************************************************
PROCEDURE    p_izmdata(p_rntv IN NUMBER,
                                       p_rnps IN NUMBER,
                                       p_psh out curtyp,
                                       p_tv out curtyp,
                                       p_mo OUT curtyp,
                                       p_zag OUT curtyp,
                                       p_obr OUT curtyp,
                                       p_sost OUT curtyp,
                                       p_vhod OUT curtyp,
                                       p_isp OUT curtyp,
                                       p_td OUT curtyp) AS
vVar NUMBER;
ssE CHAR(1);
BEGIN
SELECT MAX(t.att_var) INTO vVar FROM w_ktsg.v_audi t WHERE t.att_auth=p_rnps;
vVar:=nvl(vVar,0);
SELECT MAX(t.ind_stexist) INTO ssE FROM w_ktsg.tb_per_sogl t WHERE t.rn=p_rnps;
--Изменения
open p_psh for sql_ps USING p_rnps;
--Технологический вариант
open p_tv for
'
SELECT * FROM (
SELECT a.*,   count(*) over (PARTITION BY doly_p,tvnaim_p,tvmassa_p,tvnote_p) AS cnt
FROM
(
SELECT ''Было'' as state,
                 t.t_start,
                 t.t_end,
                 t.tv_doly_b as doly_p,
                 t.tv_naim_b as tvnaim_p,
                 t.tv_massa_b as tvmassa_p,
                 t.tv_note_b as tvnote_p,
                 t.att_auth
       FROM
TABLE( cast (pk_mmk_izms.F_TV(:x1,:x2) as T_TB_IZMS_TV)) t
union all
SELECT ''Стало'' as state,
                 t.t_start,
                 t.t_end,
                 t.tv_doly_s as doly_p,
                 t.tv_naim_s as tvnaim_p,
                 t.tv_massa_s as tvmassa_p,
                 t.tv_note_s as tvnote_p,
                 t.att_auth
       FROM
TABLE(cast(pk_mmk_izms.F_TV(:x3,:x4) as T_TB_IZMS_TV)) t
)a
) WHERE cnt<2
                  order by 1
                  ' using p_rntv,p_rnps,p_rntv,p_rnps;


-- Маршрут
OPEN p_mo FOR '
SELECT
t.dizm,
t.pornom,
pb.rn AS rn_podr_b,
pb.kornaim AS kornaim_b,
vb.kornaim AS korv_b,
ps.kornaim AS kornaim_s,
vs.kornaim AS korv_s,
ps.rn AS rn_podr_s,
pb.kornaim || vb.kornaim as mo_b,
ps.kornaim || vs.kornaim as mo_s,
vnb.NAIM || '' ('' || vb.kornaim || '')''  AS VONAIM_b,
vns.NAIM || '' ('' || vs.kornaim || '')''  AS VONAIM_s,
t.pozmonote_b,
t.pozmonote_s,
t.ARIDMO_B,
t.ARIDMO_S
FROM
TABLE(pk_mmk_izms.F_MO_TV(:x1,:x2 )) t,
--TABLE(pk_mmk_izms.F_MO( :x1,:x2 )) t,
w_mp.tb_podr pb,
w_mp.tb_podr ps,
w_vo.tb_vo vb,
w_vo.tb_vo vs,
w_vo.tb_vo_naim  vnb,
w_vo.tb_vo_naim vns
WHERE
      t.rnpodr_b = pb.rn(+) AND
      t.rnpodr_s = ps.rn(+) AND
      vb.rn(+) = t.rnvo_b AND
      vs.rn(+) = t.rnvo_s and
      vnb.rn(+)=vb.rn and
      vns.rn(+)=vs.rn

ORDER BY t.dizm, pornom'
         USING p_rnps,p_rntv;

IF ssE IN('У','Н') THEN
open p_zag for  'SELECT t.t_start AS dizm,
                        rn_ei_b,
                        rn_ei_s,
                        eb.kornaim AS ei_b,
                        es.kornaim AS ei_s,
                        t.normrash_b,
                        t.normrash_s,
                        t.veszag_b,
                        t.veszag_s,
                        t.koldetzag_b,
                        t.koldetzag_s,
                        t.geomr_sh_s,
                        t.geomr_sh_b,
                        t.geomr_dl_s,
                        t.geomr_dl_b,
                        t.tzagnote_b,
                        t.tzagnote_s,
                        t.vidzag_b,
                        t.vidzag_s,
                        --vb.NAIM AS vbn,
                        --vs.naim AS vsn,
                        vzb.naim_vid AS vzb,
                        vzs.naim_vid AS vzs,
                        t.VIDZAG_b || case when vzb.naim_vid is not null then '' ('' || vzb.naim_vid || '')'' end AS VIDZAG_NAME_B,
                        t.VIDZAG_s || case when vzs.naim_vid is not null then '' ('' || vzs.naim_vid || '')'' end AS VIDZAG_NAME_S,
                        iob.obozn as obozn_b,
                        ios.obozn as obozn_s,
                        (select rn from w_ktsg.v_tv tvb where tvb.rn_ispob=t.rn_ispob_zag_b and rownum<2) as rntv_b,
                        (select rn from w_ktsg.v_tv tvs where tvs.rn_ispob=t.rn_ispob_zag_s and rownum<2) as rntv_s
                   FROM
                        --TABLE(pk_report2.F_GET_IZM_tzag(:x1, :x2)) t
                        table(pk_mmk_izms.f_zag(:x1, :x2) )t
                   left join  w_ei.tb_ei eb on t.rn_ei_b = eb.rn
                   left join  w_ei.tb_ei es on t.rn_ei_s = es.rn
--                   left join  w_ktsg.tb_vid_isp_ob vb on t.rn_vid_ispob_b = vb.rn
--                   left join  w_ktsg.tb_vid_isp_ob vs on t.rn_vid_ispob_s = vs.rn
                   left join w_vidzag.tb_vid_zag vzb on t.vidzag_b = vzb.id_vid
                   left join w_vidzag.tb_vid_zag vzs on t.vidzag_s = vzs.id_vid


                   left join (w_ktsg.v_isp_ob_s_wa  iob

                   join w_ktsg.v_audi ab on   iob.att_arid=ab.att_arid AND
                    ab.att_var=0 and ab.att_arver=0) on iob.rn_ispob=t.rn_ispob_zag_b
                    and t.t_start<ab.att_arend
                    and t.t_start>=ab.att_arstart

                  left join  (w_ktsg.v_isp_ob_s_wa  ios
                  join w_ktsg.v_audi as1 on
                        ios.att_arid=as1.att_arid and
                         as1.att_var=0 and as1.att_arver=0) on ios.rn_ispob=t.rn_ispob_zag_s
                    and t.t_start<as1.att_arend
                    and t.t_start>=as1.att_arstart
              WHERE (rn_ei_b<>rn_ei_s) OR (normrash_b<>normrash_s) OR ( nvl(veszag_b,-1)<>nvl(veszag_s,-1) ) OR ( nvl(koldetzag_b,-1)<>nvl(koldetzag_s,-1) )
                  OR ( nvl(geomr_sh_b,-1)<>nvl(geomr_sh_s,-1) )  OR ( nvl(geomr_dl_b,-1)<>nvl(geomr_dl_s,-1) ) OR ( nvl(tzagnote_b,''@NULL'')<>nvl(tzagnote_s,''@NULL'') )
                  OR ( nvl(rn_ispob_zag_b,-1)<>nvl(rn_ispob_zag_s,-1) ) OR ( nvl(vidzag_b,''@NULL'')<>nvl(vidzag_s,''@NULL'') )
'
                    USING p_rntv,p_rnps;
    ELSE
open p_zag for
'SELECT                  t.t_start AS dizm,
                        nvl(ei.rn,null) AS rn_ei_b,
                        rn_ei_s,
                        ei.kornaim AS ei_b,
                        es.kornaim AS ei_s,
                        nvl(zz.normrash,null)as  normrash_b,
                        t.normrash_s,
                        zz.veszag veszag_b,
                        t.veszag_s,
                        zz.koldetzag koldetzag_b,
                        t.koldetzag_s,
                        t.geomr_sh_s,
                        zz.geomr_sh geomr_sh_b,
                        t.geomr_dl_s,
                        zz.geomr_dl geomr_dl_b,
                        zz.tzagnote tzagnote_b,
                        t.tzagnote_s,
                        zz.vidzag vidzag_b,
                        t.vidzag_s,
                        --vb.NAIM AS vbn,
                        --vs.naim AS vsn,
                        vzbz.naim_vid AS vzb,
                        vzs.naim_vid AS vzs,
                        zz.vidzag  || case when vzbz.naim_vid is not null then '' ('' || vzbz.naim_vid || '')'' end AS VIDZAG_NAME_B,
                        t.VIDZAG_s || case when vzs.naim_vid  is not null then '' ('' || vzs.naim_vid  || '')'' end AS VIDZAG_NAME_S,
                        io.obozn as obozn_b,
                        ios.obozn as obozn_s,
                        (select rn from w_ktsg.v_tv tvb where tvb.rn_ispob=zz.RN_ISPOB_ZAG and rownum<2) as rntv_b,
                        (select rn from w_ktsg.v_tv tvs where tvs.rn_ispob=t.rn_ispob_zag_s and rownum<2) as rntv_s
                   FROM
                        --TABLE(pk_report2.F_GET_IZM_tzag(:x1, :x2)) t
                        table(pk_mmk_izms.f_zag(:x1, :x2) )t
                   left join  w_ei.tb_ei eb on t.rn_ei_b = eb.rn
                   left join  w_ei.tb_ei es on t.rn_ei_s = es.rn
--                   left join  w_ktsg.tb_vid_isp_ob vb on t.rn_vid_ispob_b = vb.rn
--                   left join  w_ktsg.tb_vid_isp_ob vs on t.rn_vid_ispob_s = vs.rn
                   left join w_vidzag.tb_vid_zag vzb on t.vidzag_b = vzb.id_vid
                   left join w_vidzag.tb_vid_zag vzs on t.vidzag_s = vzs.id_vid


                   left join (w_ktsg.v_isp_ob_s_wa  iob

                   join w_ktsg.v_audi ab on   iob.att_arid=ab.att_arid AND
                    ab.att_var=0 and ab.att_arver=0) on iob.rn_ispob=t.rn_ispob_zag_b
                    and t.t_start<ab.att_arend
                    and t.t_start>=ab.att_arstart

                  left join  (w_ktsg.v_isp_ob_s_wa  ios
                  join w_ktsg.v_audi as1 on
                        ios.att_arid=as1.att_arid and
                         as1.att_var=0 and as1.att_arver=0) on ios.rn_ispob= t.rn_ispob_zag_s
                    and t.t_start<as1.att_arend
                    and t.t_start>=as1.att_arstart
                  LEFT JOIN w_ktsg.v0_t_zag_s zz ON t.rn_tv=zz.rn_tv
                   left join w_ei.tb_ei ei on zz.RN_EI = ei.rn
                   left join w_vidzag.tb_vid_zag vzbz on zz.RN_VID_ISPOB_ZAG = vzbz.id_vid
                   left join (w_ktsg.v_isp_ob_s_wa  io
                   join w_ktsg.v_audi a on   io.att_arid=a.att_arid AND
                    a.att_var=0 and a.att_arver=0) on io.rn_ispob=zz.RN_ISPOB_ZAG
                    and t.t_start<a.att_arend
                    and t.t_start>=a.att_arstart
              WHERE (ei.rn<>rn_ei_s) OR (zz.normrash<>normrash_s) OR ( nvl(zz.veszag,-1)<>nvl(veszag_s,-1) ) OR ( nvl(zz.koldetzag,-1)<>nvl(koldetzag_s,-1) )
                  OR ( nvl(zz.geomr_sh,-1)<>nvl(geomr_sh_s,-1) )  OR ( nvl(zz.geomr_dl,-1)<>nvl(geomr_dl_s,-1) ) OR ( nvl(zz.tzagnote,''@NULL'')<>nvl(tzagnote_s,''@NULL''))
                  OR ( nvl(zz.RN_ISPOB_ZAG,-1)<>nvl(rn_ispob_zag_s,-1) ) OR ( nvl(zz.vidzag,''@NULL'')<>nvl(vidzag_s,''@NULL'') )
    ' USING p_rntv,p_rnps;
    END IF ;
/* 'SELECT t.dizm,
                        rn_ei_b,
                        rn_ei_s,
                        eb.kornaim AS ei_b,
                        es.kornaim AS ei_s,
                        t.normrash_b,
                        t.normrash_s,
                        t.veszag_b,
                        t.veszag_s,
                        t.koldetzag_b,
                        t.koldetzag_s,
                        t.geomr_sh_s,
                        t.geomr_sh_b,
                        t.geomr_dl_s,
                        t.geomr_dl_b,
                        t.tzagnote_b,
                        t.tzagnote_s,
                        t.rnispob_b,
                        t.rnispob_s,
                        t.vidzag_b,
                        t.vidzag_s,
                        vb.NAIM AS vbn,
                        vs.naim AS vsn,
                        vzb.naim_vid AS vzb,
                        vzs.naim_vid AS vzs,
                        iob.obozn as obozn_b,
                        ios.obozn as obozn_s,
                        t.VIDZAG_b || case when vzb.naim_vid is not null then '' ('' || vzb.naim_vid || '')'' end AS VIDZAG_NAME_B,
                        t.VIDZAG_s || case when vzs.naim_vid is not null then '' ('' || vzs.naim_vid || '')'' end AS VIDZAG_NAME_S,
                        to_number(tvb.rn) as rntv_b,
                        to_number(tvs.rn) as rntv_s
                   FROM TABLE(pk_report2.F_GET_IZM_tzag(:x1, :x2)) t
                   left join  w_ei.tb_ei eb on t.rn_ei_b = eb.rn
                   left join  w_ei.tb_ei es on t.rn_ei_s = es.rn
                   left join  w_ktsg.tb_vid_isp_ob vb on t.rn_vid_ispob_b = vb.rn
                   left join  w_ktsg.tb_vid_isp_ob vs on t.rn_vid_ispob_s = vs.rn
                   left join w_vidzag.tb_vid_zag vzb on t.vidzag_b = vzb.id_vid
                   left join w_vidzag.tb_vid_zag vzs on t.vidzag_s = vzs.id_vid
                   left join w_ktsg.v_isp_ob_s_wa  iob on iob.rn_ispob=t.rnispob_b
                   LEFT join w_ktsg.v_audi ab on   iob.att_arid=ab.att_arid AND
                    ab.att_var=0 and ab.att_arver=0
                    and t.dizm<ab.att_arend
                    and t.dizm>=ab.att_arstart
                   left join w_ktsg.v_tv tvb on t.rnispob_b=tvb.rn_ispob
                  left join  w_ktsg.v_isp_ob_s_wa  ios  on ios.rn_ispob=t.rnispob_s
                  LEFT join w_ktsg.v_audi as1 on
                        ios.att_arid=as1.att_arid and
                         as1.att_var=0 and as1.att_arver=0
                    and t.dizm<as1.att_arend
                    and t.dizm>=as1.att_arstart
                    left join w_ktsg.v_tv tvs on t.rnispob_s=tvs.rn_ispob

                  ORDER BY t.dizm'  USING p_rnps,p_rntv;
*/
open p_obr FOR '
SELECT p2.*
                    FROM (SELECT t.*,

                                 piip.kornaim AS koriip,
                                 piin.kornaim AS koriin,
                                 pip.kornaim  AS korip,
                                 pin.kornaim  AS korin,
                                 zmo.kornaim  AS zpodr,
                                 zvo.kornaim  AS zvo,
                                 ob.obozn || '' (Вар. изг. '' || tv1.vi || '')''  AS ObrObozn,
                                 tv1.vi       AS ObrVI,
                                 obp.obozn  || '' (Вар. изг. '' || sip.vi || '')''  AS soboznp,
                                 sip.vi       AS vip
                            FROM (SELECT
                                  --v2.0.20060831
                                  --Показывает модификации,
                                  -- внесенные актуальными изменениями таблицы TB_OBR_S
                                   rn_tv_za,
                                   RN_TV_OBR,
                                   ARID_POZMO,
                                   NULL AS T_ACTUAL,
                                   NULL AS T_VAR,
                                   NULL AS T_DIS,
                                   dizm AS T_CorDate,
                                   T_Start AS dizm,
                                   T_End,
                                   --att_ALT,
                                   att_ALTTYPE,
                                   att_AUTH,
                                   att_AUTHTYPE,
                                   rn_podr,
                                   rn_vo,
                                   RN_TV_IZG,
                                   RN_PODR_ISP_B AS RN_PODR_ISP_P,
                                   RN_PODR_ISP_S AS RN_PODR_ISP_N,
                                   RN_PODR_INITTD_B AS RN_PODR_INITTD_P,
                                   RN_PODR_INITTD_S AS RN_PODR_INITTD_N,
                                   TEHNKOL_B AS TEHNKOL_P,
                                   TEHNKOL_S AS TEHNKOL_N,
                                   MAXPART_B AS MAXPART_P,
                                   MAXPART_S AS MAXPART_N,
                                   INFOBRNOTE_B AS INFOBRNOTE_P,
                                   INFOBRNOTE_S AS INFOBRNOTE_N
                                    FROM
                              table(CAST (pk_mmk_izms.f_obr(:x1, :x2) AS t_tb_izms_obr) )
                              )t
                           INNER JOIN(w_ktsg.tb_tv sip
                           INNER JOIN w_ktsg.tb_isp_ob_s obp ON sip.rn_ispob =
                                                                obp.rn_ispob
                           INNER JOIN w_ktsg.tb_audi ap ON obp.att_arid =
                                                           ap.att_arid
                                                       AND ap.att_arver = 0
                                                       AND ap.att_var = 0) ON t.RN_TV_ZA = sip.rn AND t.dizm < ap.att_arend AND t.dizm >= ap.att_arstart
                            LEFT JOIN w_mp.tb_podr pin ON t.RN_PODR_ISP_N =
                                                          pin.rn
                            LEFT JOIN w_mp.tb_podr pip ON t.RN_PODR_ISP_P =
                                                          pip.rn
                            LEFT JOIN w_mp.tb_podr piin ON t.RN_PODR_INITTD_N =
                                                           piin.rn
                            LEFT JOIN w_mp.tb_podr piip ON t.RN_PODR_INITTD_P =
                                                           piip.rn,
                           w_mp.tb_podr zmo,
                           w_vo.tb_vo zvo,
                           w_ktsg.tb_tv tv1,
                           w_ktsg.tb_isp_ob_s ob,
                           w_ktsg.tb_audi a

                           WHERE
                             t.RN_TV_OBR = tv1.rn
                             AND tv1.rn_ispob = ob.rn_ispob
                             AND ob.att_arid = a.att_arid
                             AND a.att_arver = 0
                             AND a.att_var = 0
                             AND t.dizm < a.att_arend
                             AND t.dizm >= a.att_arstart

                             AND zmo.rn = t.rn_podr
                             AND zvo.rn = t.rn_vo) p2

                  --Убираем переподвязку

                   ORDER BY dizm,
                            nvl2(RN_PODR_ISP_P, -1, 1),
                            nvl2(RN_PODR_ISP_N, 1, -1),
                            obrobozn
' USING p_rntv,p_rnps;

OPEN p_sost FOR 'SELECT p2.*,
                         tva.rn AS rntv1
                    FROM (SELECT p.*,
                                 eip.kornaim AS eib,
                                 ein.kornaim AS eis,
                                 io.obozn,
                                 mpr.kornaim AS zex,
                                 vov.kornaim AS vo,
                                 mpr2.kornaim AS zex2,
                                 vov2.kornaim AS vo2,
                                 io.rn_ispob
                            FROM (SELECT
                                  --v2.0.20060831
                                  --Показывает модификации,
                                  -- внесенные актуальными изменениями таблицы TB_UST_COMP_S
                                   RN_POZMO,
                                   RN_ISPOB_CH,
                                   dizm,
                                   t_start,
                                   T_End,
                                   att_ALT,
                                   att_ALTTYPE,
                                   att_AUTH,
                                   att_AUTHTYPE,
                                   RN_TV,
                                   kol_s KOL_N,
                                   KOL_b AS kol_p,
                                   IND1_VARIANT_s AS IND1_VARIANT_N,
                                   IND1_VARIANT_b AS IND1_VARIANT_P,
                                   IND2_NEUST_s AS IND2_NEUST_N,
                                   IND2_NEUST_b AS IND2_NEUST_P,
                                   USTCOMPNOTE_s AS USTCOMPNOTE_N,
                                   USTCOMPNOTE_b AS USTCOMPNOTE_P,
                                   rn_ei_ust_s AS RN_EI_UST_N,
                                   RN_EI_UST_b AS RN_EI_UST_P
                                    --FROM w_ktsg.V_UST_COMP_S_HISTORY t
                                    FROM TABLE(CAST (pk_mmk_izms.F_SOSTAV(:x1,:x2) AS T_TB_IZMS_UST) )
                                    ) p
                            LEFT JOIN(w_ktsg.tb_isp_ob_s io
                           INNER JOIN w_ktsg.tb_audi a ON io.att_arid =
                                                          a.att_arid
                                                      AND a.att_arver = 0
                                                      AND a.att_var = CASE WHEN :x3=0 THEN 0 ELSE
                                                      w_ktsg.f_get_maxv1_ISP_OB(io.RN_ISPOB)
                                                      END  ) ON (p.rn_ispob_ch = io.rn_ispob) AND
                                                      p.dizm < a.att_arend AND dizm >= a.att_arstart
                            LEFT JOIN w_ei.tb_ei eip ON p.RN_EI_UST_P =
                                                        eip.rn
                            LEFT JOIN w_ei.tb_ei ein ON p.RN_EI_UST_N =
                                                        ein.rn
                            LEFT JOIN(w_ktsg.v_poz_mo_s_wa mo
                           INNER JOIN w_mp.tb_podr mpr ON mo.RN_PODR = mpr.rn
                           INNER JOIN w_vo.tb_vo vov ON mo.RN_VO = vov.rn
                           INNER JOIN w_ktsg.tb_audi aa ON mo.att_arid =
                                                           aa.att_arid
                                                       AND aa.att_arver = 0
                                                       AND aa.att_var = CASE WHEN :x4=0 THEN 0 ELSE
                                                       --w_ktsg.f_get_maxv1_pozmo_s(mo.RN_pozmo)
                                                       w_ktsg.f_get_maxv1_pozmo_sd(mo.RN_pozmo,f_get_min_dstart(:x5) - 0.0000058)
                                                       END  ) ON p.rn_pozmo = mo.RN_POZMO AND
                                                       --p.dizm < aa.att_arend AND p.dizm >= aa.att_arstart
                                                       f_get_min_dstart(p.att_auth )  - 0.0000058< aa.att_arend AND f_get_min_dstart(p.att_auth )  - 0.0000058  >= aa.att_arstart
                            LEFT JOIN(w_ktsg.v_poz_mo_s_wa mo2
                           INNER JOIN w_mp.tb_podr mpr2 ON mo2.RN_PODR =
                                                           mpr2.rn
                           INNER JOIN w_vo.tb_vo vov2 ON mo2.RN_VO = vov2.rn
                           INNER JOIN w_ktsg.tb_audi aa2 ON mo2.att_arid =
                                                            aa2.att_arid
                                                        AND aa2.att_arver = 0
                                                        AND aa2.att_var =  CASE WHEN :x6=0 THEN 0 ELSE
                                                        --w_ktsg.f_get_maxv1_pozmo_s(mo2.RN_pozmo)
                                                        w_ktsg.f_get_maxv1_pozmo_sd(mo2.RN_pozmo,f_get_max_dstart(:x7))
                                                         END
                                                        ) ON p.rn_pozmo = mo2.RN_POZMO AND
                                                        --p.dizm < aa2.att_arend AND p.dizm >= aa2.att_arstart
                                                        f_get_max_dstart(p.att_auth )  < aa2.att_arend AND f_get_max_dstart(p.att_auth ) >= aa2.att_arstart
                           ) p2
                    LEFT JOIN w_ktsg.tb_tv tva ON p2.rn_ispob = tva.rn_ispob
                   --отключение неизмененных
                  WHERE ( nvl(kol_p,-1) <> nvl(kol_n,-1) OR nvl(IND1_VARIANT_P,''@NULL'')<>nvl(IND1_VARIANT_N,''@NULL'') OR nvl(IND2_NEUST_P,''@NULL'')<>nvl(IND2_NEUST_N,''@NULL'') OR
                      nvl(ustcompnote_p,''@NULL'')<>nvl(ustcompnote_n,''@NULL'') OR nvl(eib,''@NULL'')<>nvl(eis,''@NULL'')
                      )
                   ORDER BY dizm,
                            nvl2(kol_p, -1, 1),
                            nvl2(kol_n, 1, -1),
                            obozn' USING p_rntv,p_rnps,vVar,vVar,p_rnps,vVar,p_rnps;--,p_rntv,p_rnps,p_rntv,p_rnps;
OPEN p_vhod FOR
'SELECT p.*,
                                 eip.kornaim AS eib,
                                 ein.kornaim AS eis,
                                 io.obozn,
                                 mpr.kornaim AS zex,
                                 vov.kornaim AS vo,
                                 mpr2.kornaim AS zex2,
                                 vov2.kornaim AS vo2,
                                 io.rn_ispob
                            FROM (SELECT
                                  --v2.0.20060831
                                  --Показывает модификации,
                                  -- внесенные актуальными изменениями таблицы TB_UST_COMP_S
                                   RN_POZMO,
                                   RN_ISPOB_CH,
                                   dizm,
                                   t_start,
                                   T_End,
                                   att_ALT,
                                   att_ALTTYPE,
                                   att_AUTH,
                                   att_AUTHTYPE,
                                   RN_TV,
                                   kol_s KOL_N,
                                   KOL_b AS kol_p,
                                   IND1_VARIANT_s AS IND1_VARIANT_N,
                                   IND1_VARIANT_b AS IND1_VARIANT_P,
                                   IND2_NEUST_s AS IND2_NEUST_N,
                                   IND2_NEUST_b AS IND2_NEUST_P,
                                   USTCOMPNOTE_s AS USTCOMPNOTE_N,
                                   USTCOMPNOTE_b AS USTCOMPNOTE_P,
                                   rn_ei_ust_s AS RN_EI_UST_N,
                                   RN_EI_UST_b AS RN_EI_UST_P
FROM TABLE(CAST (pk_mmk_izms.F_VHODIM_UST(:x1,:x2) AS T_TB_IZMS_UST) ) )p
                            LEFT JOIN w_ktsg.tb_tv tv ON p.rn_tv=tv.rn
                            LEFT JOIN(w_ktsg.tb_isp_ob_s io
                           INNER JOIN w_ktsg.tb_audi a ON io.att_arid =
                                                          a.att_arid
                                                      AND a.att_arver = 0
                                                      AND a.att_var = CASE WHEN :x3=0 THEN 0 ELSE
                                                      w_ktsg.f_get_maxv1_ISP_OB(io.RN_ISPOB)
                                                      END  ) ON (tv.rn_ispob = io.rn_ispob) AND
                                                      p.dizm < a.att_arend AND dizm >= a.att_arstart
                            LEFT JOIN w_ei.tb_ei eip ON p.RN_EI_UST_P =
                                                        eip.rn
                            LEFT JOIN w_ei.tb_ei ein ON p.RN_EI_UST_N =
                                                        ein.rn
                            LEFT JOIN(w_ktsg.v_poz_mo_s_wa mo
                           INNER JOIN w_mp.tb_podr mpr ON mo.RN_PODR = mpr.rn
                           INNER JOIN w_vo.tb_vo vov ON mo.RN_VO = vov.rn
                           INNER JOIN w_ktsg.tb_audi aa ON mo.att_arid =
                                                           aa.att_arid
                                                       AND aa.att_arver = 0
                                                       AND aa.att_var = CASE WHEN :x4=0 THEN 0 ELSE
                                                       --w_ktsg.f_get_maxv1_pozmo_s(mo.RN_pozmo)
                                                       w_ktsg.f_get_maxv1_pozmo_sd(mo.RN_pozmo,f_get_min_dstart(:x5) - 0.0000058)
                                                       END  ) ON p.rn_pozmo = mo.RN_POZMO AND
                                                       --p.dizm < aa.att_arend AND p.dizm >= aa.att_arstart
                                                       f_get_min_dstart(p.att_auth )  - 0.0000058< aa.att_arend AND f_get_min_dstart(p.att_auth )  - 0.0000058  >= aa.att_arstart
                            LEFT JOIN(w_ktsg.v_poz_mo_s_wa mo2
                           INNER JOIN w_mp.tb_podr mpr2 ON mo2.RN_PODR =
                                                           mpr2.rn
                           INNER JOIN w_vo.tb_vo vov2 ON mo2.RN_VO = vov2.rn
                           INNER JOIN w_ktsg.tb_audi aa2 ON mo2.att_arid =
                                                            aa2.att_arid
                                                        AND aa2.att_arver = 0
                                                        AND aa2.att_var =  CASE WHEN :x6=0 THEN 0 ELSE
                                                        --w_ktsg.f_get_maxv1_pozmo_s(mo2.RN_pozmo)
                                                        w_ktsg.f_get_maxv1_pozmo_sd(mo2.RN_pozmo,f_get_max_dstart(:x7))
                                                         END
                                                        ) ON p.rn_pozmo = mo2.RN_POZMO AND
                                                        --p.dizm < aa2.att_arend AND p.dizm >= aa2.att_arstart
                                                        f_get_max_dstart(p.att_auth )  < aa2.att_arend AND f_get_max_dstart(p.att_auth ) >= aa2.att_arstart
WHERE ( nvl(kol_p,-1) <> nvl(kol_n,-1) OR nvl(IND1_VARIANT_P,''@NULL'')<>nvl(IND1_VARIANT_N,''@NULL'') OR nvl(IND2_NEUST_P,''@NULL'')<>nvl(IND2_NEUST_N,''@NULL'') OR
                      nvl(ustcompnote_p,''@NULL'')<>nvl(ustcompnote_n,''@NULL'') OR nvl(eip.kornaim,''@NULL'')<>nvl(ein.kornaim,''@NULL'')
)        ORDER BY dizm,
                            nvl2(kol_p, -1, 1),
                            nvl2(kol_n, 1, -1),
                            obozn' USING f_get_isp(p_rntv),p_rnps,vVar,vVar,p_rnps,vVar,p_rnps;

OPEN p_isp FOR'
SELECT * FROM (
SELECT z.*,count(*) over (PARTITION BY obozn_p,tip_ispob_p,PACK_OBOZN_P) AS cnt FROM
(SELECT ''Было'' AS state,rn_ispob,dizm,att_auth,obozn_p,tip_ispob_p,PACK_OBOZN_P,obozn_n,tip_ispob_n,PACK_OBOZN_n FROM 
(SELECT t.* FROM (select
--v2.0.20060831
--Показывает модификации,
-- внесенные актуальными изменениями таблицы TB_ISP_OB_S
       RN_ISPOB,
--       T_ACTUAL,
--       T_VAR,
--       T_DIS,
--       T_CorDate,
       T_Start AS dizm,
--       T_End,
--       att_ALT,
--       att_ALTTYPE,
       att_AUTH,
--       att_AUTHTYPE,
--       att_ARID,
--       OBJTYPE,
       NVL2(T_DIS,null,OBOZN) as "OBOZN_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,OBOZN)) OVER(partition by RN_ISPOB order by T_Start)
       end as "OBOZN_P",
       NVL2(T_DIS,null,TIP_ISPOB) as "TIP_ISPOB_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,TIP_ISPOB)) OVER(partition by RN_ISPOB order by T_Start)
       end as "TIP_ISPOB_P",
       NVL2(T_DIS,null,PACK_OBOZN) as "PACK_OBOZN_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,PACK_OBOZN)) OVER(partition by RN_ISPOB order by T_Start)
       end as "PACK_OBOZN_P"
from w_ktsg.V_ISP_OB_S_HISTORY
 WHERE rn_ispob = :x1) t
                  WHERE t.att_auth = :x2
                  ORDER BY t.dizm) WHERE ROWNUM <2
UNION ALL
SELECT ''Стало'',rn_ispob,dizm,att_auth,obozn_n,tip_ispob_n,PACK_OBOZN_n,obozn_n,tip_ispob_n,PACK_OBOZN_n FROM 
(SELECT t.* FROM (select
--v2.0.20060831
--Показывает модификации,
-- внесенные актуальными изменениями таблицы TB_ISP_OB_S
       RN_ISPOB,
--       T_ACTUAL,
--       T_VAR,
--       T_DIS,
--       T_CorDate,
       T_Start AS dizm,
--       T_End,
--       att_ALT,
--       att_ALTTYPE,
       att_AUTH,
--       att_AUTHTYPE,
--       att_ARID,
--       OBJTYPE,
       NVL2(T_DIS,null,OBOZN) as "OBOZN_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,OBOZN)) OVER(partition by RN_ISPOB order by T_Start)
       end as "OBOZN_P",
       NVL2(T_DIS,null,TIP_ISPOB) as "TIP_ISPOB_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,TIP_ISPOB)) OVER(partition by RN_ISPOB order by T_Start)
       end as "TIP_ISPOB_P",
       NVL2(T_DIS,null,PACK_OBOZN) as "PACK_OBOZN_N",
       case when LAG(T_End) OVER(partition by RN_ISPOB order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,PACK_OBOZN)) OVER(partition by RN_ISPOB order by T_Start)
       end as "PACK_OBOZN_P"
from w_ktsg.V_ISP_OB_S_HISTORY
 WHERE rn_ispob = :x3) t
                  WHERE t.att_auth = :x4
                  ORDER BY t.dizm DESC) WHERE ROWNUM <2
)                  
 z ) WHERE cnt<2
ORDER BY 1                  
' USING f_get_isp(p_rntv),p_rnps,f_get_isp(p_rntv),p_rnps;
-- Технологическая добавка
IF ssE IN('У','Н') THEN
OPEN p_td FOR 'SELECT rn_tv,
                        att_arid,
                        dizm,
                        korii,
                        arid_p,
                        arid_n,
                        f_get_tehndob_string(arid_p) as td_p,
                        f_get_tehndob_string(arid_n) as td_n,
                        TEHNDOB_P,
                        TEHNDOB_N,
                        TEHNKOL_P,
                        TEHNKOL_N,
                        MAXPART_P,
                        MAXPART_N,
                        MINPART_P,
                        MINPART_N,
                        RN_PODR_ISP_P,
                        RN_PODR_ISP_N,
                        kornaim,
                        korv,
                        pornom || '' '' ||kornaim || '' '' || korv as poz,
                        pkor,
                        nkor,
                        IND_SADKA_P,
                        IND_SADKA_N,
                        tehndobnote_p,
                        tehndobnote_n,
                        rn_pozmo
                   FROM (SELECT a.rn_tv,
                   pm.pornom,
                                 att_arid,
                                 td_arid_b AS arid_p,
                                 td_arid_s AS arid_n,
                                 dizm,
                                 pii.kornaim AS korii,
                                 TEHNDOB_B AS TEHNDOB_P,
                                 TEHNDOB_N,
                                 TEHNKOL_B AS TEHNKOL_P,
                                 TEHNKOL_S AS TEHNKOL_N,
                                 MAXPART_b AS MAXPART_P,
                                 MAXPART_s AS MAXPART_N,
                                 MINPART_b AS MINPART_P,
                                 MINPART_s AS MINPART_N,
                                 RN_PODR_ISP_b AS RN_PODR_ISP_p,
                                 RN_PODR_ISP_s AS RN_PODR_ISP_n,
                                 mop.kornaim,
                                 mov.kornaim korv,
                                 pp.kornaim AS pkor,
                                 pn.kornaim AS nkor,
                                 IND_SADKA_b AS IND_SADKA_p,
                                 IND_SADKA_s AS IND_SADKA_n,
                                 tehndobnote_b AS tehndobnote_p,
                                 tehndobnote_s AS tehndobnote_n,
                                 a.rn_pozmo
                            FROM (select * FROM table(pk_mmk_izms.F_TD(:x1,:x2,0))) a
                                   JOIN w_ktsg.v_poz_mo_b mo ON
                                          a.ARID_POZMO = mo.att_ARID
                                          --AND a.T_VAR = 0
                                          and mo.att_var=0 and mo.att_arver=0
                                     and t_start<mo.att_arend
                                     and t_start>=mo.att_arstart
                                   JOIN w_vo.tb_vo mov ON mo.rn_vo = mov.rn
                                   JOIN w_mp.tb_podr mop ON mo.rn_podr=mop.rn

                                   JOIN w_mp.tb_podr pii ON a.RN_PODR_INITTD = pii.rn

                                   LEFT JOIN w_mp.tb_podr pn ON a.rn_podr_isp_s = pn.rn
                                   left JOIN w_mp.tb_podr pp ON a.RN_PODR_ISP_B = pp.rn

                                 JOIN w_ktsg.tb_poz_mo pm ON a.rn_pozmo=pm.rn
)
                  ORDER BY pornom, dizm, att_arid' USING p_rntv,p_rnps;
ELSE
OPEN p_td FOR 'SELECT rn_tv,
                        att_arid,
                        dizm,
                        korii,
                        arid_p,
                        arid_n,
                        f_get_tehndob_string(arid_p) as td_p,
                        f_get_tehndob_string(arid_n) as td_n,
                        TEHNDOB_P,
                        TEHNDOB_N,
                        TEHNKOL_P,
                        TEHNKOL_N,
                        MAXPART_P,
                        MAXPART_N,
                        MINPART_P,
                        MINPART_N,
                        RN_PODR_ISP_P,
                        RN_PODR_ISP_N,
                        kornaim,
                        korv,
                        pornom || '' '' ||kornaim || '' '' || korv as poz,
                        pkor,
                        nkor,
                        IND_SADKA_P,
                        IND_SADKA_N,
                        tehndobnote_p,
                        tehndobnote_n,
                        rn_pozmo
                   FROM (SELECT a.rn_tv,
                                 pm.pornom,
                                 att_arid,
                                 td_arid_b AS arid_p,
                                 td_arid_s AS arid_n,
                                 dizm,
                                 pii.kornaim AS korii,
                                 TEHNDOB_B AS TEHNDOB_P,
                                 TEHNDOB_N,
                                 TEHNKOL_B AS TEHNKOL_P,
                                 TEHNKOL_S AS TEHNKOL_N,
                                 MAXPART_b AS MAXPART_P,
                                 MAXPART_s AS MAXPART_N,
                                 MINPART_b AS MINPART_P,
                                 MINPART_s AS MINPART_N,
                                 RN_PODR_ISP_b AS RN_PODR_ISP_p,
                                 RN_PODR_ISP_s AS RN_PODR_ISP_n,
                                 mop.kornaim,
                                 mov.kornaim korv,
                                 pp.kornaim AS pkor,
                                 pn.kornaim AS nkor,
                                 IND_SADKA_b AS IND_SADKA_p,
                                 IND_SADKA_s AS IND_SADKA_n,
                                 tehndobnote_b AS tehndobnote_p,
                                 tehndobnote_s AS tehndobnote_n,
                                 a.rn_pozmo
                            FROM (select * FROM table(pk_mmk_izms.F_TD(:x1,:x2,1))) a
                                   JOIN w_ktsg.v_poz_mo_b mo ON
                                          a.ARID_POZMO = mo.att_ARID
                                          --AND a.T_VAR = 0
                                          and mo.att_var=0 and mo.att_arver=0
                                     and t_start<mo.att_arend
                                     and t_start>=mo.att_arstart
                                   JOIN w_vo.tb_vo mov ON mo.rn_vo = mov.rn
                                   JOIN w_mp.tb_podr mop ON mo.rn_podr=mop.rn

                                   JOIN w_mp.tb_podr pii ON a.RN_PODR_INITTD = pii.rn

                                   LEFT JOIN w_mp.tb_podr pn ON a.rn_podr_isp_s = pn.rn
                                   left JOIN w_mp.tb_podr pp ON a.RN_PODR_ISP_B = pp.rn

                                 JOIN w_ktsg.tb_poz_mo pm ON a.rn_pozmo=pm.rn
                                 -- Если был вариант 0
                                 --LEFT JOIN w_ktsg.v0_tehn_dob_s tdt ON a.arid_pozmo=tdt.arid_pozmo AND a.rn_podr_inittd = tdt.RN_PODR_INITTD
                                 --Отдел испытатель после в0
                                 --left JOIN w_mp.tb_podr pp0 ON tdt.RN_PODR_ISP = pp0.rn
                                 
)
                  ORDER BY pornom, dizm, att_arid' USING p_rntv,p_rnps;
END IF;
END;
PROCEDURE    p_td(p_arid IN NUMBER,
                                       p_DATE IN VARCHAR2,
                                       p_old IN VARCHAR2 DEFAULT NULL,
                                       p_td out curtyp)
                                       AS
                                       pd DATE;
                                       i INTEGER;
                                       BEGIN
                                       pd:=to_date(p_date,'DD.MM.YYYY HH24:MI:SS');
IF p_old IS NULL THEN
SELECT
COUNT(*) INTO i
FROM
w_ktsg.v_tehn_dob_b  tdb
WHERE  tdb.att_var=0 AND tdb.att_arver=0
AND pd - 0.0000058<tdb.att_arend
and pd - 0.0000058>=tdb.att_arstart
and tdb.arid_pozmo=p_arid;
IF TRUE THEN
  OPEN p_td FOR '
  SELECT
  F_GET_TEHNDOB_STRING(tdb.att_arid) AS TEHNDOBSTRING
  FROM
  w_ktsg.v_tehn_dob_b  tdb
  WHERE  tdb.att_var=0 AND tdb.att_arver=0
  AND :x1<tdb.att_arend
  and :x2>=tdb.att_arstart
  and tdb.arid_pozmo=:x3
  '
  USING                 pd - 0.0000058,pd - 0.0000058,p_arid;
END IF;
ELSE
SELECT
COUNT(*) INTO i
 FROM
w_ktsg.v_tehn_dob_b  tdb
WHERE  tdb.att_var=0 AND tdb.att_arver=0
AND pd<tdb.att_arend
and pd>=tdb.att_arstart
and tdb.arid_pozmo=p_arid;
IF TRUE THEN
    OPEN p_td FOR '
    SELECT
    F_GET_TEHNDOB_STRING(tdb.att_arid) AS TEHNDOBSTRING
     FROM
    w_ktsg.v_tehn_dob_b  tdb
    WHERE  tdb.att_var=0 AND tdb.att_arver=0
    AND :x1<tdb.att_arend
    and :x2>=tdb.att_arstart
    and tdb.arid_pozmo=:x3
    '
    USING                 pd,pd,p_arid;
END IF;

END IF;
                                       END;

--**************************************************************
PROCEDURE    p_matizm(p_rnmat IN NUMBER,
                                       p_psh out curtyp) AS
BEGIN
-- Список изменений в разработке где используется данный материал - для согласования со 112 отделом
open p_psh for
'select distinct ps.NOMIZM,ps.OSNOVANIE,io.obozn,b.name_full,
case
     when instr(subject_of_audit,'' '')=0 then
     subject_of_audit
else
substr(subject_of_audit,
                                       1,

                                       instr(subject_of_audit, '' '')) ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '') + 1,
                                       1) || ''.'' ||
                                substr(subject_of_audit,
                                       instr(subject_of_audit, '' '', 1, 2) + 1,
                                       1) || ''.''
                                       end AS SOA,
ps.IND_STEXIST,ps.DT_IZMSTEXIST,p.SHORTNAME ||'' - '' || p.FULLNAME as TNAME,nvl(ps.isp_zadel,-1) as isp_zadel,ps.srok_vnedr,
ps.psnote,ps.rn,
(select count(distinct t1.rn_tv) from mv_persogl_tv t1 where t1.rn_persogl=t.rn) as cnt_tv,
(select count(distinct t1.rn_ispob) from mv_persogl_tv t1 where t1.rn_persogl=t.rn)as cnt_io
from
w_ktsg.v_isp_ob t
join w_ktsg.v0_isp_ob_s io on t.rn=io.rn_ispob
JOIN v_select_mat b ON t.RN_MAT=b.RN
JOIN w_ktsg.v1_t_zag_s z ON t.rn=z.RN_ISPOB_ZAG
JOIN w_ktsg.v_izm_tv it ON z.RN_TV=it.rn_tv
JOIN w_ktsg.v_per_sogl ps ON it.rn_persogl=ps.rn
join w_osnov.tb_typedoc p on ps.rn_typedoc=p.RN
left join w_ad.v_subject_of_audit a on ps.RN_SOTR_AVT=a.GUID
WHERE t.rn_mat= :x1
AND ps.ind_stexist=''Р''
' USING p_rnmat;
end;
--**************************************************************
PROCEDURE    p_matizmdce(p_rnps IN number,
                                                    p_rnmat IN NUMBER,
                                                    p_dce out curtyp) AS
BEGIN
--Изменения
open p_dce for 'select   t.obozn,t1.VI,t1.RN
from
mv_persogl_tv p
join w_ktsg.v0_isp_ob_s t on t.rn_ispob=p.rn_ispob
left join w_ktsg.v_tv t1 on p.rn_Tv=t1.RN
join w_ktsg.v1_t_zag_s z on p.rn_tv=z.rn_tv
join w_ktsg.v_isp_ob ob on ob.rn=z.rn_ispob_zag
where
      p.rn_persogl=:x1
      and ob.rn_mat=:x2
' USING p_rnps,p_rnmat;
end;
--**************************************************************
PROCEDURE p_rel_cursor(p_cur IN CURtyp) AS
BEGIN
          CLOSE p_cur;
END;
END PK_MMK_INFO_R;
/

----------------------------------------
--  Changed package body pk_mmk_izms  --
----------------------------------------
CREATE OR REPLACE PACKAGE BODY W_MMKT.PK_MMK_IZMS IS
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Какие изменения над ДСЕ происходили за период
   FUNCTION F_IZMS(p_dstart IN DATE,
                   p_dend   IN DATE) RETURN t_TB_IZMS_IZMS
      PIPELINED IS
      vTmp t_IZMS_IZMS;
   BEGIN
      vTmp := t_IZMS_IZMS(NULL);
      FOR c IN (SELECT --+star
                DISTINCT att_auth
                  FROM v_persogl_dcorr t
                 WHERE t.att_artsc >= p_dstart
                   AND t.att_artsc < p_dend) LOOP
         vTmp.att_auth := c.att_auth;
         PIPE ROW(vTmp);
      END LOOP;
      RETURN;
   END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Заготовка

   FUNCTION F_ZAG(p_rntv IN NUMBER,
                  p_rnps IN NUMBER,
                  p_razr IN NUMBER DEFAULT 0) RETURN T_TB_IZMS_ZAG
      PIPELINED IS
   BEGIN
      IF p_razr = 0 THEN
         FOR c IN (SELECT CAST(MULTISET
                               (SELECT NULL AS arid_b,
                                       NULL AS arid_s,
                                       t.rn_tv,
                                       NULL AS att_auth,
                                       NULL AS att_authtype,
                                       NULL AS att_alt,
                                       NULL AS att_alttype,
                                       NULL AS t_cordate,
                                       t.dizm AS t_start,
                                       NULL AS t_end,
                                       rnispob_b,
                                       rnispob_s,
                                       rn_ei_b,
                                       rn_ei_s,
                                       t.normrash_b,
                                       t.normrash_s,
                                       t.vidzag_b,
                                       t.vidzag_s,
                                       t.koldetzag_b,
                                       t.koldetzag_s,
                                       t.veszag_b,
                                       t.veszag_s,                                       
                                       t.geomr_dl_b,
                                       t.geomr_dl_s,                                       
                                       t.geomr_sh_b,
                                       t.geomr_sh_s,
                                       t.tzagnote_b,
                                       t.tzagnote_s
                                  FROM TABLE(pk_report2.F_GET_IZM_tzag2(p_rnps,
                                                                        p_rntv)) t) AS
                               T_TB_IZMS_ZAG) AS dt
                     FROM dual) LOOP
            IF c.dt.COUNT <> 0 THEN
               FOR i IN c.dt.FIRST .. c.dt.LAST LOOP
                  PIPE ROW(c.dt(i));
               END LOOP;
            END IF;
         END LOOP;
      ELSIF p_razr = 1 THEN
         NULL;
      END IF;
      RETURN;
   
   END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   --Функция которая отрображает изменение ИспОба

   FUNCTION F_ISP(p_rnISP IN NUMBER,
                  p_rnps  IN NUMBER) RETURN T_TB_IZMS_ISP
      PIPELINED IS
   
      STRISP T_IZMS_ISP := T_IZMS_ISP(NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
   
   BEGIN
   
      SELECT RN_ISPOB, -- OBOZN_N,
             OBOZN_P,
             --TIP_ISPOB_N,
             TIP_ISPOB_P,
             dizm,
             dend,
             T_CorDate,
             att_ALT,
             att_ALTTYPE,
             att_AUTH,
             att_AUTHTYPE,
             NULL --, null
      
        INTO strisp.rn_ispob,
             STRISP.obozn_B, --STRISP.obozn_S, 
             strisp.tip_ispob_B, --strisp.tip_ispob_S,
             strisp.t_start,
             strisp.t_end,
             strisp.t_cordate,
             strisp.att_alt,
             strisp.att_alttype,
             Strisp.att_auth,
             strisp.att_authtype,
             strisp.att_arid_B --, strisp.att_arid_S
      
        FROM (SELECT *
                FROM (SELECT RN_ISPOB,
                             T_Start AS dizm,
                             T_End AS DEND,
                             T_CorDate,
                             att_ALT,
                             att_ALTTYPE,
                             att_AUTH,
                             att_AUTHTYPE,
                             NVL2(T_DIS, NULL, OBOZN) AS "OBOZN_N",
                             CASE
                                WHEN LAG(T_End)
                                 OVER(PARTITION BY RN_ISPOB ORDER BY
                                          T_Start) < T_Start THEN
                                 NULL
                                ELSE
                                 LAG(NVL2(T_DIS, NULL, OBOZN))
                                 OVER(PARTITION BY RN_ISPOB ORDER BY T_Start)
                             END AS "OBOZN_P",
                             NVL2(T_DIS, NULL, TIP_ISPOB) AS "TIP_ISPOB_N",
                             CASE
                                WHEN LAG(T_End)
                                 OVER(PARTITION BY RN_ISPOB ORDER BY
                                          T_Start) < T_Start THEN
                                 NULL
                                ELSE
                                 LAG(NVL2(T_DIS, NULL, TIP_ISPOB))
                                 OVER(PARTITION BY RN_ISPOB ORDER BY T_Start)
                             END AS "TIP_ISPOB_P",
                             NVL2(T_DIS, NULL, PACK_OBOZN) AS "PACK_OBOZN_N",
                             CASE
                                WHEN LAG(T_End)
                                 OVER(PARTITION BY RN_ISPOB ORDER BY
                                          T_Start) < T_Start THEN
                                 NULL
                                ELSE
                                 LAG(NVL2(T_DIS, NULL, PACK_OBOZN))
                                 OVER(PARTITION BY RN_ISPOB ORDER BY T_Start)
                             END AS "PACK_OBOZN_P"
                        FROM w_ktsg.V_ISP_OB_S_HISTORY o
                       WHERE rn_ispob = p_rnISP) t
               WHERE t.att_auth = p_rnps
              
               ORDER BY t.dizm
              
              )
       WHERE rownum = 1;
   
      SELECT RN_ISPOB,
             OBOZN_N, --OBOZN_P, 
             TIP_ISPOB_N, --TIP_ISPOB_P,
             dizm,
             dend,
             T_CorDate,
             att_ALT,
             att_ALTTYPE,
             att_AUTH,
             att_AUTHTYPE,
             --  null,
             NULL
      
        INTO strisp.rn_ispob, --STRISP.obozn_B, 
             STRISP.obozn_S, --strisp.tip_ispob_B,
             strisp.tip_ispob_S,
             strisp.t_start,
             strisp.t_end,
             strisp.t_cordate,
             strisp.att_alt,
             strisp.att_alttype,
             Strisp.att_auth,
             strisp.att_authtype, --strisp.att_arid_B, 
             strisp.att_arid_S
      
        FROM (SELECT *
                FROM (SELECT RN_ISPOB,
                             T_Start AS dizm,
                             T_End AS DEND,
                             T_CorDate,
                             att_ALT,
                             att_ALTTYPE,
                             att_AUTH,
                             att_AUTHTYPE,
                             NVL2(T_DIS, NULL, OBOZN) AS "OBOZN_N",
                             CASE
                                WHEN LAG(T_End)
                                 OVER(PARTITION BY RN_ISPOB ORDER BY
                                          T_Start) < T_Start THEN
                                 NULL
                                ELSE
                                 LAG(NVL2(T_DIS, NULL, OBOZN))
                                 OVER(PARTITION BY RN_ISPOB ORDER BY T_Start)
                             END AS "OBOZN_P",
                             NVL2(T_DIS, NULL, TIP_ISPOB) AS "TIP_ISPOB_N",
                             CASE
                                WHEN LAG(T_End)
                                 OVER(PARTITION BY RN_ISPOB ORDER BY
                                          T_Start) < T_Start THEN
                                 NULL
                                ELSE
                                 LAG(NVL2(T_DIS, NULL, TIP_ISPOB))
                                 OVER(PARTITION BY RN_ISPOB ORDER BY T_Start)
                             END AS "TIP_ISPOB_P",
                             NVL2(T_DIS, NULL, PACK_OBOZN) AS "PACK_OBOZN_N",
                             CASE
                                WHEN LAG(T_End)
                                 OVER(PARTITION BY RN_ISPOB ORDER BY
                                          T_Start) < T_Start THEN
                                 NULL
                                ELSE
                                 LAG(NVL2(T_DIS, NULL, PACK_OBOZN))
                                 OVER(PARTITION BY RN_ISPOB ORDER BY T_Start)
                             END AS "PACK_OBOZN_P"
                        FROM w_ktsg.V_ISP_OB_S_HISTORY o
                       WHERE rn_ispob = p_rnISP) t
               WHERE t.att_auth = p_rnps
               ORDER BY t.dizm DESC
              
              )
       WHERE rownum = 1;
   
      PIPE ROW(STRISP);
   
      RETURN;
   
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         BEGIN
            NULL;
            RETURN;
         END;
      
   END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- ТВ
   FUNCTION F_TV(p_rntv IN NUMBER,
                 p_rnps IN NUMBER) RETURN T_TB_IZMS_TV
      PIPELINED IS
   
      STRISP T_IZMS_TV := T_IZMS_TV(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
   
   BEGIN
   
      SELECT RN_TV,
             att_AUTH,
             att_AUTHTYPE,
             att_ALT,
             att_ALTTYPE,
             T_CorDate,
             dizm,
             T_End,
             arid_b,
             DOLY_P,
             TVNAIM_P,
             TVMASSA_P,
             TVNOTE_P
        INTO STRISP.TV_RN_TV,
             STRISP.att_AUTH,
             STRISP.att_AUTHTYPE,
             STRISP.att_ALT,
             STRISP.att_ALTTYPE,
             STRISP.T_CorDate,
             STRISP.T_Start,
             STRISP.T_End,
             STRISP.TV_ARID_B,
             STRISP.TV_DOLY_B,
             STRISP.TV_NAIM_B,
             STRISP.TV_MASSA_B,
             STRISP.TV_NOTE_B
      
        FROM (SELECT t.*
                FROM (SELECT
                      --v2.0.20060831
                      --Показывает модификации,
                      -- внесенные актуальными изменениями таблицы TB_TV_S
                       RN_TV,
                       att_AUTH,
                       att_AUTHTYPE,
                       att_ALT,
                       att_ALTTYPE,
                       T_CorDate,
                       T_Start AS dizm,
                       T_End,
                       att_ARID AS arid_b,
                       att_arid AS arid_s,
                       CASE
                          WHEN LAG(T_End) OVER(PARTITION BY RN_TV ORDER BY
                                    T_Start) < T_Start THEN
                           NULL
                          ELSE
                           LAG(NVL2(T_DIS, NULL, DOLY))
                           OVER(PARTITION BY RN_TV ORDER BY T_Start)
                       END AS "DOLY_P",
                       NVL2(T_DIS, NULL, DOLY) AS "DOLY_N",
                       CASE
                          WHEN LAG(T_End) OVER(PARTITION BY RN_TV ORDER BY
                                    T_Start) < T_Start THEN
                           NULL
                          ELSE
                           LAG(NVL2(T_DIS, NULL, TVNAIM))
                           OVER(PARTITION BY RN_TV ORDER BY T_Start)
                       END AS "TVNAIM_P",
                       NVL2(T_DIS, NULL, TVNAIM) AS "TVNAIM_N",
                       
                       CASE
                          WHEN LAG(T_End) OVER(PARTITION BY RN_TV ORDER BY
                                    T_Start) < T_Start THEN
                           NULL
                          ELSE
                           LAG(NVL2(T_DIS, NULL, TVMASSA))
                           OVER(PARTITION BY RN_TV ORDER BY T_Start)
                       END AS "TVMASSA_P",
                       NVL2(T_DIS, NULL, TVMASSA) AS "TVMASSA_N",
                       CASE
                          WHEN LAG(T_End) OVER(PARTITION BY RN_TV ORDER BY
                                    T_Start) < T_Start THEN
                           NULL
                          ELSE
                           LAG(NVL2(T_DIS, NULL, TVNOTE))
                           OVER(PARTITION BY RN_TV ORDER BY T_Start)
                       END AS "TVNOTE_P",
                       NVL2(T_DIS, NULL, TVNOTE) AS "TVNOTE_N"
                        FROM w_ktsg.V_TV_S_HISTORY
                       WHERE rn_tv = p_rntv) t
               WHERE t.att_auth = p_rnps
              
               ORDER BY t.dizm
              
              )
       WHERE rownum < 2;
   
      SELECT RN_TV,
             att_AUTH,
             att_AUTHTYPE,
             att_ALT,
             att_ALTTYPE,
             T_CorDate,
             dizm,
             T_End,
             arid_b,
             DOLY_N,
             TVNAIM_N,
             TVMASSA_N,
             TVNOTE_N
        INTO STRISP.TV_RN_TV,
             STRISP.att_AUTH,
             STRISP.att_AUTHTYPE,
             STRISP.att_ALT,
             STRISP.att_ALTTYPE,
             STRISP.T_CorDate,
             STRISP.T_Start,
             STRISP.T_End,
             STRISP.TV_ARID_S,
             STRISP.TV_DOLY_S,
             STRISP.TV_NAIM_S,
             STRISP.TV_MASSA_S,
             STRISP.TV_NOTE_S
        FROM (SELECT t.*
                FROM (SELECT
                      --v2.0.20060831
                      --Показывает модификации,
                      -- внесенные актуальными изменениями таблицы TB_TV_S
                       RN_TV,
                       att_AUTH,
                       att_AUTHTYPE,
                       att_ALT,
                       att_ALTTYPE,
                       T_CorDate,
                       T_Start AS dizm,
                       T_End,
                       att_ARID AS arid_b,
                       att_arid AS arid_s,
                       CASE
                          WHEN LAG(T_End) OVER(PARTITION BY RN_TV ORDER BY
                                    T_Start) < T_Start THEN
                           NULL
                          ELSE
                           LAG(NVL2(T_DIS, NULL, DOLY))
                           OVER(PARTITION BY RN_TV ORDER BY T_Start)
                       END AS "DOLY_P",
                       NVL2(T_DIS, NULL, DOLY) AS "DOLY_N",
                       CASE
                          WHEN LAG(T_End) OVER(PARTITION BY RN_TV ORDER BY
                                    T_Start) < T_Start THEN
                           NULL
                          ELSE
                           LAG(NVL2(T_DIS, NULL, TVNAIM))
                           OVER(PARTITION BY RN_TV ORDER BY T_Start)
                       END AS "TVNAIM_P",
                       NVL2(T_DIS, NULL, TVNAIM) AS "TVNAIM_N",
                       
                       CASE
                          WHEN LAG(T_End) OVER(PARTITION BY RN_TV ORDER BY
                                    T_Start) < T_Start THEN
                           NULL
                          ELSE
                           LAG(NVL2(T_DIS, NULL, TVMASSA))
                           OVER(PARTITION BY RN_TV ORDER BY T_Start)
                       END AS "TVMASSA_P",
                       NVL2(T_DIS, NULL, TVMASSA) AS "TVMASSA_N",
                       CASE
                          WHEN LAG(T_End) OVER(PARTITION BY RN_TV ORDER BY
                                    T_Start) < T_Start THEN
                           NULL
                          ELSE
                           LAG(NVL2(T_DIS, NULL, TVNOTE))
                           OVER(PARTITION BY RN_TV ORDER BY T_Start)
                       END AS "TVNOTE_P",
                       NVL2(T_DIS, NULL, TVNOTE) AS "TVNOTE_N"
                        FROM w_ktsg.V_TV_S_HISTORY
                       WHERE rn_tv = p_rntv) t
               WHERE t.att_auth = p_rnps
              
               ORDER BY t.dizm DESC
              
              )
       WHERE rownum < 2;
      PIPE ROW(strisp);
      RETURN;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN;
      
   END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Изменения маршрута - только измененные позиции
   FUNCTION F_MO(p_rntv IN NUMBER,
                 p_rnps IN NUMBER) RETURN T_TB_IZMS_MO
      PIPELINED IS
      STRISP T_IZMS_MO := T_IZMS_MO(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
   BEGIN
      FOR c IN (SELECT p.*, count(*) over (PARTITION BY rn_pozmo) AS cnt, rank() over (PARTITION BY rn_pozmo ORDER BY att_arid_s) AS rnum
                               FROM (SELECT
                                     --v2.0.20060831
                                     --Показывает модификации,
                                     -- внесенные актуальными изменениями таблицы TB_POZ_MO_S
                                      RN_POZMO,
                                      
                                      t.RN_TV,
                                      att_AUTH,
                                      att_AUTHTYPE,
                                      att_ALT,
                                      att_ALTTYPE,
                                      mp.pornom AS pornom,
                                      T_CorDate,
                                      T_Start AS dizm,
                                      T_End,
                                      CASE
                                         WHEN LAG(T_End)
                                          OVER(PARTITION BY RN_POZMO ORDER BY
                                                   T_Start) < T_Start THEN
                                          NULL
                                         ELSE
                                          LAG(NVL2(T_DIS, NULL, att_arid))
                                          OVER(PARTITION BY RN_POZMO ORDER BY
                                               T_Start)
                                      END AS att_arid_P ,

                                      att_ARID AS att_arid_s,
                                      CASE
                                         WHEN LAG(T_End)
                                          OVER(PARTITION BY RN_POZMO ORDER BY
                                                   T_Start) < T_Start THEN
                                          NULL
                                         ELSE
                                          LAG(NVL2(T_DIS, NULL, RN_PODR))
                                          OVER(PARTITION BY RN_POZMO ORDER BY
                                               T_Start)
                                      END AS "RN_PODR_P",
                                      NVL2(T_DIS, NULL, RN_PODR) AS "RN_PODR_N",
                                      CASE
                                         WHEN LAG(T_End)
                                          OVER(PARTITION BY RN_POZMO ORDER BY
                                                   T_Start) < T_Start THEN
                                          NULL
                                         ELSE
                                          LAG(NVL2(T_DIS, NULL, RN_VO))
                                          OVER(PARTITION BY RN_POZMO ORDER BY
                                               T_Start)
                                      END AS "RN_VO_P",
                                      NVL2(T_DIS, NULL, RN_VO) AS "RN_VO_N",
                                      CASE
                                         WHEN LAG(T_End)
                                          OVER(PARTITION BY RN_POZMO ORDER BY
                                                   T_Start) < T_Start THEN
                                          NULL
                                         ELSE
                                          LAG(NVL2(T_DIS, NULL, POZMONOTE))
                                          OVER(PARTITION BY RN_POZMO ORDER BY
                                               T_Start)
                                      END AS "POZMONOTE_P",
                                      NVL2(T_DIS, NULL, POZMONOTE) AS "POZMONOTE_N"

                                       FROM w_ktsg.V_POZ_MO_S_HISTORY t
                                      JOIN w_ktsg.tb_poz_mo mp ON t.rn_pozmo=mp.rn
                                       
                                      WHERE t.rn_Tv = p_rntv) p
                              WHERE p.att_AUTH = p_rnps
                              ORDER BY rn_pozmo
) LOOP
         IF c.cnt <> 1 THEN
            IF c.rnum=1 THEN
         strisp.RN_POZMO:=c.rn_pozmo;
         strisp.RN_TV:=c.rn_tv;
         strisp.att_AUTH:=c.att_auth;
         strisp.att_AUTHTYPE:=c.att_authtype;
         strisp.att_ALT:=c.att_alt;
         strisp.att_ALTTYPE:=c.att_alttype;
         strisp.pornom:=c.pornom;
         strisp.dizm:=c.dizm;
         strisp.T_Start:=c.dizm;
         strisp.T_End:=c.t_end;
         strisp.ARIDmo_B:=c.att_arid_p;
         strisp.RNPODR_b:=c.rn_podr_p;
         strisp.RNVO_b:=c.rn_vo_p;
         strisp.POZMONOTE_b:=c.pozmonote_p;               
            END IF;
            IF c.cnt=c.rnum AND c.rn_pozmo=strisp.RN_POZMO THEN
                     strisp.ARIDmo_S:=c.att_arid_s;
         strisp.RNPODR_s:=c.rn_podr_n;
         strisp.RNVO_s:=c.rn_vo_n;
         strisp.POZMONOTE_s:=c.pozmonote_n;

                        PIPE ROW(strisp);            
            END IF;
         ELSE 
         -- Если одна запись
         strisp.RN_POZMO:=c.rn_pozmo;
         strisp.RN_TV:=c.rn_tv;
         strisp.att_AUTH:=c.att_auth;
         strisp.att_AUTHTYPE:=c.att_authtype;
         strisp.att_ALT:=c.att_alt;
         strisp.att_ALTTYPE:=c.att_alttype;
         strisp.pornom:=c.pornom;
         strisp.dizm:=c.dizm;
         strisp.T_Start:=c.dizm;
         strisp.T_End:=c.t_end;
         strisp.ARIDmo_B:=c.att_arid_p;
         strisp.ARIDmo_S:=c.att_arid_s;
         strisp.RNPODR_b:=c.rn_podr_p;
         strisp.RNPODR_s:=c.rn_podr_n;
         strisp.RNVO_b:=c.rn_vo_p;
         strisp.RNVO_s:=c.rn_vo_n;
         strisp.POZMONOTE_b:=c.pozmonote_p;
         strisp.POZMONOTE_s:=c.pozmonote_n;
         PIPE ROW(strisp);
         END IF;
      END LOOP;
      RETURN;
   END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Изменения маршрута - все позиции
   FUNCTION F_MO_TV(p_prich IN NUMBER,
                            p_rntv  IN NUMBER) RETURN t_tb_izms_mo
      PIPELINED IS
      tmp t_izms_mo := T_IZMS_MO(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
      cur DATE;
      dizm DATE;
   BEGIN
      cur := w_ktsg.pk_values.CURDATE;
         --Измененные позиции
         --Вывести поля
         FOR k IN (SELECT p.pornom,
                          t.rn_pozmo,
                          t.rnpodr_s,
                          t.rnpodr_b,
                          t.rnvo_b,
                          t.rnvo_s,
                          t.pozmonote_b,
                          t.pozmonote_s,
                          t.aridmo_b,
                          t.aridmo_s,
                          t.dizm
                     FROM w_ktsg.tb_poz_mo p,
                          TABLE(pk_mmk_izms.F_MO(p.rn_tv,p_prich )) t
                    WHERE p.rn_tv = p_rntv
                      AND p.rn = t.rn_pozmo) LOOP
            tmp.dizm        := k.dizm;
            tmp.pornom      := k.pornom;
            tmp.rn_pozmo    := k.rn_pozmo;
            tmp.rn_tv       := p_rntv;
            tmp.rnpodr_b    := k.rnpodr_b;
            tmp.rnpodr_s    := k.rnpodr_s;
            tmp.rnvo_b      := k.rnvo_b;
            tmp.rnvo_s      := k.rnvo_s;
            tmp.pozmonote_b := k.pozmonote_b;
            tmp.pozmonote_s := k.pozmonote_s;
            tmp.aridmo_b    := k.aridmo_b;
            tmp.aridmo_s    := k.aridmo_s;
            PIPE ROW(tmp);
         END LOOP;
         dizm:=tmp.dizm;
         w_ktsg.pk_values.set_curdate(tmp.dizm);
         FOR r IN (SELECT
                          p3.pornom,
                          t3.rn_pozmo,
                          t3.rn_vo,
                          t3.pozmonote,
                          t3.rn_podr,
                          t3.att_arid
                     FROM w_ktsg.tb_poz_mo p3, w_ktsg.v0_poz_mo_s t3
                    WHERE p3.rn_tv = p_rntv
                      AND p3.rn = t3.RN_POZMO
                      AND p3.pornom IN
                          (SELECT p.pornom
                             FROM w_ktsg.tb_poz_mo p, w_ktsg.v0_poz_mo_s t
                            WHERE p.rn_tv = p_rntv
                              AND t.RN_POZMO = p.rn
                           MINUS
                           SELECT DISTINCT p.pornom
                             FROM w_ktsg.tb_poz_mo p,
                          TABLE(pk_mmk_izms.F_MO(p.rn_tv,p_prich )) t2                             
                            WHERE p.rn_tv = p_rntv
                              AND p.rn = t2.rn_pozmo
                              )) LOOP
            --Не измененные позиции
            tmp.dizm        := dizm;
            tmp.pornom      := r.pornom;
            tmp.rn_pozmo    := r.rn_pozmo;
            tmp.rn_tv       := p_rntv;
            tmp.rnpodr_b    := r.rn_podr;
            tmp.rnpodr_s    := r.rn_podr;
            tmp.rnvo_b      := r.rn_vo;
            tmp.rnvo_s      := r.rn_vo;
            tmp.pozmonote_b := r.POZMONOTE;
            tmp.pozmonote_s := r.pozmonote;
            tmp.aridmo_b    := r.att_arid;
            tmp.aridmo_s    := r.att_arid;
            PIPE ROW(tmp);
         END LOOP;
      w_ktsg.pk_values.SET_CURDATE(cur);
      RETURN;
   END;  
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Изменения маршрута - все позиции даже если нет изменений
   FUNCTION F_MO_TV_ALL(p_prich IN NUMBER,
                            p_rntv  IN NUMBER) RETURN t_tb_izms_mo
      PIPELINED IS   
      tmp t_izms_mo := T_IZMS_MO(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
      cur DATE;
      dizm DATE;
   BEGIN
      cur := w_ktsg.pk_values.CURDATE;
         --Измененные позиции
         --Вывести поля
         dizm:=NULL;
         FOR k IN (SELECT p.pornom,
                          t.rn_pozmo,
                          t.rnpodr_s,
                          t.rnpodr_b,
                          t.rnvo_b,
                          t.rnvo_s,
                          t.pozmonote_b,
                          t.pozmonote_s,
                          t.aridmo_b,
                          t.aridmo_s,
                          t.dizm
                     FROM w_ktsg.tb_poz_mo p,
                          TABLE(pk_mmk_izms.F_MO(p.rn_tv,p_prich )) t
                    WHERE p.rn_tv = p_rntv
                      AND p.rn = t.rn_pozmo) LOOP
            tmp.dizm        := k.dizm;
            tmp.pornom      := k.pornom;
            tmp.rn_pozmo    := k.rn_pozmo;
            tmp.rn_tv       := p_rntv;
            tmp.rnpodr_b    := k.rnpodr_b;
            tmp.rnpodr_s    := k.rnpodr_s;
            tmp.rnvo_b      := k.rnvo_b;
            tmp.rnvo_s      := k.rnvo_s;
            tmp.pozmonote_b := k.pozmonote_b;
            tmp.pozmonote_s := k.pozmonote_s;
            tmp.aridmo_b    := k.aridmo_b;
            tmp.aridmo_s    := k.aridmo_s;
            PIPE ROW(tmp);
         dizm:=tmp.dizm;
         END LOOP;
         IF dizm IS NULL THEN
                BEGIN
                 SELECT att_arstart 
                 INTO dizm 
                 FROM w_ktsg.tb_audi a 
                 WHERE a.att_auth=p_prich AND rownum<2
                 AND a.att_objtype<>1000 AND a.att_var=0;
                EXCEPTION 
                  WHEN NO_DATA_FOUND THEN NULL;  
                END;  
         END IF;
         w_ktsg.pk_values.set_curdate(dizm);
         FOR r IN (SELECT
                          p3.pornom,
                          t3.rn_pozmo,
                          t3.rn_vo,
                          t3.pozmonote,
                          t3.rn_podr,
                          t3.att_arid
                     FROM w_ktsg.tb_poz_mo p3, w_ktsg.v0_poz_mo_s t3
                    WHERE p3.rn_tv = p_rntv
                      AND p3.rn = t3.RN_POZMO
                      AND p3.pornom IN
                          (SELECT p.pornom
                             FROM w_ktsg.tb_poz_mo p, w_ktsg.v0_poz_mo_s t
                            WHERE p.rn_tv = p_rntv
                              AND t.RN_POZMO = p.rn
                           MINUS
                           SELECT DISTINCT p.pornom
                             FROM w_ktsg.tb_poz_mo p,
                          TABLE(pk_mmk_izms.F_MO(p.rn_tv,p_prich )) t2                             
                            WHERE p.rn_tv = p_rntv
                              AND p.rn = t2.rn_pozmo
                              )) LOOP
            --Не измененные позиции
            tmp.dizm        := dizm;
            tmp.pornom      := r.pornom;
            tmp.rn_pozmo    := r.rn_pozmo;
            tmp.rn_tv       := p_rntv;
            tmp.rnpodr_b    := r.rn_podr;
            tmp.rnpodr_s    := r.rn_podr;
            tmp.rnvo_b      := r.rn_vo;
            tmp.rnvo_s      := r.rn_vo;
            tmp.pozmonote_b := r.POZMONOTE;
            tmp.pozmonote_s := r.pozmonote;
            tmp.aridmo_b    := r.att_arid;
            tmp.aridmo_s    := r.att_arid;
            PIPE ROW(tmp);
         END LOOP;
      w_ktsg.pk_values.SET_CURDATE(cur);
      RETURN;
   END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
--Технологическая добавка - на РН_ПОЗ_МО
--Выдает Ариды ТД Было и стало по указанному Документу
--Входные параметры АРИД_ПОЗМО_С Было и СТало!!
FUNCTION F_TD_ALL (p_rntv IN NUMBER, p_rnps IN NUMBER, 
p_ARIDPOZMOS_B IN number,p_ARIDPOZMOS_S IN number, P_RN_POZMO IN NUMBER) RETURN  T_TB_IZMS_TD_ALL
PIPELINED IS
STRSP_TD T_IZMS_TD_ALL:=T_IZMS_TD_ALL(NULL,NULL,NULL,NULL,NULL);
TMP_Val  DATE;
tmp_PS_DAt DATE :=NULL;
Is_pipe NUMBER;
BEGIN
--Старая дата актуальности
tmp_val := w_ktsg.pk_values.CURDATE;
is_pipe:=0;
--Установка даты от ПС
  BEGIN
                 SELECT att_arstart 
                 INTO tmp_PS_DAt
                 FROM w_ktsg.tb_audi a 
                 WHERE a.att_auth=p_rnps AND rownum<2
                 AND a.att_objtype<>1000 AND a.att_var=0;
                EXCEPTION 
                  WHEN NO_DATA_FOUND THEN NULL;  
  END;  
         w_ktsg.pk_values.set_curdate(tmp_PS_DAt);
   --Если Ариды разные то получаем на дату документа БЫЛО и СТало ТД 
   --по указанным аридам ПОЗМОС
   IF nvl(p_ARIDPOZMOS_B,0)<>nvl(p_ARIDPOZMOS_S,0) THEN
   
FOR sp_TDARID IN(
SELECT MO.RN_TV, MO.PORNOM, MO.RN,ATDB1.ATT_ARID_b,ATDB2.ATT_ARID_S
FROM w_ktsg.tb_poz_mo mo
   LEFT OUTER JOIN (SELECT rn_pOZMO,ATT_ARID AS ATT_ARID_b, ROWNUM AS rnb FROM 
   (SELECT mb1.RN_POZMO, TB1.att_ARID FROM w_ktsg.v0_poz_mo_s Mb1, w_kTSG.V0_Tehn_Dob_s tB1
   WHERE MB1.att_ARID = p_ARIDPOZMOS_B AND TB1.ARID_POZMO = MB1.att_ARID
   ORDER BY TB1.att_ARID) )aTDb1 ON (aTDB1.rn_pOZMO = MO.RN)
     LEFT OUTER JOIN (SELECT rn_pOZMO,ATT_ARID AS ATT_ARID_s, ROWNUM AS rns FROM 
     (SELECT mb2.RN_POZMO, TB2.att_ARID FROM w_ktsg.v0_poz_mo_s Mb2, w_kTSG.V0_Tehn_Dob_s tB2
     WHERE MB2.att_ARID = p_ARIDPOZMOS_S AND TB2.ARID_POZMO = MB2.att_ARID
     ORDER BY TB2.att_ARID) )aTDb2 ON (aTDB2.rn_pOZMO = MO.RN AND ATDB2.RNS = ATDB1.RNB)
WHERE Mo.Rn = P_RN_POZMO AND NOT (ATDB1.ATT_ARID_b IS NULL AND ATDB2.ATT_ARID_S IS NULL)
UNION
SELECT MO.RN_TV, MO.PORNOM, MO.RN,ATDB1.ATT_ARID_b,ATDB2.ATT_ARID_S
FROM w_ktsg.tb_poz_mo mo
     LEFT OUTER JOIN (SELECT rn_pOZMO,ATT_ARID AS ATT_ARID_s, ROWNUM AS rns FROM 
     (SELECT mb2.RN_POZMO, TB2.att_ARID FROM w_ktsg.v0_poz_mo_s Mb2, w_kTSG.V0_Tehn_Dob_s tB2
     WHERE MB2.att_ARID = p_ARIDPOZMOS_S AND TB2.ARID_POZMO = MB2.att_ARID
     ORDER BY TB2.att_ARID) )aTDb2 ON (aTDB2.rn_pOZMO = MO.RN )
   LEFT OUTER JOIN (SELECT rn_pOZMO,ATT_ARID AS ATT_ARID_b, ROWNUM AS rnb FROM 
   (SELECT mb1.RN_POZMO, TB1.att_ARID FROM w_ktsg.v0_poz_mo_s Mb1, w_kTSG.V0_Tehn_Dob_s tB1
   WHERE MB1.att_ARID = p_ARIDPOZMOS_B AND TB1.ARID_POZMO = MB1.att_ARID
   ORDER BY TB1.att_ARID) )aTDb1 ON (aTDB1.rn_pOZMO = MO.RN AND  ATDB1.RNB =ATDB2.RNS)
WHERE Mo.Rn = P_RN_POZMO AND NOT (ATDB1.ATT_ARID_b IS NULL AND ATDB2.ATT_ARID_S IS NULL)
                )
LOOP
is_pipe:=1;
STRSP_TD.RN_TV:=SP_TDARID.RN_TV;
STRSP_TD.pornum:=SP_TDARID.PORNOM;
STRSP_TD.rn_pozmo:=SP_TDARID.RN;
STRSP_TD.TD_ARID_B:=sp_tdarid.att_arid_b;
STRSP_TD.TD_ARID_S:=sp_tdarid.att_arid_S;
 PIPE ROW(STRSP_TD);
END LOOP;                
   ELSE
   --Иначе для БЫЛО СП всех ARID ТД на указанный Арид ПОЗМОС
   --MINUS F_TD arid_S
   --UNION ALL F_TD Arid_B
   --для Стало просто все АРИДЫ на дату ПС

FOR SP_TDARID IN(
SELECT MO.RN_TV, MO.PORNOM, MO.RN,ATDB1.ATT_ARID_b,ATDB2.ATT_ARID_S
FROM w_ktsg.tb_poz_mo mo
LEFT OUTER JOIN 
(SELECT RN_POZMO, att_ARID_B, ROWNUM AS RNB FROM
(SELECT mb1.RN_POZMO,tb1.att_ARID AS att_ARID_B FROM w_ktsg.v0_poz_mo_s Mb1, w_ktsg.v0_tehn_dob_s tb1 WHERE mb1.att_ARID = p_ARIDPOZMOS_B AND tb1.ARID_POZMO = mb1.att_ARID
   MINUS 
   SELECT q.rn_pozmo, q.TD_ARID_S FROM table(cast(pk_mmk_izms.F_TD(p_rntv,p_rnps) AS  T_TB_IZMS_TD ))  q WHERE q.rn_pozmo =P_RN_POZMO        
   UNION ALL
   SELECT q.rn_pozmo, q.TD_ARID_B FROM table(CAST(pk_mmk_izms.F_TD(p_rntv,p_rnps ) AS  T_TB_IZMS_TD)) q WHERE q.rn_pozmo =P_RN_POZMO
)ORDER BY att_ARID_B
)aTDb1 ON (aTDb1.RN_POZMO = mo.rn)
LEFT OUTER JOIN 
(SELECT RN_POZMO, att_ARID_S, ROWNUM AS RNS FROM
(  SELECT a.rn_pozmo,b.att_ARID as att_ARID_S, ROWNUM
  FROM w_ktsg.v0_poz_mo_s a, w_ktsg.v0_tehn_dob_s b WHERE a.rn_pozmo = P_RN_POZMO AND b.ARID_POZMO = a.att_arid
  ORDER BY b.att_ARID
))atDb2 ON (aTDb2.RN_POZMO = mo.rn AND aTDb2.RNS = aTDb1.RNB)
WHERE Mo.Rn = P_RN_POZMO AND NOT (ATDB1.ATT_ARID_b IS NULL AND ATDB2.ATT_ARID_S IS NULL)
UNION
SELECT MO.RN_TV, MO.PORNOM, MO.RN,ATDB1.ATT_ARID_b,ATDB2.ATT_ARID_S
FROM w_ktsg.tb_poz_mo mo
LEFT OUTER JOIN 
(SELECT RN_POZMO, att_ARID_S, ROWNUM AS RNS FROM
(  SELECT a.rn_pozmo,b.att_ARID as att_ARID_S, ROWNUM
  FROM w_ktsg.v0_poz_mo_s a, w_ktsg.v0_tehn_dob_s b WHERE a.rn_pozmo = P_RN_POZMO AND b.ARID_POZMO = a.att_arid
  ORDER BY b.att_ARID
))atDb2 ON (aTDb2.RN_POZMO = mo.rn )
LEFT OUTER JOIN 
(SELECT RN_POZMO, att_ARID_B, ROWNUM AS RNB FROM
(SELECT mb1.RN_POZMO,tb1.att_ARID AS att_ARID_B FROM w_ktsg.v0_poz_mo_s Mb1, w_ktsg.v0_tehn_dob_s tb1 WHERE mb1.att_ARID = p_ARIDPOZMOS_B AND tb1.ARID_POZMO = mb1.att_ARID
   MINUS 
   SELECT q.rn_pozmo, q.TD_ARID_S FROM TABLE (CAST(pk_mmk_izms.F_TD(p_rntv,p_rnps) AS   T_TB_IZMS_TD)) q WHERE q.rn_pozmo =P_RN_POZMO        
   UNION ALL
   SELECT q.rn_pozmo, q.TD_ARID_B FROM TABLE(CAST(pk_mmk_izms.F_TD(p_rntv,p_rnps ) AS  T_TB_IZMS_TD)) q WHERE q.rn_pozmo =P_RN_POZMO
)ORDER BY att_ARID_B
)aTDb1 ON (aTDb1.RN_POZMO = mo.rn AND  aTDb1.RNB=aTDb2.RNS)
WHERE Mo.Rn = P_RN_POZMO AND NOT (ATDB1.ATT_ARID_b IS NULL AND ATDB2.ATT_ARID_S IS NULL)
           )
LOOP
is_pipe:=1;
STRSP_TD.RN_TV:=SP_TDARID.RN_TV;
STRSP_TD.pornum:=SP_TDARID.PORNOM;
STRSP_TD.rn_pozmo:=SP_TDARID.RN;
STRSP_TD.TD_ARID_B:=sp_tdarid.att_arid_b;
STRSP_TD.TD_ARID_S:=sp_tdarid.att_arid_S;
 PIPE ROW(STRSP_TD);
END LOOP;           


   END IF;   
IF is_pipe = 0 THEN
STRSP_TD.RN_TV:=p_rntv;
STRSP_TD.pornum:=NULL; --не используется
STRSP_TD.rn_pozmo:=P_RN_POZMO;
STRSP_TD.TD_ARID_B:=NULL;
STRSP_TD.TD_ARID_S:=NULL;
 PIPE ROW(STRSP_TD);
END IF;   

w_ktsg.pk_values.Set_CURDATE(TMP_Val);
RETURN;
END;
   
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Технологическая(и не только) добавка
   
   FUNCTION F_TD(p_rntv IN NUMBER,
                  p_rnps IN NUMBER,
                  p_razr IN NUMBER DEFAULT 0) RETURN T_TB_IZMS_TD
      PIPELINED IS
      STRISP T_IZMS_TD := T_IZMS_TD(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL
                                    );
  fst BOOLEAN:=TRUE;
  nskip BOOLEAN:=TRUE;
  vAridPozmo NUMBER:=-1;
  vPODR_INIT NUMBER:=-1;
  fAridPozmo NUMBER:=-1;
  fPODR_INIT NUMBER:=-1;
  fAridByl   NUMBER:=1;
  fAridSt   NUMBER:=1;
   BEGIN  
   FOR r IN (
   SELECT CAST(MULTISET
                               (
   SELECT a.rn_tv,
                   pm.pornom,
                   pm.rn,
                                 a.att_arid,
                                 a.rn_podr_inittd,
                                 decode(p_razr,1,nvl(ARID_P,tdt.att_arid),arid_p) AS arid_p,
                                 arid_N,
                                 att_auth,
                                 att_authtype,                                 
                                 att_alt,
                                 att_alttype,
                                 dizm,
                                 t_start,
                                 t_end,
--                                 a.korii,                                 
                                 decode(p_razr,1,nvl2(arid_p,TEHNDOB_P,tdt.TEHNDOB),TEHNDOB_P) AS TEHNDOB_P,
                                 TEHNDOB_N,
                                 decode(p_razr,1,nvl2(arid_p,TEHNKOL_P,tdt.tehnkol),tehnkol_P) AS TEHNKOL_P,
                                 TEHNKOL_N,
                                 decode(p_razr,1,nvl2(arid_p,MAXPART_P,tdt.MAXPART),maxpart_P) AS MAXPART_P,
                                 MAXPART_N,
                                 decode(p_razr,1,nvl2(arid_p,MINPART_P,tdt.minpart),minpart_P) AS MINPART_P,
                                 MINPART_N,
                                 decode(p_razr,1,nvl2(arid_p,RN_PODR_ISP_P,tdt.rn_podr_isp),RN_PODR_ISP_P) AS RN_PODR_ISP_P,
                                 RN_PODR_ISP_N,
                                 decode(p_razr,1,nvl2(arid_p,IND_SADKA_P,tdt.IND_SADKA),IND_SADKA_P) AS IND_SADKA_P,
                                 IND_SADKA_N,
                                 decode(p_razr,1,nvl2(arid_p,tehndobnote_p,tdt.TEHNDOBNOTE),tehndobnote_p) AS tehndobnote_p,
                                 tehndobnote_n
                            FROM (SELECT --

                                   mo1.rn_tv,
                                   mo1.att_arid,
                                   t.RN_PODR_INITTD,
                                   pii.kornaim AS korii,
                                   t.T_End,
                                   t.t_start,
                                   t.t_cordate AS dizm,
                                   t.att_auth,
                                   t.att_authtype,
                                   t.att_alt,
                                   t.att_alttype,                                 
                                   p.kornaim,                                   
                                   v.kornaim AS korv,
                                   mo1.RN_POZMO,
                                   NVL2(t.T_DIS, NULL, t.att_arid) as arid_N,
CASE
                                      WHEN LAG(t.T_End)
                                       OVER(PARTITION BY ARID_POZMO,
                                                RN_PODR_INITTD ORDER BY
                                                t.T_Start) < t.T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(t.T_DIS, NULL, t.att_arid))
                                       OVER(PARTITION BY ARID_POZMO,
                                            RN_PODR_INITTD ORDER BY t.T_Start)
                                   END AS "ARID_P",

                                   NVL2(t.T_DIS, NULL, TEHNDOB) AS "TEHNDOB_N",
                                   CASE
                                      WHEN LAG(t.T_End)
                                       OVER(PARTITION BY ARID_POZMO,
                                                RN_PODR_INITTD ORDER BY
                                                t.T_Start) < t.T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(t.T_DIS, NULL, TEHNDOB))
                                       OVER(PARTITION BY ARID_POZMO,
                                            RN_PODR_INITTD ORDER BY t.T_Start)
                                   END AS "TEHNDOB_P",
                                   NVL2(t.T_DIS, NULL, TEHNKOL) AS "TEHNKOL_N",
                                   CASE
                                      WHEN LAG(t.T_End)
                                       OVER(PARTITION BY ARID_POZMO,
                                                RN_PODR_INITTD ORDER BY
                                                t.T_Start) < t.T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(t.T_DIS, NULL, TEHNKOL))
                                       OVER(PARTITION BY ARID_POZMO,
                                            RN_PODR_INITTD ORDER BY t.T_Start)
                                   END AS "TEHNKOL_P",
                                   NVL2(t.T_DIS, NULL, MAXPART) AS "MAXPART_N",
                                   CASE
                                      WHEN LAG(t.T_End)
                                       OVER(PARTITION BY ARID_POZMO,
                                                RN_PODR_INITTD ORDER BY
                                                t.T_Start) < t.T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(t.T_DIS, NULL, MAXPART))
                                       OVER(PARTITION BY ARID_POZMO,
                                            RN_PODR_INITTD ORDER BY t.T_Start)
                                   END AS "MAXPART_P",
                                   NVL2(t.T_DIS, NULL, MINPART) AS "MINPART_N",
                                   CASE
                                      WHEN LAG(t.T_End)
                                       OVER(PARTITION BY ARID_POZMO,
                                                RN_PODR_INITTD ORDER BY
                                                t.T_Start) < t.T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(t.T_DIS, NULL, MINPART))
                                       OVER(PARTITION BY ARID_POZMO,
                                            RN_PODR_INITTD ORDER BY t.T_Start)
                                   END AS "MINPART_P",
                                   NVL2(t.T_DIS, NULL, RN_PODR_ISP) AS "RN_PODR_ISP_N",
                                   CASE
                                      WHEN LAG(t.T_End)
                                       OVER(PARTITION BY ARID_POZMO,
                                                RN_PODR_INITTD ORDER BY
                                                t.T_Start) < t.T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(t.T_DIS, NULL, RN_PODR_ISP))
                                       OVER(PARTITION BY ARID_POZMO,
                                            RN_PODR_INITTD ORDER BY t.T_Start)
                                   END AS "RN_PODR_ISP_P",
                                   NVL2(t.T_DIS, NULL, IND_SADKA) AS "IND_SADKA_N",
                                   CASE
                                      WHEN LAG(t.T_End)
                                       OVER(PARTITION BY ARID_POZMO,
                                                RN_PODR_INITTD ORDER BY
                                                t.T_Start) < t.T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(t.T_DIS, NULL, IND_SADKA))
                                       OVER(PARTITION BY ARID_POZMO,
                                            RN_PODR_INITTD ORDER BY t.T_Start)
                                   END AS "IND_SADKA_P",
                                   NVL2(t.T_DIS, NULL, TEHNDOBNOTE) AS "TEHNDOBNOTE_N",
                                   CASE
                                      WHEN LAG(t.T_End)
                                       OVER(PARTITION BY ARID_POZMO,
                                                RN_PODR_INITTD ORDER BY
                                                t.T_Start) < t.T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(t.T_DIS, NULL, TEHNDOBNOTE))
                                       OVER(PARTITION BY ARID_POZMO,
                                            RN_PODR_INITTD ORDER BY t.T_Start)
                                   END AS "TEHNDOBNOTE_P"

                                    FROM w_mp.tb_podr                pii,
                                         w_vo.tb_vo                  v,
                                         w_mp.tb_podr                p,
                                         w_ktsg.V_TEHN_DOB_S_HISTORY t,
                                         w_ktsg.v_poz_mo_b          mo1

                                   WHERE t.RN_PODR_INITTD = pii.rn
                                     AND -- иниц испыт
                                         mo1.rn_vo = v.rn
                                     AND -- вид обр поз
                                         mo1.rn_podr = p.rn
                                     AND -- подр поз
                                         t.ARID_POZMO = mo1.att_ARID
                                     AND t.T_VAR = p_razr
                                     and mo1.att_var=0 and mo1.att_arver=0
                                     --AND pk_audi.IsActual(mo1.att_arid,t_start)>0
                                     and t_start<mo1.att_arend
                                     and t_start>=mo1.att_arstart

                                     AND mo1.RN_TV = p_rntv) a,
                                 w_mp.tb_podr pn,
                                 w_mp.tb_podr pp,
                                 w_ktsg.tb_poz_mo pm,
                                 w_ktsg.v0_tehn_dob_s tdt 
                           WHERE 
                               a.rn_pozmo=pm.rn 
                           AND a.RN_PODR_ISP_P = pp.rn(+)
                           AND a.rn_podr_isp_N = pn.rn(+)
                           AND a.att_AUTH = p_rnps
                           AND a.att_arid=tdt.ARID_POZMO(+) 
                           AND a.rn_podr_inittd=tdt.RN_PODR_INITTD(+)
                           ORDER BY att_arid,rn_podr_inittd,t_start
                             ) AS
                               T_TB_IZMS_td) AS dt
                     FROM dual) LOOP
/*      IF r.dt.COUNT <> 0 THEN
         FOR i IN r.dt.FIRST .. r.dt.LAST LOOP
            PIPE ROW(r.dt(i));
         END LOOP;
      END IF;
*/                     
      IF r.dt.COUNT <> 0 THEN
         FOR i IN r.dt.FIRST .. r.dt.LAST LOOP
             IF vAridPozmo<>r.dt(i).Arid_pozmo OR vPODR_INIT<>r.dt(i).RN_PODR_INITTD THEN
                IF fAridPozmo<>-1 THEN
                   IF fAridByl IS NULL AND fAridSt IS NULL THEN
                      --Не выдавать запись
                      nskip:=FALSE;
                   END IF;
                END IF;
                -- Первый раз запись
                fAridPozmo:=r.dt(i).Arid_pozmo;
                fPODR_INIT:=r.dt(i).RN_PODR_INITTD;
                fAridByl:=r.dt(i).TD_ARID_B;                
                IF nskip THEN
                   IF NOT fst THEN
                      PIPE ROW(strisp);
                   END IF;
                ELSE
                   nskip:=TRUE;
                END IF;                                
             END IF;
            vAridPozmo:=r.dt(i).Arid_pozmo;
            vPODR_INIT:=r.dt(i).RN_PODR_INITTD;
            fAridSt:=r.dt(i).TD_ARID_S;
            STRISP:=r.dt(i);
            fst:=FALSE;
         END LOOP;
--Последняя запись         
            IF fAridPozmo<>-1 THEN
                   IF fAridByl IS NULL AND fAridSt IS NULL THEN
                      --Не выдавать запись
                      nskip:=FALSE;
                   END IF;
                END IF;         
        IF nskip THEN
           IF NOT fst THEN
              PIPE ROW(strisp);
           END IF;
        ELSE
           nskip:=TRUE;
        END IF;                                
      END IF;
     END LOOP;
     RETURN;
END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Состав
   FUNCTION F_SOSTAV(p_rntv IN NUMBER,
                 p_rnps IN NUMBER) RETURN T_TB_IZMS_UST
      PIPELINED IS
      STRISP T_IZMS_UST := T_IZMS_UST(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
       vRn_Mo NUMBER:=-1;
       vIsp_ch NUMBER:=-1;
       fst BOOLEAN:=TRUE;
   BEGIN
        FOR r IN (SELECT p.*
                               FROM (SELECT
                                  --v2.0.20060831
                                  --Показывает модификации,
                                  -- внесенные актуальными изменениями таблицы TB_UST_COMP_S
                                   RN_POZMO,
                                   RN_ISPOB_CH,
                                   att_AUTH,
                                   att_AUTHTYPE,
                                   att_ALT,
                                   att_ALTTYPE,
                                   T_start AS dizm,
                                   T_Start ,
                                   T_End,

                                   att_ARID,
                                   att_ARID AS att_arid_s,
                                   RN_TV,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_POZMO,
                                                RN_ISPOB_CH ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, KOL))
                                       OVER(PARTITION BY RN_POZMO,
                                            RN_ISPOB_CH ORDER BY T_Start)
                                   END AS "KOL_P",
                                   NVL2(T_DIS, NULL, KOL) AS "KOL_N",
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_POZMO,
                                                RN_ISPOB_CH ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, IND1_VARIANT))
                                       OVER(PARTITION BY RN_POZMO,
                                            RN_ISPOB_CH ORDER BY T_Start)
                                   END AS "IND1_VARIANT_P",
                                   NVL2(T_DIS, NULL, IND1_VARIANT) AS "IND1_VARIANT_N",
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_POZMO,
                                                RN_ISPOB_CH ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, IND2_NEUST))
                                       OVER(PARTITION BY RN_POZMO,
                                            RN_ISPOB_CH ORDER BY T_Start)
                                   END AS "IND2_NEUST_P",
                                   NVL2(T_DIS, NULL, IND2_NEUST) AS "IND2_NEUST_N",
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_POZMO,
                                                RN_ISPOB_CH ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, USTCOMPNOTE))
                                       OVER(PARTITION BY RN_POZMO,
                                            RN_ISPOB_CH ORDER BY T_Start)
                                   END AS "USTCOMPNOTE_P",
                                   NVL2(T_DIS, NULL, USTCOMPNOTE) AS "USTCOMPNOTE_N",
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_POZMO,
                                                RN_ISPOB_CH ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, RN_EI_UST))
                                       OVER(PARTITION BY RN_POZMO,
                                            RN_ISPOB_CH ORDER BY T_Start)
                                   END AS "RN_EI_UST_P",
                                   NVL2(T_DIS, NULL, RN_EI_UST) AS "RN_EI_UST_N"
                                    FROM w_ktsg.V_UST_COMP_S_HISTORY t
                                   WHERE t.RN_TV = p_rntv) p
                              WHERE p.att_AUTH = p_rnps
                              ORDER BY rn_ispob_ch,rn_pozmo,dizm
                              ) LOOP
                                IF vRN_mo<>r.rn_pozmo OR vIsp_ch<>r.rn_ispob_ch THEN
                                   IF NOT fst THEN
                                      PIPE ROW(strisp);
                                   END IF;
                                   strisp.RN_POZMO:=r.rn_pozmo;
                                   strisp.RN_ISPOB_CH:=r.rn_ispob_ch;
                                   strisp.kol_b:=r.kol_p;
                                   strisp.IND1_VARIANT_b:=r.IND1_VARIANT_P;
                                   strisp.IND2_NEUST_b:=r.IND2_NEUST_P;
                                   strisp.USTCOMPNOTE_b:=r.USTCOMPNOTE_P;
                                   strisp.RN_EI_UST_b:=r.RN_EI_UST_P;

                                   strisp.att_AUTH:=r.att_auth;
                                   strisp.att_AUTHTYPE:=r.att_authtype;
                                   --strisp.att_ALT:=r.att_alt;
                                   strisp.att_ALTTYPE:=r.att_alttype;
                                   strisp.rn_tv:=r.rn_tv;
                                END IF;
                                   strisp.dizm:=r.dizm;
                                   strisp.T_Start:=r.t_start;
                                   strisp.T_End:=r.t_end;
                                   strisp.kol_s:=r.kol_n;
                                   strisp.IND1_VARIANT_s:=r.IND1_VARIANT_n;
                                   strisp.IND2_NEUST_s:=r.IND2_NEUST_n;
                                   strisp.USTCOMPNOTE_s:=r.USTCOMPNOTE_n;
                                   strisp.RN_EI_UST_s:=r.RN_EI_UST_n;
                                fst:=FALSE;
                                vRn_mo:=r.rn_pozmo;
                                vIsp_ch:=r.rn_ispob_ch;
                              END LOOP;
                              IF NOT fst THEN
                                 PIPE ROW(strisp);
                              END IF;
      RETURN;
   END;   
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Состав
   FUNCTION F_SOSTAV_MO(p_rntv IN NUMBER,
                 p_rnps IN NUMBER) RETURN T_TB_IZMS_UST
      PIPELINED IS
      STRISP T_IZMS_UST := T_IZMS_UST(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
       vRn_Mo NUMBER:=-1;
       vIsp_ch NUMBER:=-1;
       fst BOOLEAN:=TRUE;
       cur DATE;
       vDate DATE;
   BEGIN
   cur := w_ktsg.pk_values.CURDATE;
   BEGIN
   SELECT att_arstart INTO vDate FROM tb_audi a WHERE a.att_auth=p_rnps AND rownum<2
            AND a.att_objtype<>1000 AND a.att_var=0;
            w_ktsg.pk_values.set_curdate(vDate);
   EXCEPTION 
            WHEN NO_DATA_FOUND THEN
                 NULL;  
   END;
   
FOR r IN (      SELECT --+use_nl(t3 mo)
t3.*,mo.RN_PODR,mo.RN_VO,mo.POZMONOTE
      FROM       
      TABLE(CAST (pk_mmk_izms.F_SOSTAV(p_rntv,p_rnps) AS T_TB_IZMS_UST)) t3
      JOIN w_ktsg.v0_poz_mo_s mo ON t3.rn_pozmo=mo.RN_POZMO
) LOOP
                                   strisp.RN_POZMO:=r.rn_pozmo;
                                   strisp.RN_ISPOB_CH:=r.rn_ispob_ch;
                                   strisp.rn_tv:=r.rn_tv;
                                   strisp.att_AUTH:=r.att_auth;
                                   strisp.att_AUTHTYPE:=r.att_authtype;
                                   --strisp.att_ALT:=r.att_alt;
                                   strisp.att_ALTTYPE:=r.att_alttype;
                                   
                                   strisp.dizm:=r.dizm;
                                   strisp.T_Start:=r.t_start;
                                   strisp.T_End:=r.t_end;
                                     
                                   strisp.kol_b:=r.kol_b;
                                   strisp.IND1_VARIANT_b:=r.IND1_VARIANT_b;
                                   strisp.IND2_NEUST_b:=r.IND2_NEUST_b;
                                   strisp.USTCOMPNOTE_b:=r.USTCOMPNOTE_b;
                                   strisp.RN_EI_UST_b:=r.RN_EI_UST_b;
                                   strisp.kol_s:=r.kol_s;
                                   strisp.IND1_VARIANT_s:=r.IND1_VARIANT_s;
                                   strisp.IND2_NEUST_s:=r.IND2_NEUST_s;
                                   strisp.USTCOMPNOTE_s:=r.USTCOMPNOTE_s;
                                   strisp.RN_EI_UST_s:=r.RN_EI_UST_s;
                                   strisp.RNPODR_B:=r.rn_podr;
                                   strisp.RNvo_B:=r.rn_vo;
                                   strisp.pozmonote_B:=r.pozmonote;
                                   strisp.RNPODR_s:=r.rn_podr;
                                   strisp.RNvo_s:=r.rn_vo;
                                   strisp.pozmonote_s:=r.pozmonote;
                                   PIPE ROW(strisp);
END LOOP;
       FOR r2 IN (SELECT --
        u.RN_TV,u.RN_ISPOB_CH,u.RN_POZMO
      FROM
        w_ktsg.tb_poz_mo p
           JOIN w_ktsg.v0_ust_comp_s u ON p.rn=u.RN_POZMO
           JOIN TABLE(cast (pk_mmk_izms.F_MO(p.rn_tv,p_rnps) AS T_TB_IZMS_MO)) t2 ON p.rn = t2.rn_pozmo
        WHERE p.rn_tv = p_rntv AND (t2.rnpodr_b<>t2.rnpodr_s OR t2.rnvo_b <>t2.rnvo_s)
       MINUS
      SELECT rn_tv,rn_ispob_ch,rn_pozmo
      FROM 
      TABLE(CAST (pk_mmk_izms.F_SOSTAV(p_rntv,p_rnps) AS T_TB_IZMS_UST)) t3
      ) LOOP
        FOR r IN (SELECT --
        t2.*,u.RN_ISPOB_CH,u.KOL,u.IND1_VARIANT,u.IND2_NEUST,u.USTCOMPNOTE,u.RN_EI_UST
FROM
  w_ktsg.tb_poz_mo p
     JOIN w_ktsg.v0_ust_comp_s u ON p.rn=u.RN_POZMO
     JOIN TABLE(cast(pk_mmk_izms.F_MO(p.rn_tv,p_rnps) AS T_TB_IZMS_MO)) t2 ON p.rn = t2.rn_pozmo
  WHERE p.rn_tv = p_rntv  
  AND (t2.rnpodr_b<>t2.rnpodr_s OR t2.rnvo_b <>t2.rnvo_s)
  AND u.rn_ispob_ch=r2.rn_ispob_ch AND u.rn_pozmo=r2.rn_pozmo) LOOP
                                   strisp.RN_POZMO:=r.rn_pozmo;
                                   strisp.RN_ISPOB_CH:=r.rn_ispob_ch;
                                   strisp.rn_tv:=r.rn_tv;
                                   strisp.att_AUTH:=r.att_auth;
                                   strisp.att_AUTHTYPE:=r.att_authtype;
                                   --strisp.att_ALT:=r.att_alt;
                                   strisp.att_ALTTYPE:=r.att_alttype;
                                   
                                   strisp.dizm:=r.dizm;
                                   strisp.T_Start:=r.t_start;
                                   strisp.T_End:=r.t_end;

         IF r.rnpodr_b IS NOT  NULL AND r.rnpodr_s IS NULL THEN         
                                   strisp.kol_b:=r.kol;
                                   strisp.IND1_VARIANT_b:=r.IND1_VARIANT;
                                   strisp.IND2_NEUST_b:=r.IND2_NEUST;
                                   strisp.USTCOMPNOTE_b:=r.USTCOMPNOTE;
                                   strisp.RN_EI_UST_b:=r.RN_EI_UST;
                                   strisp.RNPODR_B:=r.rnpodr_b;
                                   strisp.RNvo_B:=r.rnvo_b;
                                   strisp.pozmonote_B:=r.pozmonote_b;
         ELSIF r.rnpodr_b IS NULL AND r.rnpodr_s IS NOT NULL THEN
                                   strisp.kol_s:=r.kol;
                                   strisp.IND1_VARIANT_s:=r.IND1_VARIANT;
                                   strisp.IND2_NEUST_s:=r.IND2_NEUST;
                                   strisp.USTCOMPNOTE_s:=r.USTCOMPNOTE;
                                   strisp.RN_EI_UST_s:=r.RN_EI_UST;
                                   strisp.RNPODR_s:=r.rnpodr_s;
                                   strisp.RNvo_s:=r.rnvo_s;
                                   strisp.pozmonote_s:=r.pozmonote_s;
         ELSIF r.rnpodr_b IS NOT NULL AND r.rnpodr_s IS NOT NULL THEN
                                   strisp.kol_b:=r.kol;
                                   strisp.IND1_VARIANT_b:=r.IND1_VARIANT;
                                   strisp.IND2_NEUST_b:=r.IND2_NEUST;
                                   strisp.USTCOMPNOTE_b:=r.USTCOMPNOTE;
                                   strisp.RN_EI_UST_b:=r.RN_EI_UST;
                                   strisp.kol_s:=r.kol;
                                   strisp.IND1_VARIANT_s:=r.IND1_VARIANT;
                                   strisp.IND2_NEUST_s:=r.IND2_NEUST;
                                   strisp.USTCOMPNOTE_s:=r.USTCOMPNOTE;
                                   strisp.RN_EI_UST_s:=r.RN_EI_UST;
                                   strisp.RNPODR_B:=r.rnpodr_b;
                                   strisp.RNvo_B:=r.rnvo_b;
                                   strisp.pozmonote_B:=r.pozmonote_b;
                                   strisp.RNPODR_s:=r.rnpodr_s;
                                   strisp.RNvo_s:=r.rnvo_s;
                                   strisp.pozmonote_s:=r.pozmonote_s;
         END IF;
             PIPE ROW(strisp);
          END LOOP;
          --PIPE ROW(strisp);
      END LOOP;
   w_ktsg.pk_values.set_curdate(cur);
   RETURN;
   END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Образцы
   FUNCTION F_OBR(p_rntv IN NUMBER,
                 p_rnps IN NUMBER) RETURN T_TB_IZMS_OBR
      PIPELINED IS
      STRISP T_IZMS_OBR := T_IZMS_OBR(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
       vRn_Arid NUMBER:=-1;
       vRN_OBR NUMBER:=-1;
       fst BOOLEAN:=TRUE;
       cur DATE;
       vDate DATE;
       cnt PLS_INTEGER;
   BEGIN
   cur := w_ktsg.pk_values.CURDATE;
   BEGIN
   SELECT att_arstart INTO vDate FROM tb_audi a WHERE a.att_auth=p_rnps AND rownum<2
            AND a.att_objtype<>1000 AND a.att_var=0;
            w_ktsg.pk_values.set_curdate(vDate);
   EXCEPTION 
            WHEN NO_DATA_FOUND THEN
                 NULL;  
   END;

        FOR r IN (SELECT p.*
                               FROM (SELECT
                                  --v2.0.20060831
                                  --Показывает модификации,
                                  -- внесенные актуальными изменениями таблицы TB_OBR_S
                                   mos.rn_tv AS rn_tv_za,
                                   RN_TV_OBR,
                                   ARID_POZMO,
                                   T_ACTUAL,
                                   T_VAR,
                                   T_DIS,
                                   T_CorDate,
                                   T_Start AS dizm,
                                   t.T_End,
                                   --att_ALT,
                                   t.att_ALTTYPE,
                                   t.att_AUTH,
                                   t.att_AUTHTYPE,
                                   mos.rn_podr,
                                   mos.rn_vo,
                                   RN_TV_IZG,
                                   NVL2(T_DIS, NULL, RN_TV_IZG) AS RN_TV_IZG_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, RN_TV_IZG))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS RN_TV_IZG_P,
                                   NVL2(T_DIS, NULL, RN_PODR_ISP) AS RN_PODR_ISP_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, RN_PODR_ISP))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS RN_PODR_ISP_P,
                                   NVL2(T_DIS, NULL, RN_PODR_INITTD) AS RN_PODR_INITTD_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, RN_PODR_INITTD))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS RN_PODR_INITTD_P,
                                   NVL2(T_DIS, NULL, TEHNKOL) AS TEHNKOL_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, TEHNKOL))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS TEHNKOL_P,
                                   NVL2(T_DIS, NULL, round(MAXPART,6)) AS MAXPART_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, round(MAXPART,6)))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS MAXPART_P,
                                   NVL2(T_DIS, NULL, INFOBRNOTE) AS INFOBRNOTE_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, INFOBRNOTE))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS INFOBRNOTE_P
                                    FROM w_ktsg.V_OBR_S_HISTORY t,
                                         w_ktsg.v_poz_mo_b mos
                                   WHERE mos.att_arid = arid_pozmo
                                     AND rn_tv_izg = p_rntv
                                     AND mos.att_arver=0 AND mos.att_var=0) p
                              WHERE p.att_AUTH = p_rnps
                              ORDER BY rn_tv_obr,arid_pozmo,dizm
                              ) LOOP
                                IF vRN_arid<>r.arid_pozmo OR vRN_Obr<>r.rn_tv_obr THEN
                                   IF NOT fst THEN
                                      IF strisp.rn_podr_isp_b IS NOT NULL AND  strisp.rn_podr_isp_s IS NOT NULL THEN
                                         -- Изменение 
                                         SELECT COUNT(*) INTO cnt FROM w_ktsg.v0_poz_mo_s mos WHERE mos.att_arid=r.arid_pozmo;
                                         IF cnt=0 THEN
                                             strisp.rn_podr:=NULL;
                                             strisp.rn_vo:=NULL;
                                             strisp.RN_PODR_ISP_s:=NULL;
                                             strisp.RN_PODR_INITTD_s:=NULL;
                                             strisp.TEHNKOL_s:=NULL;
                                             strisp.MAXPART_s:=NULL;
                                             strisp.INFOBRNOTE_s:=NULL;
                                         END IF;
                                      END IF;
                                      PIPE ROW(strisp);
                                   END IF;
                                   strisp.RN_TV_OBR:=r.rn_tv_obr;
                                   strisp.RN_TV_IZG:=r.rn_tv_izg;
                                   strisp.ARID_POZMO:=r.arid_pozmo;
                                   strisp.RN_TV_ZA:=r.rn_tv_za;
                                   strisp.RN_PODR_ISP_B:=r.rn_podr_isp_p;
                                   strisp.RN_PODR_INITTD_B:=r.rn_podr_inittd_p;
                                   strisp.TEHNKOL_b:=r.tehnkol_p;
                                   strisp.MAXPART_b:=r.MAXPART_p;
                                   strisp.INFOBRNOTE_b:=r.INFOBRNOTE_p;

                                   strisp.att_AUTH:=r.att_auth;
                                   strisp.att_AUTHTYPE:=r.att_authtype;
                                   --strisp.att_ALT:=r.att_alt;
                                   strisp.att_ALTTYPE:=r.att_alttype;                                   
                                END IF;
                                   strisp.dizm:=r.t_cordate;
                                   strisp.T_Start:=r.dizm;
                                   strisp.T_End:=r.t_end;
                                   strisp.rn_podr:=r.rn_podr;
                                   strisp.rn_vo:=r.rn_vo;
                                   strisp.RN_PODR_ISP_s:=r.rn_podr_isp_n;
                                   strisp.RN_PODR_INITTD_s:=r.rn_podr_inittd_n;
                                   strisp.TEHNKOL_s:=r.tehnkol_n;
                                   strisp.MAXPART_s:=r.MAXPART_n;
                                   strisp.INFOBRNOTE_s:=r.INFOBRNOTE_n;
                                fst:=FALSE;
                                vRn_Arid:=r.Arid_pozmo;
                                vRN_Obr:=r.RN_TV_Obr;
                              END LOOP;
                              IF NOT fst THEN
                                   PIPE ROW(strisp);
                              END IF;
                              w_ktsg.pk_values.set_curdate(cur);                              
       RETURN;
   END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Входимость
   FUNCTION F_VHODIM_UST(p_rnispob IN NUMBER,
                 p_rnps IN NUMBER) RETURN T_TB_IZMS_UST
      PIPELINED IS
      STRISP T_IZMS_UST := T_IZMS_UST(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
       vRn_Mo NUMBER:=-1;
       vRn_tv NUMBER:=-1;
       fst BOOLEAN:=TRUE;
   BEGIN
        FOR r IN (SELECT p.*
                               FROM (SELECT
                                  --v2.0.20060831
                                  --Показывает модификации,
                                  -- внесенные актуальными изменениями таблицы TB_UST_COMP_S
                                   RN_POZMO,
                                   RN_ISPOB_CH,
                                   att_AUTH,
                                   att_AUTHTYPE,
                                   att_ALT,
                                   att_ALTTYPE,
                                   T_start AS dizm,
                                   T_Start ,
                                   T_End,

                                   att_ARID,
                                   att_ARID AS att_arid_s,
                                   RN_TV,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_POZMO,
                                                RN_ISPOB_CH ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, KOL))
                                       OVER(PARTITION BY RN_POZMO,
                                            RN_ISPOB_CH ORDER BY T_Start)
                                   END AS "KOL_P",
                                   NVL2(T_DIS, NULL, KOL) AS "KOL_N",
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_POZMO,
                                                RN_ISPOB_CH ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, IND1_VARIANT))
                                       OVER(PARTITION BY RN_POZMO,
                                            RN_ISPOB_CH ORDER BY T_Start)
                                   END AS "IND1_VARIANT_P",
                                   NVL2(T_DIS, NULL, IND1_VARIANT) AS "IND1_VARIANT_N",
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_POZMO,
                                                RN_ISPOB_CH ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, IND2_NEUST))
                                       OVER(PARTITION BY RN_POZMO,
                                            RN_ISPOB_CH ORDER BY T_Start)
                                   END AS "IND2_NEUST_P",
                                   NVL2(T_DIS, NULL, IND2_NEUST) AS "IND2_NEUST_N",
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_POZMO,
                                                RN_ISPOB_CH ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, USTCOMPNOTE))
                                       OVER(PARTITION BY RN_POZMO,
                                            RN_ISPOB_CH ORDER BY T_Start)
                                   END AS "USTCOMPNOTE_P",
                                   NVL2(T_DIS, NULL, USTCOMPNOTE) AS "USTCOMPNOTE_N",
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_POZMO,
                                                RN_ISPOB_CH ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, RN_EI_UST))
                                       OVER(PARTITION BY RN_POZMO,
                                            RN_ISPOB_CH ORDER BY T_Start)
                                   END AS "RN_EI_UST_P",
                                   NVL2(T_DIS, NULL, RN_EI_UST) AS "RN_EI_UST_N"
                                    FROM w_ktsg.V_UST_COMP_S_HISTORY t
                                   WHERE t.RN_ISPOB_CH=p_rnispob) p
                              WHERE p.att_AUTH = p_rnps
                              ORDER BY rn_tv,rn_pozmo,dizm
                              ) LOOP
                                IF vRN_mo<>r.rn_pozmo OR vRn_tv<>r.Rn_tv THEN
                                   IF NOT fst THEN
                                      PIPE ROW(strisp);
                                   END IF;
                                   strisp.RN_POZMO:=r.rn_pozmo;
                                   strisp.RN_ISPOB_CH:=r.rn_ispob_ch;
                                   strisp.kol_b:=r.kol_p;
                                   strisp.IND1_VARIANT_b:=r.IND1_VARIANT_P;
                                   strisp.IND2_NEUST_b:=r.IND2_NEUST_P;
                                   strisp.USTCOMPNOTE_b:=r.USTCOMPNOTE_P;
                                   strisp.RN_EI_UST_b:=r.RN_EI_UST_P;

                                   strisp.att_AUTH:=r.att_auth;
                                   strisp.att_AUTHTYPE:=r.att_authtype;
                                   --strisp.att_ALT:=r.att_alt;
                                   strisp.att_ALTTYPE:=r.att_alttype;
                                   strisp.rn_tv:=r.rn_tv;
                                END IF;
                                   strisp.dizm:=r.dizm;
                                   strisp.T_Start:=r.t_start;
                                   strisp.T_End:=r.t_end;
                                   strisp.kol_s:=r.kol_n;
                                   strisp.IND1_VARIANT_s:=r.IND1_VARIANT_n;
                                   strisp.IND2_NEUST_s:=r.IND2_NEUST_n;
                                   strisp.USTCOMPNOTE_s:=r.USTCOMPNOTE_n;
                                   strisp.RN_EI_UST_s:=r.RN_EI_UST_n;
                                fst:=FALSE;
                                vRn_mo:=r.rn_pozmo;
                                vRn_tv:=r.rn_tv;
                              END LOOP;      
                              IF NOT fst THEN        
                                 PIPE ROW(strisp);
                              END IF;
      RETURN;
   END;   
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Входимость
   FUNCTION F_VHODIM_UST_MO(p_rnispob IN NUMBER,
                 p_rnps IN NUMBER) RETURN T_TB_IZMS_UST
      PIPELINED IS
      STRISP T_IZMS_UST := T_IZMS_UST(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
       vRn_Mo NUMBER:=-1;
       vRn_tv NUMBER:=-1;
       fst BOOLEAN:=TRUE;
   BEGIN

FOR r IN (      SELECT --+use_nl(t3 mo)
t3.*,mo.RN_PODR,mo.RN_VO,mo.POZMONOTE
      FROM       
      TABLE(CAST (pk_mmk_izms.F_VHODIM_UST(p_rnispob,p_rnps) AS T_TB_IZMS_UST)) t3
      JOIN w_ktsg.v0_poz_mo_s mo ON t3.rn_pozmo=mo.RN_POZMO
) LOOP
                                   strisp.RN_POZMO:=r.rn_pozmo;
                                   strisp.RN_ISPOB_CH:=r.rn_ispob_ch;
                                   strisp.rn_tv:=r.rn_tv;
                                   strisp.att_AUTH:=r.att_auth;
                                   strisp.att_AUTHTYPE:=r.att_authtype;
                                   --strisp.att_ALT:=r.att_alt;
                                   strisp.att_ALTTYPE:=r.att_alttype;
                                   
                                   strisp.dizm:=r.dizm;
                                   strisp.T_Start:=r.t_start;
                                   strisp.T_End:=r.t_end;
                                     
                                   strisp.kol_b:=r.kol_b;
                                   strisp.IND1_VARIANT_b:=r.IND1_VARIANT_b;
                                   strisp.IND2_NEUST_b:=r.IND2_NEUST_b;
                                   strisp.USTCOMPNOTE_b:=r.USTCOMPNOTE_b;
                                   strisp.RN_EI_UST_b:=r.RN_EI_UST_b;
                                   strisp.kol_s:=r.kol_s;
                                   strisp.IND1_VARIANT_s:=r.IND1_VARIANT_s;
                                   strisp.IND2_NEUST_s:=r.IND2_NEUST_s;
                                   strisp.USTCOMPNOTE_s:=r.USTCOMPNOTE_s;
                                   strisp.RN_EI_UST_s:=r.RN_EI_UST_s;
                                   strisp.RNPODR_B:=r.rn_podr;
                                   strisp.RNvo_B:=r.rn_vo;
                                   strisp.pozmonote_B:=r.pozmonote;
                                   strisp.RNPODR_s:=r.rn_podr;
                                   strisp.RNvo_s:=r.rn_vo;
                                   strisp.pozmonote_s:=r.pozmonote;
                                   PIPE ROW(strisp);
END LOOP;
   
      FOR r2 IN ( SELECT t4.rn_Tv,t4.rn_ispob_ch,t4.rn_pozmo FROM
       (SELECT --
        u.RN_TV,u.RN_ISPOB_CH,u.RN_POZMO
      FROM 
           w_ktsg.v0_ust_comp_s u           
        WHERE u.rn_ispob_ch=p_rnispob 
        --p.rn_tv = p_rntv AND (t2.rnpodr_b<>t2.rnpodr_s OR t2.rnvo_b <>t2.rnvo_s)
       MINUS
      SELECT rn_tv,rn_ispob_ch,rn_pozmo
      FROM 
      TABLE(CAST (pk_mmk_izms.F_VHODIM_UST(p_rnispob,p_rnps) AS T_TB_IZMS_UST)) t3
      ) t4 JOIN TABLE(cast (pk_mmk_izms.F_MO(t4.rn_tv,p_rnps) AS T_TB_IZMS_MO)) t2 ON t4.rn_pozmo = t2.rn_pozmo
      ) LOOP
      
        FOR r IN (SELECT --
        t2.*,u.RN_ISPOB_CH,u.KOL,u.IND1_VARIANT,u.IND2_NEUST,u.USTCOMPNOTE,u.RN_EI_UST
FROM  
    w_ktsg.v0_ust_comp_s u
     JOIN TABLE(cast(pk_mmk_izms.F_MO(u.rn_tv,p_rnps) AS T_TB_IZMS_MO)) t2 ON u.rn_pozmo = t2.rn_pozmo
  WHERE (t2.rnpodr_b<>t2.rnpodr_s OR t2.rnvo_b <>t2.rnvo_s)
  AND u.rn_tv=r2.rn_Tv AND u.rn_ispob_ch=r2.rn_ispob_ch AND u.rn_pozmo=r2.rn_pozmo) LOOP
                                   strisp.RN_POZMO:=r.rn_pozmo;
                                   strisp.RN_ISPOB_CH:=r.rn_ispob_ch;
                                   strisp.rn_tv:=r.rn_tv;
                                   strisp.att_AUTH:=r.att_auth;
                                   strisp.att_AUTHTYPE:=r.att_authtype;
                                   --strisp.att_ALT:=r.att_alt;
                                   strisp.att_ALTTYPE:=r.att_alttype;
                                   
                                   strisp.dizm:=r.dizm;
                                   strisp.T_Start:=r.t_start;
                                   strisp.T_End:=r.t_end;

         IF r.rnpodr_b IS NOT  NULL AND r.rnpodr_s IS NULL THEN         
                                   strisp.kol_b:=r.kol;
                                   strisp.IND1_VARIANT_b:=r.IND1_VARIANT;
                                   strisp.IND2_NEUST_b:=r.IND2_NEUST;
                                   strisp.USTCOMPNOTE_b:=r.USTCOMPNOTE;
                                   strisp.RN_EI_UST_b:=r.RN_EI_UST;
                                   strisp.RNPODR_B:=r.rnpodr_b;
                                   strisp.RNvo_B:=r.rnvo_b;
                                   strisp.pozmonote_B:=r.pozmonote_b;
         ELSIF r.rnpodr_b IS NULL AND r.rnpodr_s IS NOT NULL THEN
                                   strisp.kol_s:=r.kol;
                                   strisp.IND1_VARIANT_s:=r.IND1_VARIANT;
                                   strisp.IND2_NEUST_s:=r.IND2_NEUST;
                                   strisp.USTCOMPNOTE_s:=r.USTCOMPNOTE;
                                   strisp.RN_EI_UST_s:=r.RN_EI_UST;
                                   strisp.RNPODR_s:=r.rnpodr_s;
                                   strisp.RNvo_s:=r.rnvo_s;
                                   strisp.pozmonote_s:=r.pozmonote_s;
         ELSIF r.rnpodr_b IS NOT NULL AND r.rnpodr_s IS NOT NULL THEN
                                   strisp.kol_b:=r.kol;
                                   strisp.IND1_VARIANT_b:=r.IND1_VARIANT;
                                   strisp.IND2_NEUST_b:=r.IND2_NEUST;
                                   strisp.USTCOMPNOTE_b:=r.USTCOMPNOTE;
                                   strisp.RN_EI_UST_b:=r.RN_EI_UST;
                                   strisp.kol_s:=r.kol;
                                   strisp.IND1_VARIANT_s:=r.IND1_VARIANT;
                                   strisp.IND2_NEUST_s:=r.IND2_NEUST;
                                   strisp.USTCOMPNOTE_s:=r.USTCOMPNOTE;
                                   strisp.RN_EI_UST_s:=r.RN_EI_UST;
                                   strisp.RNPODR_B:=r.rnpodr_b;
                                   strisp.RNvo_B:=r.rnvo_b;
                                   strisp.pozmonote_B:=r.pozmonote_b;
                                   strisp.RNPODR_s:=r.rnpodr_s;
                                   strisp.RNvo_s:=r.rnvo_s;
                                   strisp.pozmonote_s:=r.pozmonote_s;
         END IF;
         PIPE ROW(strisp);
  END LOOP;  
  END LOOP;
      RETURN;
   END;

--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- С кем изготавливается образец
   FUNCTION F_VHODIM_OBR(p_rntv IN NUMBER,
                 p_rnps IN NUMBER) RETURN T_TB_IZMS_OBR
      PIPELINED IS
      STRISP T_IZMS_OBR := T_IZMS_OBR(NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
       vRn_Arid NUMBER:=-1;
       vRNTV_Izg NUMBER:=-1;
       fst BOOLEAN:=TRUE;
   BEGIN
        FOR r IN (SELECT p.*
                               FROM (SELECT
                                  --v2.0.20060831
                                  --Показывает модификации,
                                  -- внесенные актуальными изменениями таблицы TB_OBR_S
                                   mos.rn_tv AS rn_tv_za,
                                   RN_TV_OBR,
                                   ARID_POZMO,
                                   T_ACTUAL,
                                   T_VAR,
                                   T_DIS,
                                   T_CorDate,
                                   T_Start AS dizm,
                                   T_End,
                                   --att_ALT,
                                   att_ALTTYPE,
                                   att_AUTH,
                                   att_AUTHTYPE,
                                   mos.rn_podr,
                                   mos.rn_vo,
                                   RN_TV_IZG,
                                   NVL2(T_DIS, NULL, RN_TV_IZG) AS RN_TV_IZG_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, RN_TV_IZG))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS RN_TV_IZG_P,
                                   NVL2(T_DIS, NULL, RN_PODR_ISP) AS RN_PODR_ISP_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, RN_PODR_ISP))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS RN_PODR_ISP_P,
                                   NVL2(T_DIS, NULL, RN_PODR_INITTD) AS RN_PODR_INITTD_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, RN_PODR_INITTD))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS RN_PODR_INITTD_P,
                                   NVL2(T_DIS, NULL, TEHNKOL) AS TEHNKOL_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, TEHNKOL))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS TEHNKOL_P,
                                   NVL2(T_DIS, NULL, round(MAXPART,6)) AS MAXPART_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, round(MAXPART,6)))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS MAXPART_P,
                                   NVL2(T_DIS, NULL, INFOBRNOTE) AS INFOBRNOTE_N,
                                   CASE
                                      WHEN LAG(T_End)
                                       OVER(PARTITION BY RN_TV_OBR,
                                                ARID_POZMO ORDER BY T_Start) <
                                           T_Start THEN
                                       NULL
                                      ELSE
                                       LAG(NVL2(T_DIS, NULL, INFOBRNOTE))
                                       OVER(PARTITION BY RN_TV_OBR,
                                            ARID_POZMO ORDER BY T_Start)
                                   END AS INFOBRNOTE_P
                                    FROM w_ktsg.V_OBR_S_HISTORY,
                                         w_ktsg.v_poz_mo_s_wa mos
                                   WHERE mos.att_arid = arid_pozmo
                                     AND rn_tv_obr = p_rntv) p
                              WHERE p.att_AUTH = p_rnps
                              ORDER BY rn_tv_izg,arid_pozmo,dizm
                              ) LOOP
                                IF vRN_arid<>r.arid_pozmo OR vRNTV_Izg<>r.rn_tv_izg THEN
                                   IF NOT fst THEN
                                      PIPE ROW(strisp);
                                   END IF;
                                   strisp.RN_TV_OBR:=r.rn_tv_obr;
                                   strisp.RN_TV_IZG:=r.rn_tv_izg;
                                   strisp.ARID_POZMO:=r.arid_pozmo;
                                   strisp.RN_TV_ZA:=r.rn_tv_za;
                                   strisp.RN_PODR_ISP_B:=r.rn_podr_isp_p;
                                   strisp.RN_PODR_INITTD_B:=r.rn_podr_inittd_p;
                                   strisp.TEHNKOL_b:=r.tehnkol_p;
                                   strisp.MAXPART_b:=r.MAXPART_p;
                                   strisp.INFOBRNOTE_b:=r.INFOBRNOTE_p;

                                   strisp.att_AUTH:=r.att_auth;
                                   strisp.att_AUTHTYPE:=r.att_authtype;
                                   --strisp.att_ALT:=r.att_alt;
                                   strisp.att_ALTTYPE:=r.att_alttype;                                   
                                END IF;
                                   strisp.dizm:=r.t_cordate;
                                   strisp.T_Start:=r.dizm;
                                   strisp.T_End:=r.t_end;
                                   strisp.rn_podr:=r.rn_podr;
                                   strisp.rn_vo:=r.rn_vo;
                                   strisp.RN_PODR_ISP_s:=r.rn_podr_isp_n;
                                   strisp.RN_PODR_INITTD_s:=r.rn_podr_inittd_n;
                                   strisp.TEHNKOL_s:=r.tehnkol_n;
                                   strisp.MAXPART_s:=r.MAXPART_n;
                                   strisp.INFOBRNOTE_s:=r.INFOBRNOTE_n;
                                fst:=FALSE;
                                vRn_Arid:=r.Arid_pozmo;
                                vRNTV_Izg:=r.RN_TV_Izg;
                              END LOOP;
                              IF NOT fst THEN
                                 PIPE ROW(strisp);
                              END IF;
       RETURN;
   END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- У кого объект является заготовкой
   FUNCTION F_VHODIM_ZAG(p_rnispob IN NUMBER,
                  p_rnps IN NUMBER,
                  p_razr IN NUMBER DEFAULT 0) RETURN T_TB_IZMS_ZAG
      PIPELINED IS
   BEGIN
FOR r2 IN (
select
--v2.0.20060831
--Показывает модификации,
-- внесенные актуальными изменениями таблицы TB_T_ZAG_S
       RN_TV,
       T_ACTUAL,
       T_VAR,
       T_DIS,
       T_CorDate,
       T_Start,
       T_End,
       att_ALT,
       att_ALTTYPE,
       att_AUTH,
       att_AUTHTYPE,
       att_ARID,
       OBJTYPE,
       NVL2(T_DIS,null,RN_ISPOB_ZAG) as "RN_ISPOB_ZAG_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,RN_ISPOB_ZAG)) OVER(partition by RN_TV order by T_Start)
       end as "RN_ISPOB_ZAG_P",
       NVL2(T_DIS,null,RN_VID_ISPOB_ZAG) as "RN_VID_ISPOB_ZAG_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,RN_VID_ISPOB_ZAG)) OVER(partition by RN_TV order by T_Start)
       end as "RN_VID_ISPOB_ZAG_P",
       NVL2(T_DIS,null,RN_EI) as "RN_EI_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,RN_EI)) OVER(partition by RN_TV order by T_Start)
       end as "RN_EI_P",
       NVL2(T_DIS,null,NORMRASH) as "NORMRASH_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,NORMRASH)) OVER(partition by RN_TV order by T_Start)
       end as "NORMRASH_P",
       NVL2(T_DIS,null,VIDZAG) as "VIDZAG_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,VIDZAG)) OVER(partition by RN_TV order by T_Start)
       end as "VIDZAG_P",
       NVL2(T_DIS,null,KOLDETZAG) as "KOLDETZAG_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,KOLDETZAG)) OVER(partition by RN_TV order by T_Start)
       end as "KOLDETZAG_P",
       NVL2(T_DIS,null,VESZAG) as "VESZAG_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,VESZAG)) OVER(partition by RN_TV order by T_Start)
       end as "VESZAG_P",
       NVL2(T_DIS,null,GEOMR_DL) as "GEOMR_DL_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,GEOMR_DL)) OVER(partition by RN_TV order by T_Start)
       end as "GEOMR_DL_P",
       NVL2(T_DIS,null,GEOMR_SH) as "GEOMR_SH_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,GEOMR_SH)) OVER(partition by RN_TV order by T_Start)
       end as "GEOMR_SH_P",
       NVL2(T_DIS,null,TZAGNOTE) as "TZAGNOTE_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,TZAGNOTE)) OVER(partition by RN_TV order by T_Start)
       end as "TZAGNOTE_P"
from W_KTSG.V_T_ZAG_S_HISTORY t WHERE t.att_auth=p_rnps ) LOOP

       FOR r IN (
       SELECT CAST(MULTISET
                               (
       SELECT 
             NULL AS arid_b,
             NULL AS arid_s,
             rn_tv,
             att_auth AS att_auth,
             att_authtype AS att_authtype,
             NULL AS att_alt,
             NULL AS att_alttype,
             t_cordate AS t_cordate,
             t_start AS t_start,
             t_end AS t_end,
             RN_ISPOB_ZAG_P AS rnispob_b,
             RN_ISPOB_ZAG_N AS rnispob_s,
             RN_EI_P AS rn_ei_b,
             RN_EI_N AS rn_ei_s,
             NORMRASH_N AS normrash_b,
             NORMRASH_N AS normrash_s,
             VIDZAG_P AS vidzag_b,
             VIDZAG_N AS vidzag_s,
             KOLDETZAG_P AS koldetzag_b,
             KOLDETZAG_N AS koldetzag_s,
             VESZAG_P AS veszag_b,
             VESZAG_N AS veszag_s,
             GEOMR_DL_N AS geomr_dl_s,
             GEOMR_DL_P AS geomr_dl_b,
             GEOMR_SH_N AS geomr_sh_s,
             GEOMR_SH_P AS geomr_sh_b,
             TZAGNOTE_P AS tzagnote_b,
             TZAGNOTE_N AS tzagnote_s
              FROM (
       select
--v2.0.20060831
--Показывает модификации,
-- внесенные актуальными изменениями таблицы TB_T_ZAG_S
       RN_TV,
       T_ACTUAL,
       T_VAR,
       T_DIS,
       T_CorDate,
       T_Start,
       T_End,
       att_ALT,
       att_ALTTYPE,
       att_AUTH,
       att_AUTHTYPE,
       att_ARID,
       OBJTYPE,
       NVL2(T_DIS,null,RN_ISPOB_ZAG) as "RN_ISPOB_ZAG_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,RN_ISPOB_ZAG)) OVER(partition by RN_TV order by T_Start)
       end as "RN_ISPOB_ZAG_P",
       NVL2(T_DIS,null,RN_VID_ISPOB_ZAG) as "RN_VID_ISPOB_ZAG_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,RN_VID_ISPOB_ZAG)) OVER(partition by RN_TV order by T_Start)
       end as "RN_VID_ISPOB_ZAG_P",
       NVL2(T_DIS,null,RN_EI) as "RN_EI_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,RN_EI)) OVER(partition by RN_TV order by T_Start)
       end as "RN_EI_P",
       NVL2(T_DIS,null,NORMRASH) as "NORMRASH_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,NORMRASH)) OVER(partition by RN_TV order by T_Start)
       end as "NORMRASH_P",
       NVL2(T_DIS,null,VIDZAG) as "VIDZAG_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,VIDZAG)) OVER(partition by RN_TV order by T_Start)
       end as "VIDZAG_P",
       NVL2(T_DIS,null,KOLDETZAG) as "KOLDETZAG_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,KOLDETZAG)) OVER(partition by RN_TV order by T_Start)
       end as "KOLDETZAG_P",
       NVL2(T_DIS,null,VESZAG) as "VESZAG_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,VESZAG)) OVER(partition by RN_TV order by T_Start)
       end as "VESZAG_P",
       NVL2(T_DIS,null,GEOMR_DL) as "GEOMR_DL_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,GEOMR_DL)) OVER(partition by RN_TV order by T_Start)
       end as "GEOMR_DL_P",
       NVL2(T_DIS,null,GEOMR_SH) as "GEOMR_SH_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,GEOMR_SH)) OVER(partition by RN_TV order by T_Start)
       end as "GEOMR_SH_P",
       NVL2(T_DIS,null,TZAGNOTE) as "TZAGNOTE_N",
       case when LAG(T_End) OVER(partition by RN_TV order by T_Start) < T_Start then null
            else LAG(NVL2(T_DIS,null,TZAGNOTE)) OVER(partition by RN_TV order by T_Start)
       end as "TZAGNOTE_P"
from w_ktsg.V_T_ZAG_S_HISTORY t WHERE t.rn_tv=r2.rn_tv ) WHERE att_auth=p_rnps
AND (RN_ISPOB_ZAG_N=p_rnispob OR RN_ISPOB_ZAG_P=p_rnispob)
 ) AS
                               T_TB_IZMS_ZAG) AS dt
                     FROM dual
) LOOP
      IF r.dt.COUNT <> 0 THEN
         FOR i IN r.dt.FIRST .. r.dt.LAST LOOP
            PIPE ROW(r.dt(i));
         END LOOP;
      END IF;
  END LOOP;     
       END LOOP;


         /*SELECT CAST(MULTISET
                               (SELECT NULL AS arid_b,
                                       NULL AS arid_s,
                                       t.rn_tv,
                                       NULL AS att_auth,
                                       NULL AS att_authtype,
                                       NULL AS att_alt,
                                       NULL AS att_alttype,
                                       NULL AS t_cordate,
                                       t.dizm AS t_start,
                                       NULL AS t_end,
                                       rnispob_b,
                                       rnispob_s,
                                       rn_ei_b,
                                       rn_ei_s,
                                       t.normrash_b,
                                       t.normrash_s,
                                       t.vidzag_b,
                                       t.vidzag_s,
                                       t.koldetzag_b,
                                       t.koldetzag_s,
                                       t.veszag_b,
                                       t.veszag_s,
                                       t.geomr_dl_s,
                                       t.geomr_dl_b,
                                       t.geomr_sh_s,
                                       t.geomr_sh_b,
                                       t.tzagnote_b,
                                       t.tzagnote_s
                                  FROM TABLE(pk_report2.F_GET_IZM_tzag2(p_rnps,
                                                                        p_rnispob)) t) AS
                               T_TB_IZMS_ZAG) AS dt
                     FROM dual) LOOP
            IF c.dt.COUNT <> 0 THEN
               FOR i IN c.dt.FIRST .. c.dt.LAST LOOP
                  PIPE ROW(c.dt(i));
               END LOOP;
            END IF;
         END LOOP;*/
      RETURN;
   END;   
END PK_MMK_IZMS;
/
---------------------------------
--  Changed type t_build_tree  --
---------------------------------
create or replace type w_mmkt.T_build_tree as object
(
Kol Number,
kdce_ch Number,
ap number,
rn_podr number,
tv_ch number,
ez number,
ind number,
urov number,
rn_pozmo number,
att_arrid number,
Min_part number,
Max_part number,
Min_Kol number,
k number,
kdce_k number,
tv_k number,
doly_ch number
)
/
-------------------------------------
--  Changed type t_build_tree_set  --
-------------------------------------
create or replace type w_mmkt.T_build_tree_SET is Table of T_build_tree
/
---------------------------
--  Changed type t_tree  --
---------------------------
create or replace type w_mmkt.T_tree is object
(
Kol Number,
kdce_ch Number,
ap Number,
rn_podr number,
tv_ch number,
ez number,
ind number,
urov number,
rn_pozmo number,
att_arrid number,
kdce_k number,
tv_k number
)
/
------------------------------
--  Changed type t_treetab  --
------------------------------
create or replace type w_mmkt.T_TREETAB as object
(
Kol Number,
kdce_ch Number,
ap Number,
cex varchar2(250)
)
/
----------------------------------
--  Changed type t_treetab_set  --
----------------------------------
create or replace type w_mmkt.t_treetab_SET as Table of t_treetab
/
-------------------------------
--  Changed type t_tree_set  --
-------------------------------
create or replace type w_mmkt.T_tree_set is Table of t_tree
/
-------------------------------
--  Changed type t_res_intv  --
-------------------------------
create or replace type w_mmkt.T_RES_INTV as object
( --Запись интервала
  att_arstart     DATE,   -- Дата начала действия состояния
  farid              NUMBER   -- Первый арид изменения
)
/
----------------------------------
--  Changed type t_res_tb_intv  --
----------------------------------
create or replace type w_mmkt.T_RES_TB_INTV as table OF T_RES_INTV;
/
-----------------------------------------
--  Changed package body pk_tresult35  --
-----------------------------------------
CREATE OR REPLACE PACKAGE BODY W_MMKT.PK_TRESULT35 IS
   --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   -- Function and procedure implementations
   fl_use_forall CHAR(1):='1';
   FUNCTION F_RES_K_INL_p(p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL) RETURN t_res_nl3
      PIPELINED
      IS
      t_all t_rec_all;
      i INTEGER;
   BEGIN
      i:=pk_tresult35.f_res_k_inl(t_all,p_start,p_end,p_rntv,p_rnispob);
      IF t_all.ba.COUNT>0 THEN
         FOR c IN t_all.ba.FIRST .. t_all.ba.LAST LOOP
            PIPE ROW (t_all.ba(c));
          END LOOP;
      END IF;
      RETURN;
   END;
   FUNCTION F_RES_K_INL_p2(p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL) RETURN t_res_nl3
      PIPELINED
      IS
      t_all t_rec_all;
      i INTEGER;
   BEGIN
      i:=pk_tresult35.f_res_k_inl2(t_all,p_start,p_end,p_rntv,p_rnispob);
      IF t_all.ba.COUNT>0 THEN
         FOR c IN t_all.ba.FIRST .. t_all.ba.LAST LOOP
            PIPE ROW (t_all.ba(c));
          END LOOP;
      END IF;
      RETURN;
   END;
   FUNCTION F_RES_K_INL_p2obr(p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL) RETURN t_res_nl3
      PIPELINED
      IS
      t_all t_rec_all;
      i INTEGER;
   BEGIN
      i:=pk_tresult35.f_res_k_inl2obr(t_all,p_start,p_end,p_rntv,p_rnispob);
      IF t_all.ba.COUNT>0 THEN
         FOR c IN t_all.ba.FIRST .. t_all.ba.LAST LOOP
            PIPE ROW (t_all.ba(c));
          END LOOP;
      END IF;
      RETURN;
   END;

   -- Function and procedure implementations
   FUNCTION F_RES_K_INL_t(p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL,
                        p_part    IN number default 1000000) RETURN INTEGER
      IS
      t_all t_rec_all;
      i INTEGER;
   BEGIN
      i:=pk_tresult35.f_res_k_inl(t_all,p_start,p_end,p_rntv,p_rnispob,p_part);
     /* IF t_all.ba.COUNT>0 THEN
         FOR c IN t_all.ba.FIRST .. t_all.ba.LAST LOOP
            --PIPE ROW (t_all.ba(c));
            NULL;
          END LOOP;
      END IF;*/
      RETURN 1;
   END;
   -- Function and procedure implementations
   FUNCTION F_RES_K_INL_t2(p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL) RETURN INTEGER
      IS
      t_all t_rec_all;
      i INTEGER;
   BEGIN
      i:=pk_tresult35.f_res_k_inl2(t_all,p_start,p_end,p_rntv,p_rnispob);
     /* IF t_all.ba.COUNT>0 THEN
         FOR c IN t_all.ba.FIRST .. t_all.ba.LAST LOOP
            --PIPE ROW (t_all.ba(c));
            NULL;
          END LOOP;
      END IF;*/
      RETURN 1;
   END;
   --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   PROCEDURE p_show_debug(t tb_int_dstart) IS

      c varchar2(20);
      fa number;
      rn_ispob_ch number;
      ez NUMBER;
      --rn_pozmo NUMBER;
   BEGIN
     /* --rall:=pk_tresult3.f_res_k_inl(p_start,p_end,p_rntv,p_rnispob);
      --dbms_output.put_line('dates=  '||t.COUNT);
      IF t.COUNT>0 THEN
         c:=t.first;
         while c is not null loop
         --IF c='11.01.2008 00:00:00' THEN
            dbms_output.put_line('-----' || c);
            fa:=t(c).FIRST;
            while fa is not null LOOP
                dbms_output.put_line('----------(' || fa||')');
                rn_ispob_ch:=t(c)(fa).tb_r.first;
                while rn_ispob_ch is not null loop
                      dbms_output.put_line('-----------------'||to_char(rn_ispob_ch));
                      ez:=t(c)(fa).tb_r(rn_ispob_ch).n.FIRST;
                      WHILE ez IS NOT NULL LOOP
                             --dbms_output.put_line('-----------------!!!!!!'||to_char(ez));
                            \* rn_pozmo:=t(c)(fa).tb_r(rn_ispob_ch).n(ez).v.FIRST;
                             WHILE rn_pozmo IS NOT NULL LOOP
                                   --dbms_output.put_line('-----------------!!!!!!^^^^^'||to_char(rn_pozmo));
                                   rn_pozmo:=t(c)(fa).tb_r(rn_ispob_ch).n(ez).v.NEXT(rn_pozmo);
                             END LOOP;*\
                             ez:=t(c)(fa).tb_r(rn_ispob_ch).n.NEXT(ez);
                       END LOOP;
                      rn_ispob_ch:=t(c)(fa).tb_r.next(rn_ispob_ch);
                end loop;
                fa:=t(c).next(fa);
            end loop;
         --END IF;
            c:=T.next(c);
         END LOOP;
      END IF;*/
      RETURN;
      --b_r(c).n(c1).v(c2).q(c3).uf_vz
   END;
   --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   FUNCTION F_RES_K_INL_pmd(p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL) RETURN t_res_int
      PIPELINED
      IS
      rall t_rec_all;
      el t_res_intv_el;
      c varchar2(20);
      fa number;
      rn_ispob_ch number;
      ez1 NUMBER;
      rn_pozmo NUMBER;
      rn_tv NUMBER;
   BEGIN
      el:=t_res_intv_el(NULL,NULL,null,null,NULL,NULL,NULL,NULL);
   --   rall:=pk_tresult32.f_res_k_inl(p_start,p_end,p_rntv,p_rnispob);
      --dbms_output.put_line('dates=  '||rall.intv.COUNT);
      IF rall.ddstart.COUNT>0 THEN
      FOR c IN (SELECT t.dstart,
                                           t.farid,
                                           t.rn_isp,
                                           t.n,
                                           t.v,
                                           t.ind_mo,
                                           t.rntv,
                                           t.ap

       FROM
            /*TABLE ( CAST(rall.dfarid AS t_res_dfarid) ) dfr
          JOIN TABLE (CAST (rall.disp AS t_res_disp) ) di ON dfr.rn=di.rn_farids_fk
          JOIN TABLE ( CAST (rall.dez AS t_res_dez) ) dez ON di.rn=dez.rn_isp_fk
          JOIN*/ v_res_dmotv t /*ON t.dstart=dfr.dstart_fk AND t.farid=dfr.farid AND t.rn_isp=di.rn_ispob AND t.n=dez.ez*/) LOOP
                 el.dstart:=c.dstart;--rall.intv(c)dstart;
                 el.farid:=c.farid;
                 el.rnisp_c:=c.rn_isp;
                 el.ez:=c.n;
                 el.rn_pozmo:=c.v;
                 el.ind:=c.ind_mo;
                 IF c.rntv=1 THEN
                    el.rntv_c:=NULL;
                 ELSE
                    el.rntv_c:=c.rntv;
                 END IF;
                 el.ap:=c.ap;
                 PIPE ROW (el);
          END LOOP;
          END IF;
/*         c:=rall.intv.first;
         while c is not null loop
            el.dstart:=c;--rall.intv(c)dstart;
            fa:=rall.intv(c).FIRST;
            while fa is not null loop
                el.farid:=fa;
                --dbms_output.put_line( rall.intv(c)(fa).tb_r.count );
                rn_ispob_ch:=rall.intv(c)(fa).tb_r.first;
                while rn_ispob_ch is not null loop
                      el.rnisp_c:=rn_ispob_ch;
                      ez1:=rall.intv(c)(fa).tb_r(rn_ispob_ch).n.FIRST;
                      WHILE ez1 IS NOT NULL LOOP
                             el.ez:=ez1;
                             FOR p IN (SELECT * FROM v_res_dmotv t
                             WHERE t.dstart=to_char(c,'DD.MM.YYYY HH24:MI:SS') AND t.farid=fa AND t.rn_isp=rn_ispob_ch
                                               AND t.n=ez) LOOP
                                             el.rn_pozmo:=p.v;
                                             el.ind:=p.ind_mo;
                                         IF p.rntv=1 THEN
                                            el.rntv_c:=NULL;
                                         ELSE
                                         el.rntv_c:=p.rntv;
                                         END IF;
                                         el.ap:=p.ap;
\*                             rn_pozmo:=rall.intv(c)(fa).tb_r(rn_ispob_ch).n(ez).v.FIRST;
                             WHILE rn_pozmo IS NOT NULL LOOP
                                   el.rn_pozmo:=rn_pozmo;
                                   el.ind:=rall.intv(c)(fa).tb_r(rn_ispob_ch).n(ez).v(rn_pozmo).ind;
                                   rn_tv:=rall.intv(c)(fa).tb_r(rn_ispob_ch).n(ez).v(rn_pozmo).q.FIRST;
                                   WHILE rn_tv IS NOT NULL LOOP
                                         IF rn_tv=1 THEN
                                            el.rntv_c:=NULL;
                                         ELSE
                                         el.rntv_c:=rn_tv;
                                         END IF;
                                         el.ap:=rall.intv(c)(fa).tb_r(rn_ispob_ch).n(ez).v(rn_pozmo).q(rn_tv).ap;
                                         PIPE ROW (el);
                                         rn_tv:=rall.intv(c)(fa).tb_r(rn_ispob_ch).n(ez).v(rn_pozmo).q.NEXT(rn_tv);
                                   END LOOP;
                                   rn_pozmo:=rall.intv(c)(fa).tb_r(rn_ispob_ch).n(ez).v.NEXT(rn_pozmo);*\
                             END LOOP;
                             ez1:=rall.intv(c)(fa).tb_r(rn_ispob_ch).n.NEXT(ez1);
                       END LOOP;
                      rn_ispob_ch:=rall.intv(c)(fa).tb_r.next(rn_ispob_ch);
                end loop;
                fa:=rall.intv(c).next(fa);
            end loop;
            c:=rall.intv.next(c);
         END LOOP;
      END IF;
*/      RETURN;
   END;
   --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   -- получить первый арид изменения
   FUNCTION F_get_first_arid(
            p_rnps IN number) RETURN number
      IS
      resul number;
   BEGIN
/*        select min(att_arid) into resul
        from w_ktsg.v_audi where att_auth=p_rnps;*/
        select farid into resul
        from w_mmkt.tb_auth_farid where att_auth=p_rnps;        
      RETURN resul;
   exception
            when NO_DATA_FOUND then
            SELECT MIN(att_arid) into resul FROM tb_audi a WHERE a.att_auth=p_rnps;
            return resul;
   END;
   --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   -- получить первый арид изменения для следующего состояния
   FUNCTION F_get_first_arid_for_end(
            p_arid IN number,
            p_disa IN CHAR DEFAULT '1') RETURN number
      IS
      p_rnps NUMBER;
      resul NUMBER;
   BEGIN
       -- SELECT att_auth INTO p_RNPS FROM w_ktsg.tb_audi WHERE att_arid=
select farid into resul
        from w_mmkt.tb_auth_farid WHERE att_auth=(
        select --+star
----mstart,a2.att_arid,--a2.asd,
               nvl((SELECT al.att_auth
	             FROM w_ktsg.v_AUDI al
               WHERE al.att_ARVer=nvl2(p_disa,nvl2(al.att_ardis,1,0),0)
                   AND al.att_ARStart=f1.mstart
	             CONNECT BY PRIOR al.att_NextARID=al.att_ARID
                   AND PRIOR al.att_OBJTYPE=al.att_OBJTYPE
	             START WITH al.att_ARID=a2.att_arid
               ),-1) estart
--               INTO p_rnps
 from (
           select (
               SELECT MIN(a.att_arstart) as mstart
	             FROM w_ktsg.v_AUDI a
               WHERE a.att_ARVer=nvl2(p_disa,nvl2(a.att_ardis,1,0),0)
                   AND a.att_ARStart>=f.att_Arend
	             CONNECT BY PRIOR a.att_NextARID=a.att_ARID
                   AND PRIOR a.att_OBJTYPE=a.att_OBJTYPE
	             START WITH a.att_ARID=f.att_arid
                  ) mstart,f.att_arid
           from
           (
               select att_arid,
                      att_arend
               from
               tb_audi a1
               order by att_arid desc
           ) f ) f1 join tb_audi a2 on f1.att_arid=a2.att_arid
           WHERE a2.att_arid=p_arid);
        --f_ResGetNextActual2(p_arid,'1');
--        f_ResGetNextActual2(p_arid,'1');
--        w_common.pk_audi.GetNextActual(p_arid,'1');
        /*select farid into resul
        from w_mmkt.tb_auth_farid where att_auth=p_rnps;*/
/*        SELECT MIN(att_arid) INTO resul
        FROM w_ktsg.v_audi WHERE att_auth=p_rnps;
*/      RETURN resul;
EXCEPTION
      WHEN NO_DATA_fOUND  THEN
      RETURN NULL;
   END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   -- актуальнай ли арид
   FUNCTION F_is_arid_actual(
            p_dstart IN DATE,
            p_farid IN NUMBER,
            p_arid IN NUMBER,
            p_start in date -- дата начала периода расчета - если считаем на эту дату, то 
            --первый арид не учитывается
            ) RETURN INTEGER
      IS
      p_rnps NUMBER;
   BEGIN
        SELECT att_auth INTO p_RNPS
        FROM
        w_ktsg.tb_audi a WHERE a.att_arid=p_arid
        AND att_var=0 AND att_arver=0
        AND (
                     (p_dstart > a.att_arstart ----- дата начала действия должна быть внутри интервала
                                    OR
                                    (   (p_dstart=p_start 
                                         and p_dstart = a.att_arstart
                                        )
                                        or 
                                      (
                                         p_dstart = a.att_arstart
                                             AND
                                         f_get_first_arid(a.att_auth)-p_farid <= 0
                                         and
                                         p_start<>p_dstart
                                       )
                                    )
                     )
                     AND
                     (p_dstart < a.att_arend
                                    OR
                                     (
                                       --p_dstart=p_start or 
                                        (
                                         p_dstart=a.att_arend
                                                                 AND
                                         f_get_first_arid_for_end(a.att_arid)-p_farid>0
                                          and
                                          p_dstart<>p_start
                                        )
                                     )
                     )
                     )
        ;
      RETURN 1;
EXCEPTION
      WHEN NO_DATA_fOUND  THEN
      RETURN -1;
   END;
   --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   -- актуальная ли позиция МО на данный интервал
   FUNCTION F_is_mo_actual(
            p_dstart IN DATE,
            p_farid IN NUMBER,
            p_rnpozmo IN NUMBER,
            p_start in date-- дата начала периода расчета - если считаем на эту дату, то 
            --первый арид не учитывается
            ) RETURN INTEGER
      IS
      p_rnps NUMBER;
   BEGIN
        SELECT att_auth INTO p_RNPS
        FROM
        w_ktsg.v_poz_mo_b m WHERE m.rn_pozmo=p_rnpozmo
        AND att_var=0 AND att_arver=0
        AND (
                          (p_dstart > m.att_arstart ----- дата начала действия должна быть внутри интервала
                                    OR
                                    (    (p_dstart=p_start
                                           and p_dstart = m.att_arstart
                                         )                                    
                                          or 
                                       (
                                         p_dstart = m.att_arstart
                                             AND
                                         f_get_first_arid(m.att_auth)-p_farid <= 0
                                         and
                                         p_dstart<>p_start  
                                       )
                                    )
                     )
                     AND
                     (p_dstart < m.att_arend
                                    OR
                                     (   --p_dstart=p_start or 
                                       (
                                         p_dstart=m.att_arend
                                                                 AND
                                         f_get_first_arid_for_end(m.att_arid)-p_farid>0
                                          and
                                          p_dstart<>p_start
                                        )
                                     )
                     )
                     );
      RETURN 1;
EXCEPTION
      WHEN NO_DATA_fOUND  THEN
      RETURN -1;
   END;
      --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      -- дать арид позиции МО актуальный на данный интервал
   FUNCTION F_get_mo_actual(
            p_dstart IN DATE,
            p_farid IN NUMBER,
            p_rnpozmo IN NUMBER,
            p_start IN DATE) RETURN NUMBER
      IS
      arid NUMBER;
      eparm stringarray;
   BEGIN
        SELECT att_arid INTO arid -- max - в случае перекрестных состояний по первому ариду - берем максимальный арид - убран
        FROM
        w_ktsg.v_poz_mo_b m WHERE m.rn_pozmo=p_rnpozmo
        AND att_var=0 AND att_arver=0
        AND (
                     (p_dstart > m.att_arstart ----- дата начала действия должна быть внутри интервала
                                    OR
                                    (  (p_dstart=p_start
                                       AND
                                       p_dstart = m.att_arstart
                                       )
                                       OR 
                                       (p_dstart=m.att_arstart
                                             AND
                                         f_get_first_arid(m.att_auth)-p_farid <= 0
                                         AND p_dstart<>p_start
                                       )
                                    )
                     )
                     AND
                     (p_dstart < m.att_arend
                                    OR
                                     (
                                         p_dstart=m.att_arend
                                                                 AND
                                         f_get_first_arid_for_end(m.att_arid)-p_farid>0
                                         AND p_dstart<>p_start
                                     )
                     )
                     )
        ;
      RETURN arid;
EXCEPTION
      WHEN NO_DATA_fOUND  THEN
      RETURN -1;
      WHEN OTHERS THEN
      Eparm:=StringArray('f_get_mo_actual',
                       p_dstart ,
                       p_farid,
                       p_rnpozmo);
    w_COMMON.Raiseerror(Eparm);
   END;
      --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   FUNCTION F_RASC_K_INL_p(p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL) RETURN t_rrasc_nl
      PIPELINED
      IS
      ba  t_rrasc_nl;
   BEGIN
      ba := f_rasc_k_inl ( p_start, p_end, p_rntv, p_rnispob );
      FOR c IN ba.FIRST .. ba.LAST LOOP
          PIPE ROW (ba(c));
      END LOOP;
      RETURN;
   END;
   --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
FUNCTION F_GET_TD_INTERVALS(
         p_ARIDMO IN NUMBER, -- МО для которого проверяем интервалы
         p_dstart IN DATE, -- Дата начала интервала
         p_farid IN NUMBER, -- Первый арид изменения начала интервала
         p_dend IN DATE, -- Дата конца интервала
         p_rnprich IN NUMBER, -- Изменение которым обусловлено данное состояние
         p_td IN OUT NOCOPY t_node_td
         ) RETURN INTEGER
IS
i INTEGER:=0;
RESULT INTEGER:=0;
  BEGIN
      FOR mo IN (SELECT DISTINCT td.rn_podr_inittd FROM w_ktsg.v_tehn_dob_s_wa td
           WHERE td.arid_pozmo=p_aridmo
           ORDER BY 1) LOOP
               FOR moss IN (SELECT ms.rn_podr_inittd,ms.tehndob,
               ams.ATT_ARID,ams.ATT_ARSTART,ams.ATT_AREND,ams.ATT_ARVER,ams.ATT_AUTH  FROM w_ktsg.v_tehn_dob_s_wa ms
                        JOIN w_ktsg.v_audi ams
                        ON ms.att_arid=ams.ATT_ARID AND
                               ms.objtype=ams.ATT_OBJTYPE AND
                               ams.ATT_VAR=0 AND ams.att_arver=nvl2(ams.ATT_ARDIS, 1, 0)
                               --JOIN tb_auth_farid fa ON ams.att_auth=fa.att_auth
                                AND (
                                                           (p_dstart < ams.att_arend AND -- Дата конца состояний для раскомплектовки до изменений должна быть внутри интервала
                                                            p_dend >= ams.att_arend AND
                                                            p_rnprich = -1)
                                                          OR
                                                           -- Завершение
                                                           (
                                                             (   p_dstart < ams.att_arend
                                                                        OR -- дата завершения действия должна быть внутри интервала
                                                              (p_dstart = ams.att_arend
                                                              -- Чтоб при изменениях с одной даты попадали состояния идущие по состоянию своих изменений после верхнего
                                                              AND
                                                              w_mmkt.pk_tresult2.f_get_first_arid_for_end(ams.att_arid)-p_farid >= 0
                                                              AND p_rnprich<>-1
                                                              )
                                                           )
                                                               AND
                                                             (   p_dend > ams.att_arend
                                                                 OR
                                                                 (
                                                                 p_dend=ams.att_arend
                                                                  AND
                                                                  w_mmkt.pk_tresult2.f_get_first_arid_for_end(ams.att_arid)-p_farid < 0
                                                                 )
                                                            )
                                                            )
                                                          OR
                                                          -- Начало
                                                           (
                                                              (p_dstart < ams.att_arstart ----- дата начала действия должна быть внутри интервала
                                                                        OR
                                                                 (p_dstart = ams.att_arstart
                                                                  AND
                                                                  f_get_first_arid(ams.att_auth)-p_farid >= 0
                                                                )
                                                              )
                                                              AND
                                                            (p_dend > ams.att_arstart
                                                                   OR
                                                              (
                                                                     p_dstart=ams.att_arstart
                                                                 AND
                                                                     f_get_first_arid(ams.att_auth)-p_farid<0
                                                                 --AND d.rn_prich<>-1
                                                              )
                                                            )
                                                           )
                                                          OR -- Учитываем изменения конца интервала - если дата начала состояния равна дате конца интервала и
                                                         /*     -- дате конца заданного к расчету периода - то берем ее
                                                           (p_end=p_dend AND
                                                            ams.att_arstart=p_end
                                                           )
                                                          OR*/
                                                            (p_dstart > -- То что действует на всем интервале и не аннулировано
                                                            ams.att_arstart AND
                                                            p_dend < ams.att_arend AND
                                                            ams.att_ardis IS NULL
                                                            )
                                                       )
                 WHERE ms.rn_podr_inittd=mo.rn_podr_inittd AND ms.arid_pozmo=p_aridmo
                 ORDER BY att_arid) LOOP
                        p_td.EXTEND;
                        p_td(p_td.LAST) := T_NODE_td_EL(NULL,NULL,NULL,NULL,NULL,NULL,NULL);
                        p_td(p_td.LAST).att_auth := moss.att_auth;
                        p_td(p_td.LAST).att_arstart := moss.att_arstart;
                        p_td(p_td.LAST).att_arend := moss.att_arend;
                        p_td(p_td.LAST).att_arver := moss.att_arver;
                        p_td(p_td.LAST).arid_td := moss.att_arid;
                        p_td(p_td.LAST).rn_podr_inittd := moss.rn_podr_inittd;
                        p_td(p_td.LAST).tehndob := moss.tehndob;
                        i:=i+1;
                        END LOOP;
                       --IF i >1 THEN
                                           result:=RESULT+i;
                     --END IF;
                     i:=0;
           END LOOP;
           RETURN RESULT;
  END;
   --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
PROCEDURE  P_GET_MO_INTERVALS(
         p_allstart IN DATE,
         p_rntv IN NUMBER, -- ТВ для которого проверяем интервалы
         p_dstart IN DATE, -- Дата начала интервала
         p_farid IN NUMBER, -- Первый арид изменения начала интервала
         p_dend IN DATE, -- Дата конца интервала
         p_earid in NUMBER, --Первый арид изменения след интервала
         p_rnprich IN NUMBER, -- Изменение которым обусловлено данное состояние
         p_result OUT NUMBER,
         p_mos IN OUT NOCOPY t_node_mo,
         p_intv OUT  NOCOPY t_node_mo
         )
IS
vI INTEGER:=0;
i INTEGER:=0;
RESULT INTEGER:=0;
tmpEarid number;
r NUMBER;
  BEGIN
  IF p_rntv=32371  THEN
     dbms_output.put_line('p_mo_int ' || to_char(p_dstart,'DD.MM.YYYY HH24:MI:SS') );
  END IF;
p_intv:= t_node_mo();
      FOR mo IN (SELECT m.RN FROM w_ktsg.v_poz_mo m
           WHERE m.rn_tv=p_rntv
           ORDER BY pornom) LOOP -- Все иницаторы какие есть в этой позиции
               FOR moss IN (SELECT ms.rn_pozmo,
               ams.ATT_ARID,ams.ATT_ARSTART,ams.ATT_AREND,ams.ATT_ARVER,ams.ATT_AUTH,ams.att_ardis  FROM w_ktsg.v_poz_mo_s_wa ms
                        JOIN w_ktsg.v_audi ams
                        ON ms.att_arid=ams.ATT_ARID AND
                               ms.objtype=ams.ATT_OBJTYPE AND
                               ams.ATT_VAR=0 AND ams.att_arver=0--nvl2(ams.ATT_ARDIS, 1, 0)
                               --JOIN tb_auth_farid fa ON ams.att_auth=fa.att_auth
                                AND (
                                                           (p_dstart < ams.att_arend AND -- Дата конца состояний для раскомплектовки до изменений должна быть внутри интервала
                                                            p_dend >= ams.att_arend AND
                                                            p_rnprich = -1)
                                                          OR
                                                           -- Завершение
                                                           (
                                                             (   p_dstart < ams.att_arend
                                                                        OR -- дата завершения действия должна быть внутри интервала
                                                              (p_dstart = ams.att_arend
                                                              -- Чтоб при изменениях с одной даты попадали состояния идущие по состоянию своих изменений после верхнего
                                                              AND
                                                              w_mmkt.pk_tresult2.f_get_first_arid_for_end(ams.att_arid)-p_farid > 0
                                                              AND p_rnprich<>-1
                                                              )
                                                           )
                                                               AND
                                                             (   p_dend > ams.att_arend
                                                                 OR
                                                                 (
                                                                 p_dend=ams.att_arend
                                                                  AND
                                                                  w_mmkt.pk_tresult2.f_get_first_arid_for_end(ams.att_arid)-p_farid < 0
                                                                 )
                                                            )
                                                            )
                                                          OR
                                                          -- Начало
                                                           (
                                                              (p_dstart < ams.att_arstart ----- дата начала действия должна быть внутри интервала
                                                                        OR
                                                                 (p_dstart = ams.att_arstart
                                                                  AND
                                                                  (select farid from w_mmkt.tb_auth_farid where att_auth=ams.att_auth)
                                                                  /*f_get_first_arid(ams.att_auth)*/-p_farid >= 0
                                                                )
                                                              )
                                                              AND
                                                            (p_dend > ams.att_arstart
                                                                   OR
                                                              (
                                                                     p_dend=ams.att_arstart -- p_dstart on p_dend 17.09.2008
                                                                 AND
                                                                 (select farid from w_mmkt.tb_auth_farid where att_auth=ams.att_auth)
                                                                    /*f_get_first_arid(ams.att_auth)*/-p_earid<0 -- p_farid on p_earid 17.09.2008
                                                                 --AND d.rn_prich<>-1
                                                              )
                                                            )
                                                           )
                                                         -- OR -- Учитываем изменения конца интервала - если дата начала состояния равна дате конца интервала и
                                                         /*     -- дате конца заданного к расчету периода - то берем ее
                                                           (p_end=p_dend AND
                                                            ams.att_arstart=p_end
                                                           )
                                                          OR*/
                                                        /*    (p_dstart > -- То что действует на всем интервале и не аннулировано
                                                            ams.att_arstart AND
                                                            p_dend < ams.att_arend AND
                                                            ams.att_ardis IS NULL
                                                            ) */
                                                            OR
                                                            (
                                                            (p_dstart > -- То что действует на всем интервале и не аннулировано
                                                            ams.att_arstart
                                                            OR (
                                                            p_dstart=ams.att_arstart
                                                                                    AND
                                                                (select farid from w_mmkt.tb_auth_farid where att_auth=ams.att_auth)
                                                                /*pk_tresult3.f_get_first_arid(ams.att_auth)*/-p_farid <= 0
                                                            )
                                                            )
                                                             AND
                                                             (p_dend < ams.att_arend
                                                                    OR (
                                                                    p_dend=ams.att_arend
                                                                    AND
                                                                    pk_tresult3.f_get_first_arid_for_end(ams.att_arid)-p_earid >=0
                                                                    )
                                                            ) AND
                                                            ams.att_ardis IS NULL
                                                            )
                                                       )

                 WHERE ms.rn_pozmo=mo.rn
                 ORDER BY att_arid) LOOP
                        p_mos.EXTEND;
                        p_mos(p_mos.LAST) := T_NODE_mo_EL(NULL,null,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
                        IF moss.att_arstart > p_dstart OR (moss.att_arstart = p_dstart AND f_get_first_arid(moss.att_auth)>p_farid AND p_rnprich<>-1) OR (p_rnprich=moss.att_auth AND moss.att_arstart=p_dstart) THEN --Встретили изменение
                           -- Началось  внутри интервала
                           p_mos(p_mos.LAST).att_auth := moss.att_auth;
                           p_mos(p_mos.LAST).att_arstart :=     moss.att_arstart;
                           p_mos(p_mos.LAST).farid  := f_get_first_arid(moss.att_auth);
                        ELSE
                            -- Началось вне(до) интервала
                            p_mos(p_mos.LAST).att_auth := p_rnprich;--moss.att_auth;
                            p_mos(p_mos.LAST).att_arstart := p_dstart;
                            p_mos(p_mos.LAST).farid :=p_farid;
                            -- Изменение - состояние начало действовать до интервала
                        END IF;
            tmpEarid := f_get_first_arid_for_end(moss.att_arid);
            IF moss.att_arend > p_dend OR (moss.att_arend =p_dend AND tmpEarid>p_earid) THEN
               --Состояние закончилось вне(после) интервала
               p_mos(p_mos.LAST).att_arend := p_dend;
               p_mos(p_mos.LAST).earid := p_earid;
            ELSE
              --Состояние закончилось до интервала
               p_mos(p_mos.LAST).att_arend := moss.att_arend;
               p_mos(p_mos.LAST).earid := tmpEarid;
            END IF;
            --p_mos(p_mos.LAST).att_auth := moss.att_auth;
            --p_mos(p_mos.LAST).att_arstart := moss.att_arstart;
            --p_mos(p_mos.LAST).att_arend := moss.att_arend;
            p_mos(p_mos.LAST).att_arver := moss.att_arver;
            p_mos(p_mos.LAST).arid_mo := moss.att_arid;
            p_mos(p_mos.LAST).rn_pozmo := moss.rn_pozmo;
            p_mos(p_mos.LAST).att_ardis:=moss.att_ardis;
            p_mos(p_mos.LAST).tds := t_node_td();
            p_mos(p_mos.LAST).tds.DELETE;
            IF F_GET_TD_INTERVALS(moss.att_arid, moss.att_arstart,  f_get_first_arid(moss.att_auth), moss.att_arend, moss.att_auth, p_mos(p_mos.LAST).tds) >0 THEN
                       FOR tds IN (SELECT DISTINCT att_arstart,att_auth FROM TABLE(p_mos(p_mos.LAST).tds) ) LOOP

                           IF (tds.att_arstart>p_dstart OR (tds.att_arstart=p_dstart AND f_get_first_arid(tds.att_auth)>p_farid AND p_allstart<>tds.att_arstart) ) AND
                                 (tds.att_arstart<p_dend OR (tds.att_arstart=p_dend AND f_get_first_arid(tds.att_auth)<p_earid) ) THEN

                           SELECT COUNT(*) INTO r FROM TABLE(p_mos) WHERE att_arstart=tds.att_arstart AND farid=f_get_first_arid(tds.att_auth);
                           IF r=0 THEN
                              p_mos.EXTEND;
                              p_mos(p_mos.LAST) := T_NODE_mo_EL(NULL,null,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
                              p_mos(p_mos.LAST).att_arstart :=     tds.att_arstart;
                              p_mos(p_mos.LAST).farid  := f_get_first_arid(tds.att_auth);
                              p_mos(p_mos.LAST).att_auth  := tds.att_auth;
                           END IF;
                          END IF;
                       END LOOP;
                       result:=RESULT+1000;
            END IF;
            i:=i+1;
            END LOOP;
                       IF i >1 THEN
                                           result:=RESULT+i;
                     END IF;
                                                                  i:=0;
           END LOOP;
           --Формируем таблицу объединения интервалов
           SELECT count(*) INTO vI FROM table(p_mos) WHERE att_arstart=p_dstart AND farid=decode(p_rnprich,-1,-1,f_get_first_arid(p_rnprich));
           i:=0;
           IF p_rntv=154483 THEN
                      dbms_output.put_line ('m1- ' ||p_intv.COUNT );
           END IF;
           FOR c IN (
                SELECT att_arstart,
                decode(att_auth,-1,-1,decode(rownum,1,p_farid,farid)) as farid,
                lead(att_arstart,1,p_dend) over (PARTITION BY 1 ORDER BY att_arstart,farid) AS att_arend,
                lead(farid,1,p_earid) over (PARTITION BY 1 ORDER BY att_arstart,farid) AS earid,
                att_auth
           FROM (SELECT att_arstart, farid, CASE WHEN att_arstart=p_allstart THEN
                -1 ELSE
                att_auth
                END AS att_auth FROM table(p_mos)
                UNION
                SELECT att_arend AS att_arstart, earid AS farid, (SELECT att_auth FROM tb_auth_farid  a1 WHERE a1.farid=earid) AS att_auth
                  FROM table(p_mos) WHERE att_arend<p_dend OR (att_arend=p_dend AND earid<p_earid)
                UNION
                 SELECT p_dstart,p_farid,p_rnprich FROM dual WHERE vI=0
                ORDER BY att_arstart
                )
                 -- Чтоб первый интервал оставался
           ) LOOP
                        p_intv.EXTEND;
                        p_intv(p_intv.LAST) := T_NODE_mo_EL(NULL,NULL,NULL,null,NULL,NULL,NULL,NULL,NULL,NULL);
                        p_intv(p_intv.LAST).att_arstart:=c.att_arstart;
                        p_intv(p_intv.LAST).att_arend:=c.att_arend;
                        p_intv(p_intv.LAST).att_auth:=c.att_auth;
                        p_intv(p_intv.LAST).farid:=c.farid;
                        p_intv(p_intv.LAST).earid:=c.earid;
                        --p_intv(p_intv.LAST):=p_intv(p_intv.LAST);
                        --dbms_output.put_line('m2- ' || p_intv(p_intv.LAST).att_auth ||  ' ' || p_intv(p_intv.LAST).farid || ' ' || p_intv(p_intv.LAST).att_arstart);
                        i:=i+1;
           END LOOP;
           IF p_rntv=1558697 AND 1=0 THEN
                      dbms_output.put_line ('m2- ' ||p_intv.COUNT );
                       FOR c IN (SELECT att_arstart, farid, CASE WHEN att_arstart=p_allstart THEN
                -1 ELSE
                att_auth
                END AS att_auth FROM table(cast(p_mos AS t_node_mo))
                UNION
                SELECT att_arend AS att_arstart, earid AS farid, (SELECT att_auth FROM tb_auth_farid  a1 WHERE a1.farid=earid) AS att_auth
                  FROM table(cast(p_mos AS t_node_mo)) WHERE att_arend<p_dend OR (att_arend=p_dend AND earid<p_earid)
                UNION
                 SELECT p_dstart,p_farid,p_rnprich FROM dual WHERE vI=0
                ORDER BY att_arstart
                       ) LOOP
                                    dbms_output.put_line('m3- ' || c.att_arstart ||  ' ' || c.farid || ' ' || c.att_auth);
                       END LOOP;
           END IF;
           IF i=1 THEN
              i:=0;
           END IF;           
           p_result:= RESULT+i;
  EXCEPTION
           WHEN OTHERS THEN
         dbms_output.put_line('Error while mo intervals '|| SQLERRM);
  END;
   --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Чисто раскомплектовка - чтобы найти ДСЕ где два
FUNCTION F_RASC_K_INL(p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL) RETURN t_rrasc_nl
IS
      ba  t_rrasc_nl;
      x   PLS_INTEGER := 1; -- Текущий уровень
      num PLS_INTEGER := 0; -- Кол-во записей в коллекции
BEGIN
     ba := t_rrasc_nl();
FOR c IN (SELECT a.rn_ispob,
                       a.rn AS rn_c,
                       -1 AS rn_kuda,
                       1.0 AS kol,
                       1.0 AS ak,
                       1.0 AS oldkol,
                       x AS urov
                  FROM w_ktsg.v_tv a
                 INNER JOIN w_ktsg.v_tv_s_wa tvs ON a.rn = tvs.rn_tv
                 INNER JOIN w_ktsg.v_audi aa ON aa.ATT_ARID = tvs.ATT_ARID
                                            AND aa.ATT_ARVER = 0
                                            AND aa.ATT_VAR = 0
                 WHERE w_ktsg.pk_VALUES.CURDATE < aa.att_arend
                   AND w_ktsg.pk_VALUES.CURDATE >= aa.att_arstart
                   AND a.rn = p_rntv) LOOP
         ba.EXTEND;
         ba(ba.LAST) :=
          t_rrasc_elem(-1, -- farid
                                   c.rn_ispob , --AS isp_k
                                   c.rn_kuda , --AS tv_k
                                   c.rn_ispob , --AS isp_ch
                                   NULL, -- tv_ch
                                   c.urov, --
                                   nvl(p_start, to_date('1.01.2007','DD.MM.YYYY')),
                                   nvl(p_end, to_date('1.10.2008','DD.MM.YYYY')),
                                   NULL,
                                   -1,
                                   NULL,
                                   NULL
                                   );
--               dbms_output.put_line(c.rn_ispob);



      END LOOP;
      --***********************************************************************
      LOOP
         FOR c IN (SELECT b.*, (x + 1) AS urov
                     FROM (
                           --leading (d) use_nl(d s) use_nl(s C)
                           SELECT --+ leading(d) use_nl(d s) use_nl(s a) use_nl(s C)
                             d.dstart,
                             d.dend,
                             d.rn_prich,
                             d.farid,
                             d.rnisp_c,
                             ksp.*
--                             ,ksp.kol_o * d.kol /**tvs.DOLY*/ AS kol,


                             FROM TABLE(CAST(ba AS t_rrasc_nl)) d
                             join
                             (
                             SELECT -- УСТАНОВКА КОМПОНЕНТ
                                    tv.rn_ispob, -- Исп куда
                                    s.rn_ispob_ch, -- Исп что
                                    s.rn_tv, -- ТВ куда
                                    tvc.RN AS TV_CH, -- ТВ что
                                    NULL AS TV_IZG, -- С кем совместно изготавливается
                                    s.kol /**tvs.DOLY*/ AS kol_o,
                                    a.ATT_ARSTART,
                                    a.att_arend,
                                    a.att_auth,
                                    a.att_ardis,
                                    att_arver,
                                    rn_pozmo,
                                    '1' AS ind,
                                    a.att_arid,
                                    NULL AS arid_zo, --арид кого защищает образец
                                    a.ATT_PREVARID
                             from
                              w_ktsg.v_tv tv
                             JOIN w_ktsg.tb_ust_comp_s s ON tv.rn = s.rn_tv
                             JOIN w_ktsg.v_audi a ON
                                                 s.att_arid = a.att_arid
                                                 AND a.ATT_VAR = 0
                                                 AND a.att_arver = NVL2(a.att_ardis, 1, 0)
                              LEFT JOIN w_ktsg.v_tv tvc ON s.rn_ispob_ch=tvc.RN_ISPOB
                             UNION ALL -- ОБРАЗЕЦ
                             SELECT
                             tv.rn_ispob,-- Исп куда - защ объект
                             f_get_rn_ispob(o.rn_tv_obr), -- Исп что - образец
                             t.rn_tv, -- ТВ куда - защ объекта
                             o.rn_tv_obr, -- ТВ что - образец
                             o.rn_tv_izg,
                             1 as kol,
                             a.att_arstart,a.att_arend,a.att_auth,a.att_ardis, a.att_arver,
                             t.rn_pozmo, '3' as ind,a.att_arid,
                             o.arid_pozmo AS arid_zo, --арид кого защищает образец
                             a.ATT_PREVARID
                             FROM
                                    w_ktsg.tb_obr_s o
                                    JOIN w_ktsg.v_audi a on
                                         o.att_arid=a.ATT_ARID and
                                         o.objtype=a.ATT_OBJTYPE and
                                         a.att_var=0 and  a.att_arver = NVL2(a.att_ardis, 1, 0)
                                    JOIN w_ktsg.tb_poz_mo_s t on t.att_arid=o.arid_pozmo
                                    JOIN w_ktsg.v_tv  tv on t.rn_Tv=tv.rn
                           UNION ALL -- ЗАГОТОВКА
                           SELECT
                                 tvz.RN_ISPOB AS rn_ispob, -- Исп куда
                                 tz.rn_ispob_zag AS rn_ispob_ch,-- Исп что
                                 tz.rn_tv AS rn_tv,-- ТВ куда
                                 NULL AS tv_ch,-- ТВ что
                                 NULL AS TV_IZG, -- С кем совместно изготавливается  - только для образцов
                                 tz.normrash /**tvs.DOLY*/ AS kol_o,
                                 az.ATT_ARSTART,
                                 az.att_arend,
                                 az.att_auth,
                                 az.att_ardis,
                                 az.att_arver,
                                 NULL AS rn_pozmo,
                                 '2' AS ind, -- Заготовка
                                 az.att_arid,
                                 NULL AS arid_zo, --арид кого защищает образец
                                 az.ATT_PREVARID
                           FROM
                               w_ktsg.tb_t_zag_s tz
                               JOIN w_ktsg.v_tv tvz ON tz.rn_tv=tvz.RN
                               JOIN w_ktsg.v_audi az ON
                                                            tz.att_arid=az.ATT_ARID AND
                                                            tz.objtype=az.ATT_OBJTYPE AND
                                                            az.ATT_VAR=0 AND az.att_arver=nvl2(az.ATT_ARDIS, 1, 0)


                                                 ) ksp on
                                                       D.rnisp_c = ksp.rn_ispob
                                                       AND d.urov = x AND (
                                                           (d.dstart <= ksp.att_arend AND -- Дата конца состояний для раскомплектовки до изменений должна быть внутри интервала
                                                            d.dend >= ksp.att_arend AND
                                                            rn_prich = -1)
                                                          OR
                                                           (d.dstart <= ksp.att_arend AND -- дата завершения действия должна быть внутри интервала
                                                            d.dend > ksp.att_arend)
                                                          OR
                                                           (d.dstart <= ----- дата начала действия должна быть внутри интервала
                                                           ksp.att_arstart AND
                                                           d.dend > ksp.att_arstart
                                                           )
                                                          OR -- Учитываем изменения конца интервала - если дата начала состояния равна дате конца интервала и
                                                              -- дате конца заданного к расчету периода - то берем ее
                                                           (p_end=d.dend AND
                                                            ksp.att_arstart=p_end
                                                           )
                                                          OR
                                                            (d.dstart > -- То что действует на всем интервале и не аннулировано
                                                            ksp.att_arstart AND
                                                            d.dend < ksp.att_arend AND
                                                            ksp.att_ardis IS NULL
                                                            )
                                                       )
                                              ) b
                    ORDER BY rn_ispob_ch, rn_tv, tv_izg,rn_pozmo, att_arstart ) LOOP
                    IF c.ind=2 AND  c.rn_ispob_ch=F_Get_rn_ispOb(c.rn_tv)  THEN -- Исключение зацикливания по заготовке
                          NULL;
                    ELSE

            --Цикл
            ba.EXTEND;
            ba(ba.LAST) := t_rrasc_elem(
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL);
            ba(ba.LAST).golova := p_rntv;
            ba(ba.LAST).rntv_k := c.rn_tv; --rn_tvk;
            ba(ba.LAST).rntv_c := c.tv_ch;
            ba(ba.LAST).rnisp_c := c.rn_ispob_ch;
            ba(ba.LAST).rnisp_k := c.rnisp_c;
            ba(ba.LAST).urov := c.urov;
            ba(ba.LAST).ind := c.ind;
            IF c.att_arstart > c.dstart THEN --Встретили изменение
               -- Началось  внутри интервала
               ba(ba.LAST).rn_prich := c.att_auth;
               ba(ba.LAST).dstart := c.att_arstart;
               ba(ba.LAST).farid  := f_get_first_arid(c.att_auth);
            ELSE
               -- Началось вне(до) интервала
               ba(ba.LAST).rn_prich := c.rn_prich;
               ba(ba.LAST).dstart := c.dstart;
               ba(ba.LAST).farid :=c.farid;
               -- Изменение - состояние начало действовать до интервала
            END IF;

            IF c.att_arend > c.dend THEN
               --Состояние закончилось вне(после) интервала
               ba(ba.LAST).dend := c.dend;
            ELSE
              --Состояние закончилось до интервала
               ba(ba.LAST).dend := c.att_arend;
            END IF;
            --С той же даты другое изменение
            IF c.att_arstart = c.dstart AND c.rn_prich <> c.att_auth AND c.rn_prich <> -1 THEN
               --Если разные изменения - то
               IF f_get_first_arid(c.rn_prich)<f_get_first_arid(c.att_auth) THEN
                  -- Верхнее раньше нижнего
                  -- Встречалось ли оно раньше
                  ba(ba.LAST).ind_dts := '1';
               ELSE
                  -- Нижнее раньше верхнего
                   ba(ba.LAST).ind_dts := '2';
               END IF;
            ELSE
               ba(ba.LAST).ind_dts := '0';
            END IF;
            END IF;
         END LOOP;
         IF num = ba.COUNT THEN
            EXIT;
         END IF;
         num := ba.COUNT;
         x   := x + 1;
      END LOOP;
      RETURN ba;
END;
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   FUNCTION F_RES_K_start(p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL) RETURN t_res_nl2
                        PIPELINED
      IS
  -- Установка
      TYPE ustnumbers IS  RECORD(
           key NUMBER,
           rn_tv NUMBER,
           isp_chto NUMBER,
           tv_chto NUMBER, -- Если есть ТВ у исп объекта - то делим на два разных объекта
           rn_pozmo NUMBER
     );
     --Образец
      TYPE obrnumbers IS  RECORD(
           key NUMBER,
           tv_izg  NUMBER, -- С кем совм. изготовляется
           tv_obr NUMBER, -- Образец
           arid_mo NUMBER -- Кого защищает
     );
     --Заготовка
      TYPE zagnumbers IS  RECORD(
           key NUMBER,
           rn_tv  NUMBER -- Кто имеет заготовку
     );
      ba  t_res_nl2;
      x   PLS_INTEGER := 1; -- Текущий уровень
      dce_chto_key ustnumbers;   -- Текущий  key, ДСЕ-что и rnpozmo
      dce_chto_key_obr obrnumbers;   -- Текущий key,
      dce_chto_key_zag zagnumbers;   -- Текущий key,

BEGIN
ba := t_res_nl2();

      FOR c IN (SELECT a.rn_ispob,
                       a.rn AS rn_c,
                       -1 AS rn_kuda,
                       1.0 AS kol,
                       1.0 AS ak,
                       1.0 AS oldkol,
                       x AS urov
                  FROM w_ktsg.v_tv a
                 INNER JOIN w_ktsg.v_tv_s_wa tvs ON a.rn = tvs.rn_tv
                 INNER JOIN w_ktsg.v_audi aa ON aa.ATT_ARID = tvs.ATT_ARID
                                            AND aa.ATT_ARVER = 0
                                            AND aa.ATT_VAR = 0
                 WHERE w_ktsg.pk_VALUES.CURDATE < aa.att_arend
                   AND w_ktsg.pk_VALUES.CURDATE >= aa.att_arstart
                   AND a.rn = p_rntv) LOOP
         ba.EXTEND;
         ba(ba.LAST) :=   /*t_res_elem(NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL,
                                               NULL);*/

          t_res_elem2(-1,
                      -1,
                      -1,
                                   c.rn_ispob , --AS isp_k
                                   c.rn_c , --AS tv_k
                                   c.rn_ispob , --AS isp_ch
                                   c.rn_c,
                                   c.oldkol,
                                   c.kol,
                                   c.ak,
                                   c.urov,
                                   nvl(p_start, to_date('1.01.2007','DD.MM.YYYY')),
                                   nvl(p_end, to_date('1.10.2008','DD.MM.YYYY')),
                                   NULL,
                                   -1,
                                   NULL,
                                   NULL,
                                   null,--T_NODE_IZM(),
                                   1,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL
                                   );
               dbms_output.put_line(c.rn_ispob);

               dce_chto_key.rn_tv:=1;
               dce_chto_key.key:=1;
               dce_chto_key.isp_chto:=c.rn_ispob;
               dce_chto_key.rn_pozmo:=1;
               dce_chto_key.tv_chto:=null;

               dce_chto_key_obr.key:=1;
               dce_chto_key_obr.tv_obr:=1;
               dce_chto_key_obr.arid_mo:=1;
               dce_chto_key_obr.tv_izg:=1;

               dce_chto_key_zag.key:=1;
               dce_chto_key_zag.rn_tv:=1;

      END LOOP;
      FOR c IN ba.FIRST .. ba.LAST LOOP
          PIPE ROW (ba(c));
      END LOOP;
      RETURN;

END;
   --!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   -- 15.05.2008 - Работы по учету изменений которые вступают в силу с одной даты
   --                     Решения:
   --                    1) Включить в  разбивку на интервалы
   --                    2) Сделать логику анализа дат и аридов чтоб соответствующие состояния были в результате
   --
   -- Function and procedure implementations

   FUNCTION F_RES_K_INL(
                        trall IN OUT NOCOPY t_rec_all,
                        p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL,
                        p_part IN NUMBER DEFAULT 1
                        ) RETURN INTEGER --t_rec_all
      IS
      --trall t_rec_all;
  -- Установка
      TYPE ustnumbers IS  RECORD(
           key PLS_INTEGER,
           rn_tv NUMBER,
           isp_chto NUMBER,
           tv_chto NUMBER, -- Если есть ТВ у исп объекта - то делим на два разных объекта
           rn_pozmo NUMBER
     );
  -- Образец
      TYPE obrnumbers IS  RECORD(
           key PLS_INTEGER,
           tv_izg  NUMBER, -- С кем совм. изготовляется
           tv_obr NUMBER, -- Образец
           arid_mo NUMBER -- Кого защищает
     );
     --Заготовка
      TYPE zagnumbers IS  RECORD(
           key PLS_INTEGER,
           rn_tv  NUMBER -- Кто имеет заготовку
     );
      --ba  t_res_nl3;
      x   PLS_INTEGER := 1; -- Текущий уровень
      num PLS_INTEGER := 0; -- Кол-во записей в коллекции
      key PLS_INTEGER:=1; -- текущий вставляемый key
      oldkey PLS_INTEGER; -- предыдущий key
      dce_chto_key ustnumbers;   -- Текущий  key, ДСЕ-что и rnpozmo
      dce_chto_key_obr obrnumbers;   -- Текущий key,
      dce_chto_key_zag zagnumbers;   -- Текущий key,
      r PLS_INTEGER; -- Для прохода по циклу изменений в ветке
      --izm_cnt PLS_INTEGER; -- Кол-во изменений пройденных в ветке
      --strsql CLOB; -- Текст запроса который выполняется

--      t tb_int_dstart;
      --kol3 NUMBER; -- Временная для расчета кол-ва
      --uf NUMBER; -- Полная применяемость ДСЕ куда
      intv t_res_tb_intv;
    -- Создаем отдельные таблицы
      --dez_idx PLS_INTEGER:=1;
      dez_i VARCHAR2(45);
      dez_i2 VARCHAR2(45);
      dfarid_idx PLS_INTEGER:=1;
--      disp_idx PLS_INTEGER:=1;
      disp_i VARCHAR2(41);
      vIsp VARCHAR2(10); -- Чтоб хранить Исп
      vEz VARCHAR2(3); -- Чтоб хранить Ez
      vEz2 VARCHAR2(3); -- Чтоб хранить Ez
      --cnt_intv_v PLS_INTEGER; -- Временная для прохождения по интервалам
      --tb_rint rec_int_farid;
      --tb_kol rec_ez;
      tb_td  pk_tresult3.tb_td;
      m NUMBER; -- Временная для прохождения по техдобавкам
      n NUMBER;
      fl_relink boolean:=false;
      fl_first_record integer:=1; -- Обрабатываем уровень 0
      --cnt_rec INTEGER:=0; --Счетчик отработанных записей
      fromstart DATE; -- Откуда копируем
      fromfarid NUMBER;--Откуда копируем
--      nmo t_node_mo;
      n_ez NUMBER;
      --tmpFlag INTEGER:=0;
      izdPornom NUMBER;
      izdPozmo NUMBER;
--
      vRN_Pozmo       PLS_INTEGER; -- Позиция для которой счатаем из- за заготовки
      vFaridNext NUMBER; -- Farid следующего за текущим состояния
      vDstart DATE;
      vFarid NUMBER;
      vInd_new CHAR(1);
      vRn_Prich NUMBER;
      cycrn_ispob_ch number;
      cycez NUMBER;
      cycrn_pozmo NUMBER;
      tmpEarid number;
      tmpmo_states t_node_mo;
      tmpmo_intv t_node_mo;
      iExists PLS_INTEGER;
      iExists2 PLS_INTEGER;
      iExists3 PLS_INTEGER;
      iExists4 PLS_INTEGER;
      vAp NUMBER;
      yntd tb_yntd; --Хранит для ТВ - есть/нет ТД
      vRN_Pozmo2   PLS_INTEGER; -- Позиция для которой счатаем - с учетом отсутствия тех добавок
      cntI pls_integer:=0;
      cntI2 pls_integer:=0;
      cntI3 pls_integer:=0;
      cntI4 pls_integer:=0;
      cntI5 pls_integer:=0;
      vTmp VARCHAR2(100);
      ez_am t_res_ez_am;
      oldr PLS_INTEGER:=0;
      r2 PLS_INTEGER:=0;
      oldr2 PLS_INTEGER:=0;
      res_sequence pls_integer:=0;
      Fl_forall CHAR(1):=NULL; -- Флаг - что состояние действует на всех интервалах
      Fl_forallo CHAR(1):=NULL; -- Флаг - что состояние собственное действует на всех интервалах
      fl_forall_p BOOLEAN:=FALSE;
      vpdStart DATE;--
      vpFarid NUMBER;--      
      ufTmp NUMBER;
      vInd CHAR(1);
      vInd_Add CHAR(1); --Устанавливается когда добавили интервал
   BEGIN
      trall.ba := t_res_nl3();
      intv:= t_res_tb_intv();


      --Добавляем один элемент
      INTv.EXTEND;
      intv(INTv.LAST) := t_res_intv(p_start,-1);
      --trall.intv(to_char(p_start,'DD.MM.YYYY HH24:MI:SS'))(-1).ind:=null;

      trall.ddstart( to_char(p_start,'DD.MM.YYYY HH24:MI:SS') ):='1';
--      trall.ddstart(trall.ddstart.LAST).rn:=to_char(p_start,'DD.MM.YYYY HH24:MI:SS');

      trall.dfarid(to_char(p_start,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(-1)).ind:=NULL;
      dfarid_idx:=dfarid_idx+1;

      FOR c IN (SELECT a.rn_ispob,
                       a.rn AS rn_c,
                       -1 AS rn_kuda,
                       1.0 AS kol,
                       1.0 AS ak,
                       1.0 AS oldkol,
                       x AS urov
                  FROM w_ktsg.v_tv a
                 INNER JOIN w_ktsg.v_tv_s_wa tvs ON a.rn = tvs.rn_tv
                 INNER JOIN w_ktsg.v_audi aa ON aa.ATT_ARID = tvs.ATT_ARID
                                            AND aa.ATT_ARVER = 0
                                            AND aa.ATT_VAR = 0
                 WHERE w_ktsg.pk_VALUES.CURDATE < aa.att_arend
                   AND w_ktsg.pk_VALUES.CURDATE >= aa.att_arstart
                   AND a.rn = p_rntv) LOOP
         trall.ba.EXTEND;
         trall.ba(trall.ba.LAST) :=
          t_res_elem3(-1,
                      -1,
                      -1,
                                   c.rn_ispob , --AS isp_k
                                   c.rn_c , --AS tv_k
                                   c.rn_ispob , --AS isp_ch
                                   c.rn_c, --as tv_ch
                                   c.kol,
                                   --c.ak,
                                   c.urov,
                                   nvl(p_start, to_date('1.01.2007','DD.MM.YYYY')),
                                   nvl(p_end, to_date('1.10.2008','DD.MM.YYYY')),
                                   999999999999999999999999999, --earid
                                   NULL,
                                   -1,
                                   --NULL, --deltakol
                                   NULL,
                                   1,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   w_mmk_raskomp.f_ei_flag(52));

               dce_chto_key.rn_tv:=1;
               dce_chto_key.key:=1;
               dce_chto_key.isp_chto:=c.rn_ispob;
               dce_chto_key.rn_pozmo:=1;
               dce_chto_key.tv_chto:=null;

               dce_chto_key_obr.key:=1;
               dce_chto_key_obr.tv_obr:=1;
               dce_chto_key_obr.arid_mo:=1;
               dce_chto_key_obr.tv_izg:=1;

               dce_chto_key_zag.key:=1;
               dce_chto_key_zag.rn_tv:=1;
      END LOOP;


      --***********************************************************************
      LOOP
     -- IF x>2 THEN EXIT;   END IF;
     BEGIN
      select
       min(l.pornom) into izdPornom
      from
       w_ktsg.tb_poz_mo l
      where l.rn_tv=p_rntv and l.pornom>0;

     select
      s.rn_pozmo into
      izdPozmo
     from
      w_ktsg.tb_poz_mo_s s,
      w_ktsg.tb_audi a,
      w_ktsg.tb_poz_mo mo
     where
      mo.rn=s.rn_pozmo and mo.pornom=izdPornom and
      s.rn_tv=p_rntv and s.att_arid=a.att_arid and
      s.objtype=a.att_objtype and p_Start<a.att_arend and
      p_Start>=a.att_arstart and a.att_arver=0 and a.att_var=0;
      EXCEPTION
               WHEN no_DATA_FOUND THEN
               izdPornom:=null;
               izdPozmo:=NULL;
      END;
         FOR c IN (
         select
         0 as base,
         d.dstart,
         d.dend,
         --d.oldkol,
         --d.ak,
         d.rn_prich,
         d.ardis,
         d.farid,
         d.earid,
         d.rnisp_C as rnisp_k,
         d.key,
         d.ind_new,
         d.rnISP_c AS rn_ispob,
         d.rnisp_C AS rn_ispob_ch,
         p_rntv AS rn_tv,
         p_rntv AS tv_ch,
         1 AS TV_IZG,
         1 AS kol_o,
         sysdate as ATT_ARSTART,
         sysdate AS att_arend,
         1 as att_auth,
         '1' as att_ardis,
         1 AS att_arver,
         nvl(izdPozmo,0) AS rn_pozmo,
         '0' AS ind,
         1 AS att_arid,
         1 AS arid_zo,
         null as ATT_PREVARID,
         52 AS ez,
         w_mmk_raskomp.f_ei_flag(52) as flag,
         d.att_arid as arid_k,
         p_part AS kol,
         --d.izms as izms,
         1 as ran,
         1 as urov
          FROM TABLE(CAST(trall.ba AS t_res_nl3)) d
          WHERE fl_first_record =1
          union all(
         SELECT ---full(d)
         1 as base,b.*, (x + 1) AS urov
                     FROM (--- leading(d) use_nl(d s) use_nl(s a) use_nl(s C) use_nl(ksp d)
                           SELECT --+ first_rows leading(d)
                             d.dstart
                             ,d.dend,
                             --d.oldkol,
                             --d.ak*decode (ksp.ind,1,ksp.kol_o,0) * nvl2(ksp.att_ardis,0,1) AS ak,
                             d.rn_prich,
                             d.ardis,
                             d.farid,
                             d.earid,
                             d.rnisp_c AS rnisp_k,
                             d.key,
                             d.ind_new,
                             ksp.*,
--                             ,ksp.kol_o * d.kol /**tvs.DOLY*//* AS kol,
                             d.att_arid as arid_k,
                             ksp.kol_o AS kol,
                             --d.izms,
                             rank() over (PARTITION BY d.key,ksp.tv_ch ORDER BY ksp.att_arid) AS ran
                             FROM TABLE(CAST(trall.ba AS t_res_nl3)) d
                             JOIN
                             (
                             SELECT --+ leading(tv) use_nl(tv s a tvc)  index(tv AK1_TV)
                             -- УСТАНОВКА КОМПОНЕНТ
                                    tv.rn_ispob, -- Исп куда
                                    s.rn_ispob_ch, -- Исп что
                                    s.rn_tv, -- ТВ куда
                                    nvl(tvc.RN,1) AS TV_CH, -- ТВ что NULL введен из за дублирования записей при двух технологических вариантах
                                    NULL AS TV_IZG, -- С кем совместно изготавливается
                                    s.kol /**tvs.DOLY*/ AS kol_o,
                                    a.ATT_ARSTART,
                                    a.att_arend,
                                    a.att_auth,
                                    a.att_ardis,
                                    att_arver,
                                    rn_pozmo,
                                    '1' AS ind,
                                    a.att_arid,
                                    NULL AS arid_zo, --арид кого защищает образец
                                    a.ATT_PREVARID,
                                    s.rn_ei_ust AS ez,
                                    w_mmk_raskomp.f_ei_flag(rn_ei_ust) as flag
                             from
                              w_ktsg.v_tv tv
                             JOIN w_ktsg.tb_ust_comp_s s ON tv.rn = s.rn_tv
                             JOIN w_ktsg.v_audi a ON
                                                 s.att_arid = a.att_arid
                                                 AND a.ATT_VAR = 0
                                                 AND a.att_arver =0-- NVL2(a.att_ardis, 1, 0)
                              LEFT JOIN w_ktsg.v_tv tvc ON s.rn_ispob_ch=tvc.RN_ISPOB
                              --JOIN tb_auth_farid fa ON a.att_auth=fa.att_auth
                             UNION ALL -- ОБРАЗЕЦ
                             SELECT --+leading(tv) use_nl(o a t tv) index(tv AK1_TV) star
                             tv.rn_ispob,-- Исп куда - защ объект
                             w_mmkt.f_get_rn_ispob(o.rn_tv_obr), -- Исп что - образец
                             t.rn_tv, -- ТВ куда - защ объекта
                             o.rn_tv_obr, -- ТВ что - образец
                             o.rn_tv_izg,
                             1 as kol,
                             a.att_arstart,
                             a.att_arend,
                             a.att_auth,
                             a.att_ardis,
                             a.att_arver,
                             t.rn_pozmo,
                             '3' as ind,
                             a.att_arid,
                             o.arid_pozmo AS arid_zo, --арид кого защищает образец
                             a.ATT_PREVARID,
                             52 AS ez,
                             w_mmk_raskomp.f_ei_flag(52) as flag
                             FROM
                                    w_ktsg.tb_obr_s o
                                    JOIN w_ktsg.v_audi a on
                                         o.att_arid=a.ATT_ARID and
                                         o.objtype=a.ATT_OBJTYPE and
                                         a.att_var=0 and  a.att_arver =0-- NVL2(a.att_ardis, 1, 0)
                                    JOIN w_ktsg.tb_poz_mo_s t on t.att_arid=o.arid_pozmo
                                    JOIN w_ktsg.v_tv  tv on t.rn_Tv=tv.rn
                                    --JOIN tb_auth_farid fa ON a.att_auth=fa.att_auth
                           UNION ALL -- ЗАГОТОВКА
                           SELECT--+leading(tvz) use_nl(tz tvz az tvcz) index(tvz AK1_TV) star
                                 tvz.RN_ISPOB AS rn_ispob, -- Исп куда
                                 tz.rn_ispob_zag AS rn_ispob_ch,-- Исп что
                                 tz.rn_tv AS rn_tv,-- ТВ куда
/*                                 CASE WHEN f_res_cex_pol_mat(tz.rn_tv,az.ATT_ARSTART,f_get_first_arid(az.att_auth)) IS NOT NULL THEN
                                 (SELECT rn_tv FROM w_ktsg.tb_poz_mo m WHERE m.rn=f_res_cex_pol_mat(tz.rn_tv,az.ATT_ARSTART,f_get_first_arid(az.att_auth)) )
                                 ELSE
                                     NULL
                                 END*/
                                 nvl(tvcz.rn,1) AS tv_ch,-- ТВ что
                                 NULL AS TV_IZG, -- С кем совместно изготавливается  - только для образцов
                                 tz.normrash /**tvs.DOLY*/ AS kol_o,
                                 az.ATT_ARSTART,
                                 az.att_arend,
                                 az.att_auth,
                                 az.att_ardis,
                                 az.att_arver,
                                 f_res_cex_pol_mat(tz.rn_tv,az.ATT_ARSTART,f_get_first_arid(az.att_auth)) AS rn_pozmo,
                                 '2' AS ind, -- Заготовка
                                 az.att_arid,
                                 NULL AS arid_zo, --арид кого защищает образец
                                 az.ATT_PREVARID,
                                 tz.rn_ei AS ez,
                                 w_mmk_raskomp.f_ei_flag(rn_ei) as flag
                           FROM
                               w_ktsg.tb_t_zag_s tz
                               JOIN w_ktsg.v_tv tvz ON tz.rn_tv=tvz.RN
                               JOIN w_ktsg.v_audi az ON
                                                            tz.att_arid=az.ATT_ARID AND
                                                            tz.objtype=az.ATT_OBJTYPE AND
                                                            az.ATT_VAR=0 AND az.att_arver=0--nvl2(az.ATT_ARDIS, 1, 0)
                               LEFT JOIN w_ktsg.v_tv tvcz ON tz.rn_ispob_zag=tvcz.RN_ISPOB
                                --JOIN tb_auth_farid fa ON az.att_auth=fa.att_auth
                                                 ) ksp ON
                                                       D.rnisp_c = ksp.rn_ispob
                                                       AND nvl(d.rntv_c,-15)=nvl(ksp.rn_tv,-15)
                                                       AND d.urov = x
                                                       AND (
                                                           (d.dstart < ksp.att_arend AND -- Дата конца состояний для раскомплектовки до изменений должна быть внутри интервала
                                                            d.dend >= ksp.att_arend AND
                                                            rn_prich = -1)
                                                          OR
                                                           -- Завершение
                                                           (
                                                             (   d.dstart < ksp.att_arend
                                                                        OR -- дата завершения действия должна быть внутри интервала
                                                              (d.dstart = ksp.att_arend
                                                              -- Чтоб при изменениях с одной даты попадали состояния идущие по состоянию своих изменений после верхнего
                                                              AND
                                                              w_mmkt.pk_tresult2.f_get_first_arid_for_end(ksp.att_arid)-d.farid >0--= 0
                                                              AND rn_prich<>-1
                                                              )
                                                           )
                                                               AND
                                                             (   d.dend > ksp.att_arend
                                                                 OR
                                                                 (
                                                                 d.dend=ksp.att_arend
                                                                  AND
                                                                  w_mmkt.pk_tresult2.f_get_first_arid_for_end(ksp.att_arid)-d.farid < 0
                                                                 )
                                                            )
                                                            )
                                                          OR
                                                          -- Начало
                                                           (
                                                              (d.dstart < ksp.att_arstart ----- дата начала действия должна быть внутри интервала
                                                                        OR
                                                                 (d.dstart = ksp.att_arstart
                                                                  AND
                                                                   f_get_first_arid(ksp.att_auth)-d.farid >= 0
                                                                )
                                                              )
                                                              AND
                                                            (d.dend > ksp.att_arstart
                                                                   OR
                                                              (
                                                                     --d.dstart=ksp.att_arstart  07.07.2008
                                                                     d.dend=ksp.att_arstart
                                                                 AND
                                                                     --fa.farid-d.farid<0
                                                                     --f_get_first_arid(ksp.att_auth)-d.farid<0 07.07.2008
                                                                     f_get_first_arid(ksp.att_auth)-d.earid<0
                                                                 --AND d.rn_prich<>-1
                                                              )
                                                            )
                                                           )
                                                          OR -- Учитываем изменения конца интервала - если дата начала состояния равна дате конца интервала и
                                                              -- дате конца заданного к расчету периода - то берем ее
                                                           (p_end=d.dend AND
                                                            ksp.att_arstart=p_end
                                                           )
                                                          OR
                                                            (
                                                            (d.dstart > -- То что действует на всем интервале и не аннулировано
                                                            ksp.att_arstart
                                                            OR (
                                                            d.dstart=ksp.att_arstart
                                                                                    AND
                                                                pk_tresult3.f_get_first_arid(ksp.att_auth)-d.farid <= 0
                                                            )
                                                            )
                                                             AND
                                                             (d.dend < ksp.att_arend
                                                                    OR (
                                                                    d.dend=ksp.att_arend
                                                                    AND
                                                                    pk_tresult3.f_get_first_arid_for_end(ksp.att_arid)-d.earid >=0
                                                                    )
                                                            ) AND
                                                            ksp.att_ardis IS NULL
                                                            )
                                                       )
                                              ) b
                                              )

                    ORDER BY base,key, ind,rn_ispob_ch, tv_ch, rn_tv, tv_izg, rn_pozmo, arid_zo, att_arstart--,ind
                    ) LOOP                    
                    BEGIN
     IF fl_first_record=0 THEN
                    /*IF c.tv_ch=166809 THEN
                       dbms_output.put_line('166809 ' || c.att_arend);
                       dbms_output.put_line('166809 ' || to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') );
                    END IF;*/
                    --w_otk.p_load_log('att_arid=' || c.att_arid || ' rn_Tv=' || c.rn_tv || ' rn_isp= ' || c.rn_ispob_ch || ' ind=' || c.ind,9);
                    IF c.ind=2 AND  c.rn_ispob_ch=F_Get_rn_ispOb(c.rn_tv)  THEN -- Исключение зацикливания по заготовке
                          NULL;
                          GOTO next_state;
                    ELSE


            -- Размножение интервалов - чтоб по дате окончания размножались при удаленном следующем состоянии
            -- Получить арид следующего состояния - чтоб определить его farid
            IF c.att_arend<=p_end THEN
                 vFaridNext:=w_common.pk_audi.GetNextActual(c.att_arid,'1');
                 IF vFaridNext<>-1 THEN
                  --Проверить - является ли след. состояние аннулированием
                 SELECT COUNT(*) INTO r FROM tb_audi a WHERE a.att_arid=vFaridNext AND ((a.att_ardis IS NOT NULL AND c.ind<>2) OR (c.ind =2 ));
                 SELECT f_get_first_arid(att_auth) INTO vFaridNext FROM tb_audi WHERE att_arid=vFaridNext;
                 IF r=1 THEN
                    SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv)) WHERE att_arstart=c.att_arend AND farid=vFaridNext;
                       IF r=0 THEN --Нет такого интервала - создаем
                          intv.EXTEND;
                          intv(intv.LAST):=t_res_intv(c.att_arend, vFaridNext);
                    /*IF (to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')='07.10.2008 00:00:00' AND vFaridNext IN (31027450,31037357,31042187,31045837) )
                              OR ( to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')='03.10.2008 12:06:43' AND vFaridNext=29834344)
                              OR ( to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')='03.10.2008 00:00:00' AND vFaridNext=30924794) THEN
                            dbms_output.put_line('MTV2 ' || c.tv_ch || ' ' ||  c.urov  || to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') || ' '|| vFaridNext );                      
                         END IF;
                    IF (to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')='07.10.2008 00:00:00' AND vFaridNext IN (31042187)) THEN
                            dbms_output.put_line('MTV4 ' || c.tv_ch || ' ' ||  c.urov  || to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') || ' '|| vFaridNext );                      
                               --RETURN 1;
                         END IF;*/

                          -- Копируем все что было в ближайшем кверху интервале в данный
                          -- Скопировать из верхнего интервала все в этот интервал
                          -- копируем из минимального который меньше данного
                               SELECT att_arstart,farid
                               INTO fromstart, fromfarid
                                FROM (
                              SELECT att_arstart, farid
                               FROM TABLE (cast(intv AS t_res_tb_intv))
                              WHERE att_arstart<c.att_arend OR (att_arstart=c.att_arend AND farid<vFaridNext)
                              ORDER BY att_arstart DESC, farid DESC)
                              WHERE rownum<2;

                               IF trall.ddstart.exists(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS'))  THEN
                               --IF trall.intv.exists(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS')) then
                                 IF trall.dfarid.EXISTS(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(fromfarid) ) THEN
/*                                   SELECT COUNT(*) INTO iExists FROM TABLE ( CAST(trall.dfarid AS t_res_dfarid )) WHERE dstart_fk=to_char(fromstart,'DD.MM.YYYY HH24:MI:SS')
                                                                                                  AND farid=fromfarid;
                                   IF iExists <>0 THEN
*/                     -- /*farid*/IF trall.intv(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS')).EXISTS(fromfarid) THEN
                                  --Скопировать один интервал в другой
                                  --Может уже быть такая дата но не быть farid'а - проверяем
                                  trall.ddstart( to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') ):='1';
                                  trall.dfarid( to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vFaridNext) ) .ind:=NULL;
/*                                  trall.dfarid.EXTEND;
                                  trall.dfarid(trall.dfarid.LAST):= t_res_dfarid_el( dfarid_idx,
                                                                                                        to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'),
                                                                                                        vFaridNext,
                                                                                                        NULL,
                                                                                                        NULL,
                                                                                                        NULL,
                                                                                                        NULL);
                                  dfarid_idx:=dfarid_idx+1;*/
                                  disp_i:=trall.disp.FIRST;
                                  WHILE disp_i IS NOT NULL LOOP
                                        IF instr( disp_i, to_char(fromstart/*c.dstart*/,'DD.MM.YYYY HH24:MI:SS') ||  ' ' || to_char(fromfarid) || ' ' ) <>0 THEN
                                        -- Копируем
                                           vIsp:=substr(disp_i, instr(disp_i,' ',1,3)+1, length(disp_i) - instr(disp_i,' ',1,3) );
                                           trall.disp( to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vFaridNext) || ' ' || vIsp ) := trall.disp(disp_i);
                                           trall.disp_ez(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vFaridNext) || ' ' || vIsp ):=trall.disp_ez(disp_i);
                                           dez_i:=trall.disp_ez(disp_i);
                                          IF instr(dez_i,' ')=0 THEN
                                              vEz:=dez_i;
                                              dez_i:='';
                                           ELSE
                                              vEz:=substr(dez_i,1,instr(dez_i,' ')-1);
                                              dez_i:=substr( dez_i,instr(dez_i,' ')+1, length(dez_i)-instr(dez_i,' ') );
                                           END IF;
                                            WHILE vEz IS NOT NULL LOOP
/*
                                                       dez_i := trall.dez.FIRST;
                                                       WHILE dez_i IS NOT NULL LOOP
                                                             IF instr( dez_i, disp_i || ' ')<> 0 THEN
*/                                                                --Копируем ед.изм
                                                                trall.dez( to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vFaridNext) || ' ' || vIsp || ' ' ||
                                                                /*substr(dez_i, instr(dez_i,' ',1,4)+1, length(dez_i) - instr(dez_i,' ',1,4) )*/ vEz )    :=trall.dez(disp_i || ' ' || vEz);
                                                             --END IF;
                                                            -- dez_i:=trall.dez.NEXT(dez_i);
                                                      IF nvl(length(dez_i),0)=0 THEN
                                                         vEz:=NULL;
                                                      ELSIF instr(dez_i,' ')=0 THEN
                                                         vEz:=dez_i;
                                                         dez_i:='';
                                                      ELSE
                                                          vEz:=substr(dez_i,1,instr(dez_i,' ')-1);
                                                          dez_i:=substr( dez_i,instr(dez_i,' ')+1, length(dez_i)-instr(dez_i,' ') );
                                                      END IF;
                                                       END LOOP;
                                        END IF;
                                        disp_i:=trall.disp.NEXT(disp_i);
                                  END LOOP;
                                   FOR g1 IN (SELECT t.dstart,t.farid,t.rn_isp,t.n,t.v,t.ez,t.ind_mo,t.key_mo,t.rn AS rnfrom
                                          FROM tb_res_fap t
                                          WHERE t.dstart=to_char(fromstart/*c.dstart*/,'DD.MM.YYYY HH24:MI:SS') AND t.farid=fromfarid
                                          AND t.pri IS NULL -- те что не на весь период
                                          ) LOOP
                                                --SELECT seq_res.NEXTVAL INTO iExists FROM dual;
                                                iExists:=res_sequence;
                                                res_sequence:=res_sequence+1;
                                                INSERT INTO tb_res_fap
                                                (dstart, farid, rn_isp, n, v, ez, ind_mo, key_mo, rn)
                                                VALUES
                                             (to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'), vFaridNext, g1.rn_isp, g1.n, g1.v, g1.ez, g1.ind_mo, g1.key_mo, iExists);
                                             -- Копируем ТВ
                                                    FOR g2 IN (SELECT t.rntv,t.uf,t.ap FROM tb_res_dtv t WHERE t.rnmo_fk=g1.rnfrom) LOOP
                                                    --SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                                    iExists2:=res_sequence;
                                                    res_sequence:=res_sequence+1;
                                                        INSERT INTO tb_res_dtv
                                                          (rnmo_fk, rn, rntv, uf,ap)
                                                        VALUES
                                                          (iExists, iExists2, g2.rntv, g2.uf,g2.ap);
                                                END LOOP;
                                         END LOOP;


                                     --trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'))(vFaridNext):=trall.intv(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS'))(fromfarid);

                                       --Удаление собственных позиций
                                       /*m:=trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v.FIRST;
                                       WHILE m IS NOT NULL LOOP
                                             IF trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v(m).ind=0 THEN
                                             trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v.DELETE(m);
                                       END IF;
                                       m:=trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v.next(m);
                                       END LOOP;*/
                                   ELSE -- Есть дата - нет фарида откуда
/*                                            trall.dfarid.EXTEND;
                                            trall.dfarid(trall.dfarid.LAST):=t_res_dfarid_el(dfarid_idx,
                                                                  to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'),
                                                                  vFaridNext,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL);
                                            dfarid_idx:=dfarid_idx+1;*/
                                            trall.dfarid(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vFaridNext) ).ind:=NULL;
                                     --trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'))(vFaridNext).ind:=null;
                                   END IF;
                               ELSE-- Нет даты откуда
                                                 trall.ddstart( to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') ):='1';

/*                                                 trall.dfarid.EXTEND;
                                                 trall.dfarid(trall.dfarid.LAST):=t_res_dfarid_el(dfarid_idx,
                                                                  to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'),
                                                                  vFaridNext,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL);
                                                 dfarid_idx:=dfarid_idx+1;
*/                                 --trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'))(vFaridNext).ind:=null;
                                       trall.dfarid(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vFaridNext) ).ind:=NULL;
                               END IF;
                       END IF;
                    END IF; -- r=1
               END IF;-- vFaridNext<>-1
            END IF;

            IF c.att_arstart > c.dstart OR (c.att_arstart = c.dstart AND f_get_first_arid(c.att_auth)>c.farid AND c.rn_prich<>-1) OR (c.rn_prich=c.att_auth AND c.att_arstart=p_start AND c.att_arstart=c.dstart) THEN --Встретили изменение
               IF f_get_prev_actual2(c.att_arid,'1') = -1 THEN
                  -- Предыдущего состояния не было - это новое
                  vInd_new:='1';
               END IF;
               -- Началось  внутри интервала
               vRn_prich := c.att_auth;
               vDstart := c.att_arstart;
               vFarid  := f_get_first_arid(c.att_auth);
               --Добавляем интервал - если его нету
               SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv)) WHERE att_arstart=c.att_arstart AND farid=vfarid;
               IF r=0 THEN
                  intv.EXTEND;
                  intv(intv.LAST):=t_res_intv(c.att_arstart, vFarid);
                  vInd_Add:='1';
               ELSE
                  vInd_Add:='0';
               END IF;
            ELSE
               -- Началось вне(до) интервала
               vRn_prich := c.rn_prich;
               vDstart := c.dstart;
               vFarid :=c.farid;
               -- Изменение - состояние начало действовать до интервала
            END IF;

            IF c.ind=1 AND f_is_mo_actual( vDstart, vFarid,c.rn_pozmo,p_start)=-1 THEN
                               -- Позиция неактуальна
                               GOTO next_state;
            ELSIF c.ind=3 AND F_is_arid_actual(vDstart,vFarid,c.arid_zo,p_start)=-1 THEN
                               -- Позиция неактуальна
                               GOTO next_state;
            END IF;

            --Цикл
            trall.ba.EXTEND;
            trall.ba(trall.ba.LAST) := t_res_elem3(
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       null);
            trall.ba(trall.ba.LAST).arid_k:=c.arid_k;
            trall.ba(trall.ba.LAST).att_arid := c.att_arid;
            trall.ba(trall.ba.LAST).rntv_k := c.rn_tv; --rn_tvk;
            trall.ba(trall.ba.LAST).rntv_c := c.tv_ch;
            trall.ba(trall.ba.LAST).rnisp_c := c.rn_ispob_ch;
            trall.ba(trall.ba.LAST).rnisp_k := c.rnisp_k;
            trall.ba(trall.ba.LAST).urov := c.urov;
            trall.ba(trall.ba.LAST).ind := c.ind;
            trall.ba(trall.ba.LAST).arid_zo:=c.arid_zo;
            trall.ba(trall.ba.LAST).att_auth1:=c.att_auth;
            trall.ba(trall.ba.LAST).ez:=c.ez;
            trall.ba(trall.ba.LAST).flag:=c.flag;
            -- Простановка key
            IF c.ind='1' THEN
            -- Установка
            IF dce_chto_key.key<>c.key OR dce_chto_key.isp_chto<>c.rn_ispob_ch OR dce_chto_key.rn_pozmo<>c.rn_pozmo  OR nvl(dce_chto_key.tv_chto,-15)<>nvl(c.tv_ch,-15) THEN
                        key:=key+1;
                        dce_chto_key.key:=c.key;
                        dce_chto_key.rn_tv:=c.rn_tv;
                        dce_chto_key.isp_chto:= c.rn_ispob_ch;
                        dce_chto_key.rn_pozmo:= c.rn_pozmo;
                        dce_chto_key.tv_chto:=c.tv_ch;
            END IF;
            ELSIF c.ind=3 THEN
            -- Образец
            IF dce_chto_key_obr.key<>c.key OR dce_chto_key_obr.tv_obr<>c.tv_ch OR dce_chto_key_obr.arid_mo<>c.arid_zo OR dce_chto_key_obr.tv_izg<>c.TV_IZG THEN
                         key:=key+1;
                        dce_chto_key_obr.key:=c.key;
                        dce_chto_key_obr.tv_obr:= c.TV_CH;
                        dce_chto_key_obr.arid_mo := c.arid_zo;
                        dce_chto_key_obr.tv_izg := c.tv_izg;
            END IF;
            ELSIF c.ind=2 THEN
            -- Заготовка
               IF dce_chto_key_zag.key<>c.key OR dce_chto_key_zag.rn_tv<>c.rn_tv THEN
                         key:=key+1;
                        dce_chto_key_zag.key:=c.key;
                        dce_chto_key_zag.rn_tv:= c.RN_TV;
               END IF;
            END IF;
            trall.ba(trall.ba.LAST).key:=key;

            trall.ba(trall.ba.LAST).ind_new:=vInd_new;
               trall.ba(trall.ba.LAST).rn_prich:=vRN_Prich;
               trall.ba(trall.ba.LAST).dstart:=vDstart;
               trall.ba(trall.ba.LAST).farid:=vFarid;

            -- Если вверху ввелось с 0 - то чтоб введенные внизу также считались введенными с 0 - протягивание введения вниз
--            IF c.rn_tv =177819 THEN
--               DBMS_output.put_line(c.tv_ch || ' ' || c.ran);
--            END IF;
            IF c.ind_new IS NOT NULL AND c.ran=1 THEN
               --DBMS_output.put_line('->' || c.tv_ch || ' ' || c.ran);
               IF nvl(trall.ba(trall.ba.LAST).ind_new,'0') <>'1' THEN
                  trall.ba(trall.ba.LAST).ind_new:='2';
               END IF;
            END IF;
            tmpEArid:=f_get_first_arid_for_end(c.att_arid);
            /*IF c.tv_ch=166809 THEN
               dbms_output.put_line('aaaa=' || to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'));
               dbms_output.put_line('aaaa=' || to_char(c.dend,'DD.MM.YYYY HH24:MI:SS') || ' ' || c.earid);
               dbms_output.put_line('aaaa=' || to_char(c.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' ||c.farid);
               IF c.att_arend>c.dend THEN
                  dbms_output.put_line('вввв=' );
               END IF;
               IF c.att_arend=c.dend THEN
                  dbms_output.put_line('uuuu=' );
               END IF;
            END IF;*/
            IF c.att_arend > c.dend OR (c.att_arend =c.dend AND tmpEarid>c.earid) THEN
               --Состояние закончилось вне(после) интервала
               trall.ba(trall.ba.LAST).dend := c.dend;
               trall.ba(trall.ba.LAST).earid := c.Earid;
            ELSE
              --Состояние закончилось до интервала
               trall.ba(trall.ba.LAST).dend := c.att_arend;
               trall.ba(trall.ba.LAST).earid := tmpEarid;
            END IF;


            IF c.ardis IS NOT NULL THEN
                    trall.ba(trall.ba.LAST).ardis:=to_char(to_number(c.ardis) + to_number(nvl(c.att_ardis,0)));
            ELSE
                        trall.ba(trall.ba.LAST).ardis:=c.att_ardis;
            END IF;

            trall.ba(trall.ba.LAST).kol := c.kol;
--            ba(ba.LAST).ak := c.ak;
            trall.ba(trall.ba.LAST).golova := p_rntv;
            --С той же даты другое изменение
            IF c.att_arstart = c.dstart AND c.rn_prich <> c.att_auth AND c.rn_prich <> -1 THEN
               --Если разные изменения - то
               IF f_get_first_arid(c.rn_prich)<f_get_first_arid(c.att_auth) THEN
                  -- Верхнее раньше нижнего
                  -- Встречалось ли оно раньше
                  trall.ba(trall.ba.LAST).ind_dts := '1';
               ELSE
                  -- Нижнее раньше верхнего
                   trall.ba(trall.ba.LAST).ind_dts := '2';
               END IF;
            ELSE
               trall.ba(trall.ba.LAST).ind_dts := '0';
            END IF;
            --PIPE ROW(ba(ba.LAST));
            END IF;
           END IF;--fl_first_record
           -- Проверка существования более двух интервалов в маршруте ТВ_что
           --ba(ba.LAST).mo_states := t_node_mo();
           tmpmo_states:= t_node_mo();
           tmpmo_states.DELETE;
           tmpmo_intv:= t_node_mo();
           tmpmo_intv.DELETE;
           --IF c.tv_ch=1558697 AND 1=0 THEN dbms_output.put_line(c.att_arid); END IF;--ba(ba.LAST).mo_intv := t_node_mo();
           P_GET_MO_INTERVALS(p_start,c.tv_ch, p_start, -1, p_end, 999999999999999999999999999, -1, trall.ba(trall.ba.LAST).ind_mo,tmpmo_states,/*ba(ba.LAST).mo_intv*/tmpmo_intv);
           IF key<>OLDkey THEN
              fl_forall:=NULL;
           END IF;
           IF c.att_arstart<=p_start AND c.att_arend>p_end THEN
              --Состояние действует на всем периоде расчета
              -- Размножилось ли состояние из-за маршрута?
              SELECT COUNT(*) INTO iExists FROM (
                     SELECT dstart,dend,farid,earid,att_auth,rownum AS rnum FROM (
                     SELECT trall.ba(trall.ba.LAST).dstart AS dstart,trall.ba(trall.ba.LAST).dend AS dend, trall.ba(trall.ba.LAST).farid AS farid , trall.ba(trall.ba.LAST).earid AS earid, trall.ba(trall.ba.LAST).rn_prich AS att_auth FROM dual
                     WHERE nvl(trall.ba(trall.ba.LAST).ind_mo,0)=0
                     UNION
                     SELECT att_arstart,att_arend,
                     CASE WHEN att_arstart=p_start THEN -1 ELSE
                     farid END AS farid,
                     earid,
                     att_auth FROM TABLE (CAST (/*ba(ba.LAST).*/tmpmo_intv  AS t_node_mo))
                     WHERE trall.ba(trall.ba.LAST).ind_mo>0)
              );
              IF iExists=1 AND oldkey<>key THEN-- Состояние из-за маршрута не размножилось                           
                     --Если oldkey=key - то это тоже вхождение и если в разных вхождениях fl_forall  различен
                     -- пока сработает нормально если он был Null и стал 1. В обратном случае - программа работает ошибочно.
                     
                     -- Проверяем - если уже были записи с индикатором не 0 по данному ТВ и позмо
                     SELECT COUNT(*) INTO iExists2 FROM (SELECT * FROM v_res_dmotv t WHERE --t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid=p.farid AND 
                                                        t.rn_isp=c.rn_ispob_ch AND t.n=c.Ez AND t.v=c.Rn_Pozmo AND t.rntv=c.tv_ch AND t.ind_mo<>'0' 
                                                        AND t.pri IS NULL AND rownum<2);
                      
                        -- 8 Строк добавлены 26.08.2009
                        IF c.ind=3 THEN
                           FOR gh IN(SELECT * FROM tb_audi au WHERE au.att_arid=c.arid_zo) LOOP
                               IF gh.att_arstart<=p_start AND gh.att_arend>p_end AND gh.att_var=0 AND gh.att_arver=0 THEN
                               NULL;
                               ELSE
                                iExists2:=iExists2+1;
                               END IF;
                           END LOOP;                        
                        END IF;
                     IF iExists2 =0 THEN
                        -- Проверяем - действует ли позиция защиты на всем интервале
                        fl_forall:='1';                        
                     END IF;
                     
              END IF;
           END IF;
           tmpmo_states:= t_node_mo();
           tmpmo_states.DELETE;
           tmpmo_intv:= t_node_mo();
           tmpmo_intv.DELETE;
           P_GET_MO_INTERVALS(p_start,c.tv_ch, trall.ba(trall.ba.LAST).dstart, trall.ba(trall.ba.LAST).farid, trall.ba(trall.ba.LAST).dend, trall.ba(trall.ba.LAST).earid, trall.ba(trall.ba.LAST).rn_prich, trall.ba(trall.ba.LAST).ind_mo,tmpmo_states,/*ba(ba.LAST).mo_intv*/tmpmo_intv);
           /*IF c.tv_ch=32371  THEN
                FOR tm IN (SELECT * FROM table(CAST (tmpmo_states AS t_node_mo)) ) LOOP
                dbms_output.put_line('mostates: ' || tm.rn_pozmo || ' dstart=' || to_char(tm.att_arstart,'dd.mm.yyyy HH24:MI:SS') ||' mofarid: ' || tm.farid || ' moend: ' || tm.att_arend || ' moearid: ' || tm.earid || ' att_auth=' || tm.att_auth);                
\*                              rn_pozmo      NUMBER, --РН позиции
  arid_mo         NUMBER,   -- арид позиции
  att_arstart     DATE,   -- Дата начала действия состояния
  farid              NUMBER,   -- Первый арид изменения
  earid              number,   -- Первый арид следующего изменения
  att_arend      DATE,   -- Дата конца действия состояния
  att_auth        NUMBER, -- Изменение по которому изменилось состояние
  att_arver       NUMBER, -- Версия по которой изменилось состояние
  att_ardis
*\                END LOOP;
           END IF;*/
--проверка куда на все состояния
           IF c.tv_ch<>p_rntv THEN
              BEGIN
              IF yntd(c.rn_tv)='1' THEN
              SELECT cntk,priii  INTO iExists4, iExists   FROM ( 
              SELECT
                              t.rn_isp,t.n,t.v,t.ind_mo,t.rntv,t.uf,t.ap, COUNT(*) cntk, SUM(nvl(pri,0)) AS priii
              FROM v_res_dmotv t WHERE t.rn_isp=c.rnisp_k
                     /*AND t.n=c.ez*/ AND t.v=vRn_Pozmo AND t.rntv=c.rn_Tv AND ind_mo='0'
                     GROUP BY t.rn_isp,t.n,t.v,t.ind_mo,t.rntv,t.uf,t.ap
              ) WHERE rownum<2;-- max - если разные количества в разных интервалах
              ELSE
              SELECT cntk,priii  INTO iExists4, iExists  FROM ( 
              SELECT
                              t.rn_isp,t.n,t.v,t.ind_mo,t.rntv,t.uf,t.ap, COUNT(*) cntk, SUM(nvl(pri,0)) AS priii
              FROM v_res_dmotv t WHERE t.rn_isp=c.rnisp_k
                     /*AND t.n=c.ez*/ AND t.v=1 AND t.rntv=c.rn_Tv AND ind_mo='0' 
                     GROUP BY t.rn_isp,t.n,t.v,t.ind_mo,t.rntv,t.uf,t.ap
                     ORDER BY COUNT(*)--Добавлено 27.10.2009 - т.к. может быть несколько ind_mo
              ) WHERE rownum<2;-- max - если разные количества в разных интервалах
              END IF;
              --Доб 27.10.2009 - в случае если ДСЕ идет как заготовка и как установка с одной ЕИ и на ту же МО
              BEGIN
                        SELECT t.ind_mo INTO vInd FROM v_res_dmotv t WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS') AND
                        t.farid=-1 AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=c.Rn_Pozmo AND t.rntv=c.tv_ch 
                        AND t.ind_mo<>'0' AND t.ind_mo<>c.ind AND t.pri IS NOT NULL AND rownum<2;
                        iExists4:=-2;
              EXCEPTION
                 WHEN NO_DATA_FOUND THEN
                    NULL;
              END;
              --Конец. Доб 27.10.2009 - в случае если ДСЕ идет как заготовка и как установка с одной ЕИ и на ту же МО
              IF iExists4=1 AND iExists<>0 THEN
                 -- Это с pri='1' 
                 iExists4:=  intv.COUNT;
              END IF;
              EXCEPTION
                       WHEN NO_DATA_FOUND THEN
                       fl_forall:=NULL;
                       iExists4:=0;
              END;
              iExists:=intv.COUNT;
              IF iExists<>iExists4 THEN --Если количество интервалов не равно количеству записей по куда - то значит по куда были изменения
                 -- Проверить - если по этой ДСЕ и МО в эту куда стоит PRI, то его размножить по всем состояниям
                 SELECT COUNT(*) INTO iExists4 FROM (SELECT * FROM v_res_dmotv t WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS') AND
                        t.farid=-1 AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=c.Rn_Pozmo AND t.rntv=c.tv_ch 
                        AND t.ind_mo<>'0' AND t.pri IS NOT NULL AND rownum<2);
                 IF iExists4<>0 THEN
                    --Размножаем - по всем интервалам
                    FOR adv IN (SELECT att_arstart,farid,rownum AS rn FROM TABLE (cast(intv AS t_res_tb_intv)) 
                                       
                                       ORDER BY att_arstart,farid ) LOOP
                        IF adv.rn<>1 THEN                         
                         trall.disp( to_char(adv.att_arstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(adv.farid) || ' ' || c.rn_ispob_ch ) :=  trall.disp( to_char(p_start,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(-1) || ' ' || c.rn_ispob_ch );
                         trall.disp_ez( to_char(adv.att_arstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(adv.farid) || ' ' || c.rn_ispob_ch ) :=  trall.disp_ez( to_char(p_start,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(-1) || ' ' || c.rn_ispob_ch );                         
                         trall.dez( to_char(adv.att_arstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(adv.farid) || ' ' || c.rn_ispob_ch || ' ' || c.ez) :=trall.dez( to_char(p_start,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(-1) || ' ' || c.rn_ispob_ch || ' ' || c.ez );
                         FOR adv2 IN (SELECT * FROM v_res_dmotv t WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS') AND
                             t.farid=-1 AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=c.Rn_Pozmo AND t.rntv=c.tv_ch 
                             AND t.ind_mo<>'0' AND t.pri IS NOT NULL) LOOP
                            iExists:=res_sequence;
                            res_sequence:=res_sequence+1;
                            INSERT INTO tb_res_fap
                                 (dstart, farid, rn_isp, n, v, ez, ind_mo,  key_mo,rn,PRI)
                            VALUES
                                  (to_char(adv.att_arstart,'DD.MM.YYYY HH24:MI:SS'), adv.farid, c.rn_ispob_ch, c.ez,c.rn_pozmo,adv2.ez,adv2.ind_mo/*c.ind*/, adv2.key_mo,iExists,NULL);
                           iExists2:=res_sequence;
                           res_sequence:=res_sequence+1;
                           INSERT INTO tb_res_dtv
                                             (rnmo_fk, rn, rntv, uf, ap)
                                           VALUES
                                             (iExists, iExists2, adv2.rntv, adv2.uf, adv2.ap);
                        END LOOP;
                         END IF;
                    END LOOP;
                        UPDATE tb_res_fap t SET t.pri=NULL
                        WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS') AND
                             t.farid=-1 AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=c.rn_Pozmo 
                             AND t.ind_mo<>'0' AND t.pri IS NOT NULL;
                 END IF;
                 fl_forall:=NULL;
              END IF;
              -- Если fl_forall стоит и дата начала периода <> p_start и нет записи с pri=1, то fl_forall ставим null
              IF c.dstart<>p_start AND fl_forall='1' THEN
                 SELECT COUNT(*) INTO iExists4 FROM (SELECT * FROM v_res_dmotv t WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS') AND
                        t.farid=-1 AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=c.Rn_Pozmo 
                        AND t.rntv=c.tv_ch 
                        AND t.ind_mo<>'0' AND t.pri IS NOT NULL AND rownum<2);
                  IF iExists4 =0 THEN
                     fl_forall:=NULL;
                  END IF;
              END IF;
            END IF;--   >    <
            IF fl_forall IS NULL THEN
                 -- Проверить - если по этой ДСЕ  стоит PRI По инд=0, то его изменить и размножить на все интервалы
                 SELECT COUNT(*) INTO iExists4 FROM (SELECT * FROM v_res_dmotv t WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS') AND
                        t.farid=-1 AND t.rn_isp=c.rn_ispob_ch --AND t.n=c.ez --AND t.v=c.Rn_Pozmo --Если по одной из его ЕИ - то тоже меняем
                        AND t.rntv=c.tv_ch 
                        AND t.ind_mo='0' AND t.pri IS NOT NULL AND rownum<2);
                 IF iExists4<>0 THEN
                    -- Размножаем и меняем
                       
/*                       DELETE FROM tb_res_fap t WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS') AND
                        t.farid=-1 AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez --AND t.v=c.Rn_Pozmo 
--                        AND t.rntv=c.tv_ch 
                        AND t.ind_mo='0' AND t.pri IS NOT NULL;*/

                        FOR adv IN (SELECT att_arstart,farid,rownum AS rn FROM TABLE (cast(intv AS t_res_tb_intv)) 
                        WHERE NOT (vInd_Add='1' AND att_arstart=vDstart AND farid=vFarid) --26.11.2009 - чтоб не размножалось на текущее изменение которого еще не было
                        ORDER BY att_arstart,farid ) LOOP
                                  IF adv.rn<>1 THEN                         
                                           trall.disp( to_char(adv.att_arstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(adv.farid) || ' ' || c.rn_ispob_ch ) :=  trall.disp( to_char(p_start,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(-1) || ' ' || c.rn_ispob_ch );
                                           trall.disp_ez( to_char(adv.att_arstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(adv.farid) || ' ' || c.rn_ispob_ch ) :=  trall.disp_ez( to_char(p_start,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(-1) || ' ' || c.rn_ispob_ch );                         
                                           --trall.dez( to_char(adv.att_arstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(adv.farid) || ' ' || c.rn_ispob_ch || ' ' || c.ez) :=trall.dez( to_char(p_start,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(-1) || ' ' || c.rn_ispob_ch || ' ' || c.ez );
                                           FOR adv2 IN (SELECT * FROM v_res_dmotv t WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS') AND
                                               t.farid=-1 AND t.rn_isp=c.rn_ispob_ch /*AND t.n=c.ez /*AND t.v=c.Rn_Pozmo*/ AND t.rntv=c.tv_ch 
                                               AND t.ind_mo='0' AND t.pri IS NOT NULL) LOOP
                                           trall.dez( to_char(adv.att_arstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(adv.farid) || ' ' || c.rn_ispob_ch || ' ' || adv2.ez) :=trall.dez( to_char(p_start,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(-1) || ' ' || c.rn_ispob_ch || ' ' || adv2.ez );

                                                      iExists:=res_sequence;
                                                      res_sequence:=res_sequence+1;
                                                      INSERT INTO tb_res_fap
                                                           (dstart, farid, rn_isp, n, v, ez, ind_mo,  key_mo,rn,PRI)
                                                      VALUES
                                                            (to_char(adv.att_arstart,'DD.MM.YYYY HH24:MI:SS'), adv.farid, c.rn_ispob_ch, adv2.ez,adv2.v,adv2.ez,adv2.ind_mo/*c.ind*/, adv2.key_mo,iExists,NULL);
                                                     iExists2:=res_sequence;
                                                     res_sequence:=res_sequence+1;
                                                     INSERT INTO tb_res_dtv
                                                                       (rnmo_fk, rn, rntv, uf, ap)
                                                                     VALUES
                                                                       (iExists, iExists2, adv2.rntv, adv2.uf, adv2.ap);
                                           END LOOP;
                                   END IF;
                        END LOOP;
                        UPDATE tb_res_fap t SET t .pri=NULL WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS') AND
                        t.farid=-1 AND t.rn_isp=c.rn_ispob_ch --AND t.n=c.ez --AND t.v=c.Rn_Pozmo 
                        AND t.ind_mo='0' AND t.pri IS NOT NULL;
                 END IF;
END IF;
            -- Устанавливаем Fl_forallo - если по данной ДСЕ несколько при pri
            SELECT COUNT(DISTINCT nvl(pri,0)) INTO iExists  FROM (SELECT DISTINCT pri FROM tb_res_fap t WHERE t.rn_isp=c.rn_ispob_ch
            UNION ALL
                  SELECT fl_forall FROM dual
            );
            IF iExists = 2 THEN
               Fl_forallo:=NULL;
            ELSE
                           Fl_forallo:=fl_forall;
            END IF;
--конец проверки куда на все состояния                            
           FOR mo_int IN ( -- Размножение интервалов при изменении маршрута
               
                          SELECT dstart,dend,farid,earid,att_auth,rownum AS rnum FROM (
           SELECT trall.ba(trall.ba.LAST).dstart AS dstart,trall.ba(trall.ba.LAST).dend AS dend, trall.ba(trall.ba.LAST).farid AS farid , trall.ba(trall.ba.LAST).earid AS earid, trall.ba(trall.ba.LAST).rn_prich AS att_auth FROM dual
           WHERE nvl(trall.ba(trall.ba.LAST).ind_mo,0)=0
           UNION
           SELECT att_arstart,att_arend,
           CASE WHEN att_arstart=p_start THEN -1 ELSE
           farid END AS farid,
           earid,
           att_auth FROM TABLE (CAST (/*ba(ba.LAST).*/tmpmo_intv  AS t_node_mo))
           WHERE trall.ba(trall.ba.LAST).ind_mo>0)
            --WHERE (fl_forall IS NULL OR (fl_forall IS NOT NULL AND rownum<2) )
            -- Нельзя т.к. размножается дерево
           ) LOOP
           /*IF c.tv_ch=166809  THEN
               dbms_output.put_line('mostart: ' || mo_int.dstart || ' mofarid: ' || mo_int.farid || ' moend: ' || mo_int.dend || ' moearid: ' || mo_int.earid);
               dbms_output.put_line('intervals2: ' || intv.COUNT);
               FOR p IN (SELECT * FROM TABLE (cast(intv AS t_res_tb_intv)) ) LOOP
                     dbms_output.put_line('m12- ' || to_char(p.att_arstart,'DD.MM.YYYY HH24:MI:SS') || ' ' ||  p.farid);
               END LOOP;
           END IF;*/
               fl_forall_p:=FALSE;
               IF fl_forall_p=FALSE THEN -- Чтоб один раз
              --!!!!!!!!!!!!!!!!!!!!!!!!!! НАЧАЛО ЦИКЛА P !!!!!!!!!!!!!!!!!!!!!
              FOR p IN (--Изменение всех интервалов внутренних, т.к. текущий их включает
               SELECT dstart,farid 
               FROM (
               SELECT mo_int.dstart AS dstart, mo_int.farid AS farid FROM dual
                      UNION
               SELECT att_arstart,farid FROM TABLE (cast(intv AS t_res_tb_intv))
                   WHERE (att_arstart>mo_int.dstart OR ( att_arstart=mo_int.dstart AND farid>=mo_int.farid) ) AND
--                         (att_arstart<ba(ba.LAST).dend or(att_arstart=ba(ba.LAST).dend and farid<mo_int.earid ))
                         (att_arstart<mo_int.dend or(att_arstart=mo_int.dend and farid<mo_int.earid ))
                         )
                         WHERE  (fl_forallo IS NULL OR (fl_forall IS NOT NULL AND fl_forallo IS NOT NULL AND rownum<2 AND dstart=p_start)
                         )
                         ) LOOP
                         /*IF (to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')='07.10.2008 00:00:00' AND p.farid IN (31027450,31037357,31042187,31045837) )
                              OR ( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')='03.10.2008 12:06:43' AND p.farid=29834344)
                              OR ( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')='03.10.2008 00:00:00' AND p.farid=30924794) THEN
                            dbms_output.put_line('MTV   ' || c.tv_ch || ' ' ||  c.urov  || to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' '|| p.farid );
                         END IF;
                    IF (to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')='07.10.2008 00:00:00' AND p.farid IN (31042187)) THEN
                            dbms_output.put_line('MTV3 ' || c.tv_ch || ' ' ||  c.urov  || to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' '|| p.farid );
--                               RETURN 1;                      
                         END IF;     */                    

                            fl_relink:=false;
/*                            SELECT COUNT(*) INTO iExists FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                           OR (t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid = p.farid );
                            IF iExists=0 THEN
                               fl_relink:=TRUE;
                            END IF;

*/ --                      iExists3:=0;
                          iExists4:=0;
     --                     SELECT COUNT(*) INTO iExists3 FROM TABLE( CAST (trall.ddstart AS t_res_dstart) ) WHERE rn=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS');
                           --/*dstart*/IF NOT trall.intv.EXISTS(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') ) THEN
                           IF  NOT trall.ddstart.EXISTS(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') ) THEN
--                             IF iExists3=0 THEN
                                       fl_relink:=true;
                                    ELSE
                                    IF NOT trall.dfarid.exists( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) )THEN
/*                                        SELECT COUNT(*) INTO iExists4 FROM TABLE( CAST (trall.dfarid AS t_res_dfarid))
                                        WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid;
                                       IF iExists4=0 THEN--IF not trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') ).exists(p.farid) then
*/                                          fl_relink:=TRUE;
                                       END IF;
                          /*dstart*/End if;
                          IF fl_relink THEN
                                --Скопировать из верхнего интервала все в этот интервал
                               -- копируем из минимального который меньше данного
                               SELECT att_arstart,farid
                               INTO fromstart, fromfarid
                                FROM (
                              SELECT att_arstart, farid
                               FROM TABLE (cast(intv AS t_res_tb_intv))
                              WHERE att_arstart<p.dstart OR (att_arstart=p.dstart AND farid<p.farid)
                              ORDER BY att_arstart DESC, farid DESC)
                              WHERE rownum<2;
                               -- t(to_char(с.dstart,'DD.MM.YYYY HH24:MI:SS')) (с.farid)
                               --SELECT COUNT(*) INTO iExists FROM tb_res_fap t WHERE t.dstart=to_char(fromstart /*c.dstart*/,'DD.MM.YYYY HH24:MI:SS');
                               IF trall.ddstart.EXISTS (to_char(fromstart,'DD.MM.YYYY HH24:MI:SS') ) THEN
--                               SELECT COUNT(*) INTO iExists FROM TABLE( CAST (trall.ddstart AS t_res_dstart) ) WHERE rn=to_char(fromstart,'DD.MM.YYYY HH24:MI:SS');
--                               IF iExists<>0 THEN--IF trall.intv.exists(to_char(fromstart /*c.dstart*/,'DD.MM.YYYY HH24:MI:SS')) THEN --iExists<>0 THEN
                                       /*SELECT COUNT(*) INTO iExists2 FROM tb_res_fap t
                                       WHERE t.dstart=to_char(fromstart \*c.dstart*\,'DD.MM.YYYY HH24:MI:SS') AND t.farid=fromfarid;*/
                                       IF trall.dfarid.exists( to_char(fromstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(fromfarid) ) THEN--31.08.2009 вставлено это условие
/*                                       SELECT COUNT(*) INTO iExists2 FROM TABLE( CAST (trall.dfarid AS t_res_dfarid))
                                        WHERE dstart_fk=to_char(fromstart,'DD.MM.YYYY HH24:MI:SS') AND farid=fromfarid;

                                        IF iExists2<>0 THEN*/ --/*farid*/IF trall.intv(to_char(fromstart/*c.dstart*/,'DD.MM.YYYY HH24:MI:SS')).EXISTS(fromfarid/*c.farid*/) THEN --iExists2<>0 THEN
--                                     p_copy_int(t(to_char(c.dstart,'DD.MM.YYYY HH24:MI:SS'))(c.farid), p.dstart, p.farid, t);
                                       /*IF c.tv_ch=1563887 THEN
                                          RETURN 1;
                                       END IF;*/
                                       /*SELECT COUNT(*) INTO r FROM tb_res_fap t WHERE t.dstart=p.dstart AND t.farid=p.farid;
                                       IF r>0 THEN
                                          dbms_output.put_line(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')  || ' ' || p.farid);
                                       END IF;*/
                                       
                                       FOR g1 IN (SELECT t.dstart,t.farid,t.rn_isp,t.n,t.v,t.ez,t.ind_mo,t.key_mo,t.rn AS rnfrom,t.pri
                                       FROM tb_res_fap t
                                       WHERE t.dstart=to_char(fromstart/*c.dstart*/,'DD.MM.YYYY HH24:MI:SS') AND t.farid=fromfarid
                                       AND NOT (t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.ind_mo='0')
                                       AND (key<>oldkey OR (key=oldkey AND
                                           NOT (nvl(key_mo,-1)=key)
                                       ) )
                                        --AND t.pri IS NULL -- те что не на весь период -- 25.11.2009 - было отключено -включил
                                       ) LOOP
                                       --dbms_output.put_line('5656565' || g1.dstart || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) || ' ' || to_char(g1.ez) || ' = ' ||trall.dez( g1.dstart || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) || ' ' || to_char(g1.ez)  ));

                                       /*IF c.tv_ch=3387 THEN
                                          RETURN 1;
                                       END IF;*/
                                       /*IF g1.rn_isp=3618 THEN
                                          dbms_output.put_line('Есть Еz откуда: ' || g1.dstart || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) || ' ' || to_char(g1.n) || ' Куда: ' || p.dstart || ' ' || p.farid);
                                       END IF;*/
                                       IF NOT trall.dez.EXISTS(( g1.dstart || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) || ' ' || to_char(g1.n))) THEN
                                           trall.dez( g1.dstart || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) || ' ' || to_char(g1.n)):=NULL;
                                           trall.disp_ez( g1.dstart || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) ):=to_char(g1.n);
                                       END IF;
                                        vTmp:=trall.dez( g1.dstart || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) || ' ' || to_char(g1.n));                                        
                                        IF NOT trall.disp.EXISTS( g1.dstart  || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) ) THEN
                                           trall.disp( g1.dstart  || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) ):=NULL;
                                        END IF;
                                        vTmp:=trall.disp( g1.dstart  || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) );
                                        IF NOT (key=oldkey AND (
                                           nvl(trall.dez( g1.dstart || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) || ' ' || to_char(g1.n)  ),-1)=key OR nvl(trall.disp( g1.dstart  || ' ' || to_char(g1.farid) || ' ' || to_char(g1.rn_isp) ),-1)=key) )
                                        THEN
                                             --SELECT seq_res.NEXTVAL INTO iExists FROM dual;
                                              iExists:=res_sequence;
                                              res_sequence:=res_sequence+1;
                                            IF g1.pri IS NULL THEN
                                              INSERT INTO tb_res_fap
                                                     (dstart, farid, rn_isp, n, v, ez, ind_mo, key_mo, rn)
                                                     VALUES
                                                     (to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS'), p.farid, g1.rn_isp, g1.n, g1.v, g1.ez, g1.ind_mo, g1.key_mo, iExists);
                                               -- Копируем ТВ
                                                FOR g2 IN (SELECT t.rntv,t.uf,t.ap FROM tb_res_dtv t WHERE t.rnmo_fk=g1.rnfrom) LOOP
                                                --SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                                iExists2:=res_sequence;
                                                res_sequence:=res_sequence+1;
                                                    INSERT INTO tb_res_dtv
                                                      (rnmo_fk, rn, rntv, uf,ap)
                                                    VALUES
                                                      (iExists, iExists2, g2.rntv, g2.uf,g2.ap);
                                                END LOOP;
                                             END IF;--pri
                                         END IF;
                                         END LOOP;
                                       IF  NOT trall.ddstart.EXISTS(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') ) THEN
                                              trall.ddstart(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') ):='1';
/*                                       IF iExists3=0 THEN
                                              trall.ddstart.EXTEND;
                                              trall.ddstart(trall.ddstart.last):=t_res_dstart_el( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') );
*/                                       END IF;
                                       IF NOT trall.dfarid.EXISTS(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')  || ' ' || to_char(p.farid) ) THEN
/*                                       IF iExists4=0 THEN
*/
                                                trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')  || ' ' || to_char(p.farid) ).ind:= NULL;
                                               /* trall.dfarid.EXTEND;
                                                trall.dfarid(trall.dfarid.LAST):=t_res_dfarid_el( dfarid_idx,
                                                                                                             to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS'),
                                                                                                             p.farid,
                                                                                                             NULL,
                                                                                                             NULL,
                                                                                                             NULL,
                                                                                                             NULL);
                                                dfarid_idx:=dfarid_idx+1; */
                                       END IF;
                                  disp_i:=trall.disp.FIRST;
                                  WHILE disp_i IS NOT NULL LOOP
                                        IF instr( disp_i, to_char(fromstart/*c.dstart*/,'DD.MM.YYYY HH24:MI:SS') ||  ' ' || to_char(fromfarid) || ' ' ) <>0 THEN
                                        -- Копируем                                                                                
                                           vIsp:=substr(disp_i, instr(disp_i,' ',1,3)+1, length(disp_i) - instr(disp_i,' ',1,3) );                                     
                                               
                                           IF nvl(trall.disp(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(fromfarid) || ' ' || vIsp),-1)<>key THEN
                                             
                                                 trall.disp( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || vIsp ) := trall.disp(disp_i);
                                                 trall.disp_ez( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || vIsp ) := trall.disp_ez(disp_i);
                                                 dez_i2:=trall.disp_ez(disp_i);
                                                IF instr(dez_i2,' ')=0 THEN
                                                    vEz2:=dez_i2;
                                                    dez_i2:='';
                                                 ELSE
                                                    vEz2:=substr(dez_i2,1,instr(dez_i2,' ')-1);
                                                    dez_i2:=substr( dez_i2,instr(dez_i2,' ')+1, length(dez_i2)-instr(dez_i2,' ') );
                                                 END IF;
                                                  WHILE vEz2 IS NOT NULL LOOP

      /*                                                       dez_i := trall.dez.FIRST;
                                                             WHILE dez_i IS NOT NULL LOOP
                                                                   IF instr( dez_i, disp_i || ' ' ) <> 0 THEN
        */                                                                --Копируем ед.изм
                                                          trall.dez( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || vIsp || ' ' ||
                                                          vEz2 ) :=trall.dez(disp_i ||' '|| vEz2);

                                                            IF nvl(length(dez_i2),0)=0 THEN
                                                               vEz2:=NULL;
                                                            ELSIF instr(dez_i2,' ')=0 THEN
                                                               vEz2:=dez_i2;
                                                               dez_i2:='';

                                                            ELSE
                                                                vEz2:=substr(dez_i2,1,instr(dez_i2,' ')-1);
                                                                dez_i2:=substr( dez_i2,instr(dez_i2,' ')+1, length(dez_i2)-instr(dez_i2,' ') );
                                                            END IF;
                                                  END LOOP;
                                              END IF; --key
                                        END IF;--instr
                                        disp_i:=trall.disp.NEXT(disp_i);
                                  END LOOP;
                                        /*FOR g3 IN (SELECT t2.* FROM TABLE (CAST(trall.dfarid AS t_res_dfarid) ) t1
                                                           JOIN TABLE( cast (trall.disp  AS t_res_disp) ) t2 ON t1.rn=t2.rn_farids_fk
                                                           WHERE dstart_fk=to_char(fromstart\*c.dstart*\,'DD.MM.YYYY HH24:MI:SS') AND farid=fromfarid
                                                       ) LOOP
                                                       -- Вставляем в таблицу испов
                                                       trall.disp.EXTEND;
                                                       trall.disp(trall.disp.LAST):=t_res_disp_el(disp_idx,dfarid_idx-1,g3.rn_ispob,g3.key);
                                                       disp_idx:=disp_idx+1;
                                                       FOR g4 IN (SELECT * FROM TABLE(CAST (trall.dez AS t_res_dez)) WHERE rn_isp_fk=g3.rn) LOOP
                                                           trall.dez.EXTEND;
                                                           trall.dez(trall.dez.LAST):=t_res_dez_el(dez_idx,disp_idx-1,g4.ez,g4.key);
                                                           dez_idx:=dez_idx+1;
                                                       END LOOP; --g4 ez
                                     END LOOP; --g3 isp*/

                                       --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS'))(p.farid):=trall.intv(to_char(fromstart/*c.dstart*/,'DD.MM.YYYY HH24:MI:SS'))(fromfarid/*c.farid*/);

                                       --Удаление собственных позиций - чтоб на порожденный интервал не переносились позиции, которых в нем нету,но они есть в текущем
                                       -- Удаляются только позиции
                                       /*DELETE FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND
                                       t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.ind_mo='0';*/
/*                                       IF trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r.EXISTS(c.rn_ispob_ch) THEN
                                          IF trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n.EXISTS(c.ez) THEN
                                             m:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v.FIRST;
                                             WHILE m IS NOT NULL LOOP
                                                   IF trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(m).ind=0 THEN
                                                   trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v.DELETE(m);
                                             END IF;
                                             m:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v.next(m);
                                             END LOOP;
                                         END IF;
                                       END IF;
*/                                       ---Удаление того что создано по тому же key
/*                                       IF (oldkey=key) THEN
\*                                            DELETE FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND
                                            t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.key=key;
*\                                         FOR g3 IN (SELECT t2.* FROM TABLE (CAST(trall.dfarid AS t_res_dfarid) ) t1
                                                        JOIN TABLE( cast (trall.disp  AS t_res_disp) ) t2 ON t1.rn=t2.rn_farids_fk
                                                        WHERE dstart_fk=to_char(p.dstart\*c.dstart*\,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid
                                           ) LOOP
                                                  IF g3.key=key THEN
                                                           for iut in (select rn from table(cast (trall.dez as t_res_dez )) where rn_isp_fk=g3.rn ) loop
                                                               trall.dez.delete(iut.rn);
                                                           end loop;
                                                           trall.disp.delete(g3.rn);
                                                           --+ Надо удалить их единицы измерения

                                                          DELETE FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND
                                                          t.farid=p.farid AND t.rn_isp=g3.rn_ispob;
                                                  ELSE --Не равен (mo)
                                                      FOR g4 IN (SELECT * FROM TABLE( CAST(trall.dez AS t_res_dez) ) WHERE   rn_isp_fk =g3.rn ) LOOP
                                                          IF g4.key=key THEN
                                                                  trall.dez.delete(g4.rn);
                                                                  DELETE FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND
                                                                   t.farid=p.farid AND t.rn_isp=g3.rn_ispob AND t.n=g4.ez;
                                                          ELSE--Не равен (ez)
                                                              DELETE FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND
                                                                   t.farid=p.farid AND t.rn_isp=cycrn_ispob_ch AND t.n=cycez AND t.key_mo=key;
                                                          END IF;
                                                      END LOOP;
                                                  END IF;
                                            END LOOP;
                                            \*cycrn_ispob_ch:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r.first;
                                            WHILE cycrn_ispob_ch IS NOT NULL LOOP
                                                   IF trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(cycrn_ispob_ch).key=key THEN
                                                          trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r.DELETE(cycrn_ispob_ch);
                                                          DELETE FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND
                                                          t.farid=p.farid AND t.rn_isp=cycrn_ispob_ch;
                                                   ELSE
                                                         cycez:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(cycrn_ispob_ch).n.FIRST;
                                                         WHILE cycez IS NOT NULL LOOP
                                                               IF trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(cycrn_ispob_ch).n(cycez).key=key THEN
                                                                  trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(cycrn_ispob_ch).n.DELETE(cycez);
                                                                  DELETE FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND
                                                                   t.farid=p.farid AND t.rn_isp=cycrn_ispob_ch AND t.n=cycez;

                                                               ELSE
                                                                   DELETE FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND
                                                                   t.farid=p.farid AND t.rn_isp=cycrn_ispob_ch AND t.n=cycez AND t.key_mo=key;
\*                                                                   cycrn_pozmo:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(cycrn_ispob_ch).n(cycez).v.FIRST;
                                                                   WHILE cycrn_pozmo IS NOT NULL LOOP
                                                                      IF trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(cycrn_ispob_ch).n(cycez).v(cycrn_pozmo).key=key THEN
                                                                          trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(cycrn_ispob_ch).n(cycez).v.DELETE(cycrn_pozmo);
                                                                      END IF;
                                                                      cycrn_pozmo:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(cycrn_ispob_ch).n(cycez).v.NEXT(cycrn_pozmo);
                                                                   END LOOP;
*\                                                               END IF;
                                                               cycez:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(cycrn_ispob_ch).n.NEXT(cycez);
                                                         END LOOP;
                                                   END IF;
                                            cycrn_ispob_ch:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r.NEXT(cycrn_ispob_ch);
                                            END LOOP;*\
                                       END IF;
*/                                   ELSE-- Есть дата, нет фарида откуда
                                    trall.dfarid ( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' ||  to_char(p.farid) ).ind:=null;
                                   end if;
                               else-- Еще вообще ничего нет
/*                                       trall.ddstart.EXTEND;
                                       trall.ddstart(trall.ddstart.last):=t_res_dstart_el( to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS') );*/
                                       trall.ddstart(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) :='1';
                                       trall.dfarid ( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' ||  to_char(p.farid) ).ind:=null;
                                 --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS'))(p.farid).ind:=null;
                               end if;
                           --  to_char(с.dstart,'DD.MM.YYYY HH24:MI:SS')
                /*dstart*/END IF;
                        --tb_rint:=t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid);
                        fl_first_record:=0;

                        IF c.ind=2 THEN
                           BEGIN
                            vRn_pozmo:=f_res_cex_pol_mat( c.rn_tv,  p.dstart ,p.farid) ;
                            EXCEPTION 
                                      WHEN NO_DATA_FOUND THEN
                                      vRn_pozmo:=NULL;
                            END;
                            IF vRN_Pozmo IS NULL THEN
                               GOTO next_state;
                            END IF;
                        ELSE
                            vRn_Pozmo:=c.rn_pozmo;
                        END IF;
                        --Раскомплектовка Веры!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IF NOT yntd.EXISTS(c.tv_ch) THEN
   SELECT COUNT(*) INTO iExists FROM (select * from v_poz_mo_b t5 JOIN w_ktsg.v_tehn_dob_b p5 ON t5.ARID=p5.arid_pozmo
   WHERE t5.RN_TV=c.tv_ch and rownum<2);
   IF iExists=0 THEN
      yntd(c.tv_ch):='0';
   ELSE
       yntd(c.tv_ch):='1';
   END IF;
END IF;
IF yntd(c.tv_ch) ='1' THEN
        vRn_Pozmo2:=vRn_Pozmo;
ELSE
        vRn_Pozmo2:=1;
END IF;
                        If c.rnisp_k=c.rn_ispob_ch and c.rn_tv=p_rntv then-- Изделие на которое производим расчет, входит само в себя
--                           t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).vidzag:=c.vidzag;
                             --IF fl_forall AND p.farid =-1 THEN -- Если для всех интервалов и текущий не 1 
                             SELECT COUNT(*) INTO iExists FROM (select * from tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                       AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=vRn_Pozmo AND t.ind_mo='0' and rownum<2);
                                       IF iExists>0 THEN
                                                                  UPDATE tb_res_fap t SET t.ind_mo=c.ind
                                                                  WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND
                                                                  t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=vRn_pozmo
                                                     RETURNING t.rn INTO iExists;
                                       ELSE
                                                --SELECT seq_res.NEXTVAL INTO iExists  FROM dual;
                                         iExists:=res_sequence;
                                         res_sequence:=res_sequence+1;

                                             INSERT INTO tb_res_fap
                                               (dstart, farid, rn_isp, n, v, ez, ind_mo,  key_mo,rn)
                                             VALUES
                                               (to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS'), p.farid, c.rn_ispob_ch, c.ez,vRn_pozmo,NULL,'1'/*c.ind*/, key,iExists);
                                        END IF;

                                        SELECT COUNT(*) INTO iExists2 from (select * FROM tb_res_dtv t WHERE
                                        t.rnmo_fk=iExists AND t.rntv=c.tv_ch and rownum<2);
                                        IF iExists2>0 THEN
                                             UPDATE v_res_dmotv t
                                                               SET t.ap=c.kol,
                                                                        t.uf=p_part
                                             WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND
                                             t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=vRn_pozmo AND t.rntv=c.tv_ch
                                             and (t.ap<>c.kol or t.uf<>p_part) ;
                                        ELSE
                                           --SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                         iExists2:=res_sequence;
                                         res_sequence:=res_sequence+1;
                                           
                                           INSERT INTO tb_res_dtv
                                             (rnmo_fk, rn, rntv, uf, ap)
                                           VALUES
                                             (iExists, iExists2, c.tv_ch, p_part, c.kol);
                                        END IF;
/*                                        SELECT COUNT(*) INTO iExists FROM TABLE( CAST (trall.ddstart AS t_res_dstart) ) WHERE rn=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS');
                                        IF iExists=0 THEN*/
                                        IF NOT trall.ddstart.EXISTS ( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') )  THEN
/*                                               trall.ddstart.EXTEND;
                                               trall.ddstart(trall.ddstart.last):=t_res_dstart_el( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') );
*/                                               trall.ddstart( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') ):='1';
                                        END IF;

                                        IF NOT trall.dfarid.EXISTS(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ) THEN
                                                trall.dfarid( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).ind:=NULL;
                                        END IF;

                                        IF NOT trall.disp.EXISTS( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ) THEN
                                           trall.disp( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ):=NULL;

                                        END IF;

                                        IF NOT trall.dez.EXISTS( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) || ' ' || to_char(c.ez) ) THEN
                                           trall.dez( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) || ' ' || to_char(c.ez) ):=NULL;
                                           trall.disp_ez( to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ):=to_char(c.ez);
                                        END IF;


                                        --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).tmp:='1';

                           /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).ind:=c.ind;*/

                           --dbms_output.put_line('tb_rcount1=' || t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r.COUNT);
                           --dbms_output.put_line('tb_rcount2=' || t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r.COUNT);
                           --tb_rint.tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).podr:=c.rn_podr;
                           --tb_rint.tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(r.tv_ch).ak:=r.kol*r.doly_ch;

                           /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).ap:=c.kol;--*c.doly_ch;*/
                           --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ak:= t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak;
                           --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ap:= t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ap;

                           /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).cur_kol:=c.kol;*/
                           --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).rn_vo:=r.rn_vo;
                           --t(r.kdce_ch).n(r.ez).s_ak:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ak;
                           --t(r.kdce_ch).n(r.ez).s_ap:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ap;
                           /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).uf:=p_part;*/
                           --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).u:=p_part;
                           --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).uf_vz:=p_part;
                           --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).u_vz:=p_part;
                           END IF;
                       --end if;
                       --dbms_output.put_line('tb_rcount=' || tb_rint.tb_r.COUNT);
   /* if c.rnisp_k = 477516 then
      FOR iut IN trall.ddstart.FIRST..trall.ddstart.LAST LOOP
          dbms_output.put_line('123=' || trall.ddstart(iut).rn  );
      END LOOP;
      FOR iut IN trall.dfarid.FIRST.. trall.dfarid.LAST LOOP
          dbms_output.put_line('555rn=' || trall.dfarid(iut).rn );
          dbms_output.put_line('555dstart_fk=' || trall.dfarid(iut).dstart_fk );
          dbms_output.put_line('555farid=' || trall.dfarid(iut).farid );
      END LOOP;
      FOR iut IN trall.disp.FIRST.. trall.disp.LAST LOOP
          dbms_output.put_line('777key=' || trall.disp(iut).key);
          dbms_output.put_line('777rn=' || trall.disp(iut).rn);
          dbms_output.put_line('777rn_farids_fk=' || trall.disp(iut).rn_farids_fk);
          dbms_output.put_line('777rn_ispob=' || trall.disp(iut).rn_ispob);
      END LOOP;

   end if;*/


                        /*SELECT COUNT(*) INTO iExists FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                        JOIN TABLE( CAST (trall.disp AS t_res_disp) )  g3 ON g3.rn_farids_fk=g4.rn
                                        WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid AND rn_ispob=c.rnisp_k;
                                IF iExists<>0 THEN*/
                                IF trall.disp.EXISTS(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rnisp_k) ) THEN
                                        cntI:=cntI+1;
--                        /*0*/if trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r.exists(c.rnisp_k) then
                                --t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_ez:=t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rnisp_k).n.first;
                               dez_i:=trall.disp_ez(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rnisp_k) );
                               /*dez_i:=trall.dez.FIRST;*/
                               Ez_am.DELETE;
                               IF length(dez_i)=0 THEN
                                        vEz:=NULL;
                              ELSIF instr(dez_i,' ')=0 THEN
                                      vEz:=dez_i;
                                      dez_i:='';
                               ELSE
                                  vEz:=substr(dez_i,1,instr(dez_i,' ')-1);
                                  dez_i:=substr( dez_i,instr(dez_i,' ')+1, length(dez_i)-instr(dez_i,' ') );
                               END IF;
                                WHILE vEz IS NOT NULL LOOP

                                      ez_am(vEz):='1';

                                IF nvl(length(dez_i),0)=0 THEN
                                        vEz:=NULL;
                              ELSIF instr(dez_i,' ')=0 THEN
                                      vEz:=dez_i;
                                      dez_i:='';
                                ELSE
                                    vEz:=substr(dez_i,1,instr(dez_i,' ')-1);
                                    dez_i:=substr( dez_i,instr(dez_i,' ')+1, length(dez_i)-instr(dez_i,' ') );
                                END IF;
                                END LOOP;
                                vEz:=ez_am.FIRST;
                                WHILE vEz IS NOT NULL LOOP
                                      --IF  instr(dez_i, to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rnisp_k) || ' ' ) <>0 THEN
                                            --vEz:=substr(dez_i, instr(dez_i,' ' ,1, 4)+1,length(dez_i)-instr(dez_i,' ' ,1, 4) );
/*                                 FOR n_ez2 IN ( SELECT g2.rn,g2.ez FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                        JOIN TABLE( CAST (trall.disp AS t_res_disp) )  g3 ON g3.rn_farids_fk=g4.rn
                                        JOIN TABLE( CAST (trall.dez AS t_res_dez) )  g2 ON g2.rn_isp_fk=g3.rn
                                        WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid AND rn_ispob=c.rnisp_k) LOOP
*//*                                n_ez:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rnisp_k).n.first;
                                WHILE n_ez is not null LOOP
*/                              IF yntd(c.rn_tv)='1' OR c.tv_ch=p_rntv THEN --Есть ТД или это голова                                             
                                             SELECT count(*) INTO iExists FROM (SELECT * FROM v_res_dmotv t WHERE  t.rn_isp=c.rnisp_k AND t.n=vEz AND t.v=vRn_Pozmo 
                                             AND t.rntv=c.rn_tv AND t.pri IS NOT NULL AND rownum<2);
                                            IF iExists=0 THEN --Не для всех было
                                               SELECT ap INTO vAp FROM v_res_dmotv t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                                            AND t.farid=p.farid AND t.rn_isp=c.rnisp_k AND t.n=vEz AND t.v=vRn_Pozmo AND t.rntv=c.rn_tv;
                                            ELSE -- Для всех
                                               SELECT ap INTO vAp FROM v_res_dmotv t WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS')
                                                            AND t.farid=-1 AND t.rn_isp=c.rnisp_k AND t.n=vEz AND t.v=vRn_Pozmo AND t.rntv=c.rn_tv;
                                            END IF;
                                ELSE -- Нету ТД
                                             SELECT count(*) INTO iExists FROM (SELECT * FROM v_res_dmotv t WHERE  t.rn_isp=c.rnisp_k AND t.n=vEz AND t.v=1 
                                             AND t.rntv=c.rn_tv AND t.pri IS NOT NULL AND rownum<2);
                                           IF iExists=0 THEN
                                                SELECT ap INTO vAp FROM v_res_dmotv t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                                        AND t.farid=p.farid AND t.rn_isp=c.rnisp_k AND t.n=vEz AND t.v=1 AND t.rntv=c.rn_tv;
                                           ELSE
                                                SELECT ap INTO vAp FROM v_res_dmotv t WHERE t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS')
                                                        AND t.farid=-1 AND t.rn_isp=c.rnisp_k AND t.n=vEz AND t.v=1 AND t.rntv=c.rn_tv;
                                           END IF;
                                END IF;

                                case --расчитаем uf
                                when /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid)*/c.ind=3 THEN
                                      trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).uf:=f_res_calculate_kol_obarz(c.tv_ch,f_get_mo_actual(p.dstart,p.farid,vRn_pozmo,p_start),/*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rnisp_k).n(n_ez).v(vRN_pozmo).q(c.rn_tv).ap*/vAp,p.dstart,p.farid,p_start);
                                      trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).ind:=1;
                                      --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf:=f_res_calculate_kol_obarz(c.tv_ch,f_get_mo_actual(p.dstart,p.farid,vRn_pozmo),/*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rnisp_k).n(n_ez).v(vRN_pozmo).q(c.rn_tv).ap*/vAp,p.dstart,p.farid);
                                      --u:=0;
                                      /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).ind:=1;*/
                                else
                                      --u:=t(r.kdce_k).n(n_ez).v(r.rn_pozmo).q(r.tv_k).ak;
                                      --UPDATE TABLE(CAST (trall.dfarid AS t_res_dfarid) ) p3  SET value(p3)=t_res_dfarid_el(NULL,NULL,NULL,NULL,NULL,NULL,NULL) WHERE p3.dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid;
                                      trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).uf:=vAp;
                                      trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).ind:=0;
                                      --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf:=/*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rnisp_k).n(n_ez).v(vRN_pozmo).q(c.rn_tv).ap*/vAp;
                                      --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).ind:=0;
                                end case;
                                --сама раскомплектовка
/*                        SELECT COUNT(*) INTO iExists FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                        JOIN TABLE( CAST (trall.disp AS t_res_disp) )  g3 ON g3.rn_farids_fk=g4.rn
                                        WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid AND rn_ispob=c.rn_ispob_ch;
                                IF iExists<>0 THEN
                                        */
                                        IF fl_use_forall='1' AND fl_forall='1' THEN 
                                            vpDstart:=p_start;
                                            vpFarid:=-1;
                                        ELSE
                                            vpDstart:=p.dstart;
                                            vpFarid:=p.farid;
                                        END IF;
                                 -- case добавлен экспериментально - чтоб записывалось в UF 01.08.2008 одна позиция на все состояния
                                case --расчитаем uf 
                                when /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid)*/c.ind=3 THEN
                                      trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).uf:=f_res_calculate_kol_obarz(c.tv_ch,f_get_mo_actual(p.dstart,p.farid,vRn_pozmo,p_start),/*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rnisp_k).n(n_ez).v(vRN_pozmo).q(c.rn_tv).ap*/vAp,p.dstart,p.farid,p_start);
                                      trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).ind:=1;
                                      --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf:=f_res_calculate_kol_obarz(c.tv_ch,f_get_mo_actual(p.dstart,p.farid,vRn_pozmo),/*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rnisp_k).n(n_ez).v(vRN_pozmo).q(c.rn_tv).ap*/vAp,p.dstart,p.farid);
                                      --u:=0;
                                      /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).ind:=1;*/
                                else
                                      --u:=t(r.kdce_k).n(n_ez).v(r.rn_pozmo).q(r.tv_k).ak;
                                      --UPDATE TABLE(CAST (trall.dfarid AS t_res_dfarid) ) p3  SET value(p3)=t_res_dfarid_el(NULL,NULL,NULL,NULL,NULL,NULL,NULL) WHERE p3.dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid;
                                      trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).uf:=vAp;
                                      trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).ind:=0;
                                      --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf:=/*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rnisp_k).n(n_ez).v(vRN_pozmo).q(c.rn_tv).ap*/vAp;
                                      --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).ind:=0;
                                end case;
                                
                                        IF trall.disp.EXISTS(to_char(vpDstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vPfarid) || ' ' || to_char(c.rn_ispob_ch) ) THEN
                                        cntI2:=cntI2+1;
                                --/*1*/If trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r.EXISTS(c.rn_ispob_ch) then
                                       /*SELECT COUNT(*) INTO iExists2 FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                        JOIN TABLE( CAST (trall.disp AS t_res_disp) )  g3 ON g3.rn_farids_fk=g4.rn
                                        JOIN TABLE( CAST (trall.dez AS t_res_dez) )  g2 ON g2.rn_isp_fk=g3.rn
                                        WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid AND rn_ispob=c.rn_ispob_ch AND ez=c.ez;
                                        IF iExists2<>0 THEN
                                        */
                                        IF trall.dez.EXISTS(to_char(vPdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vPfarid) || ' ' || to_char(c.rn_ispob_ch) || ' ' || to_char(c.ez) ) THEN
                                        cntI3:=cntI3+1;
                                        --/*2*/If trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n.EXISTS(c.ez) THEN
                                                   /* IF yntd(c.tv_ch) ='1' THEN --Есть ТД*/
                                                         SELECT COUNT(*) INTO iExists FROM (select * from tb_res_fap t WHERE t.dstart=to_char(vpDstart,'DD.MM.YYYY HH24:MI:SS')
                                                         AND t.farid=vpFarid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=vRn_Pozmo and rownum<2);
                                                    /*ELSE --Нет ТД
                                                         SELECT COUNT(*) INTO iExists FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                                         AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=1;
                                                    END IF;*/
                                                /*3*/If iExists>0 THEN /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v.EXISTS(vRN_pozmo) then*/
                                                     cntI4:=cntI4+1;
                                                                  SELECT COUNT(*) INTO iExists2 FROM (select * from v_res_dmotv t WHERE t.dstart=to_char(vpDstart,'DD.MM.YYYY HH24:MI:SS')
                                                                  AND t.farid=vpFarid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=vRn_Pozmo AND t.rntv=c.tv_ch and rownum<2 );

                                                         /*4*/if iExists2>0 THEN /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q.EXISTS(c.tv_ch) then*/
                                                                 cntI5:=cntI5+1;
                                                                      If NOT (c.rn_tv=p_rntv AND c.tv_ch=p_rntv) then
                                                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak+(u-t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).u)*r.kol*r.doly_ch;
/*                                                                              SELECT uf INTO vAp FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                                                                WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid;*/

                                                                                /*IF c.rn_ispob_ch=815318 THEN
                                                                                SELECT t.uf INTO vAp FROM
                                                                                v_res_dmotv t
                                                                                WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch
                                                                               AND t.n=c.ez AND t.v=vRn_pozmo AND t.rntv=c.tv_ch;
                                                                                   dbms_output.put_line(p.dstart || ' ' || p.farid || ' ' || nvl(vAp,-123));
                                                                                END IF;*/
                                                                                vAp:=trall.dfarid ( to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).uf;
                                                                         UPDATE v_res_dmotv t
                                                                               SET t.ap=t.ap+(vAp-t.uf) * c.kol
                                                                               WHERE t.dstart=to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid=vpfarid AND t.rn_isp=c.rn_ispob_ch
                                                                               AND t.n=c.ez AND t.v=vRn_pozmo AND t.rntv=c.tv_ch 
                                                                               and t.ap<>t.ap+(vAp-t.uf) * c.kol;
                                                                               /*if c.tv_ch=492085 and key=498 then
                                                                                  return 1;
                                                                               end if;*/
/*                                                                         UPDATE v_res_dmotv t
                                                                               SET t.ap=t.ap+(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf-t.uf) * c.kol
                                                                               WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch
                                                                               AND t.n=c.ez AND t.v=vRn_pozmo2 AND t.rntv=c.tv_ch;
*/
                                                                         /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).ap:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).ap+(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf-trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).uf)*c.kol;*/
                                                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ak:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ak+(u-t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).u)*r.kol*r.doly_ch;
                                                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ap:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ap+(uf-t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).uf)*r.kol*r.doly_ch;

                                                                          trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3:=0;
                                                                         FOR r1 IN (SELECT t.dstart, t.farid, t.rn_isp, t.n, t.v FROM tb_res_fap t WHERE (t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                                                                   AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.ind_mo<>0 ) OR (
                                                                                     t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS')
                                                                                   AND t.farid=-1 AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.ind_mo<>0  AND t.pri IS NOT NULL)
                                                                                   ) LOOP
                                                                                   FOR r2 IN (SELECT ap FROM v_res_dmotv t WHERE t.dstart=r1.dstart
                                                                                   AND t.farid=r1.farid AND t.rn_isp=r1.rn_isp AND t.n=r1.n AND t.v=r1.v AND t.rntv=c.tv_Ch ) LOOP
                                                                                       trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid)).kol3:=trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid)).kol3+r2.ap;
                                                                                   END LOOP;
                                                                         END LOOP;
                                                                        -- trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3:=0;

                                                                         /*tb_kol:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez);
                                                                         --kol1:=0;kol3_vz:=0;kol1_vz:=0;
                                                                         trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo:=tb_kol.v.first;
                                                                         while trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo is not null loop
                                                                               if tb_kol.v(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_Pozmo).ind<>0 then
                                                                                  trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3+tb_kol.v(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_Pozmo).q(c.tv_ch).ap;
                                                                                  --kol1:=kol1+tb_kol.v(tb_rinf.n_Pozmo).q(c.tv_ch).ak;
                                                                               end if;
                                                                               trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo:=tb_kol.v.next(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo);
                                                                         end loop;*/
                                                                      ELSE
                                                                      trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3:=p_part;
/*                                                                        FOR uit IN (select rn FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                                                                WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid) LOOP
                                                                                   trall.dfarid(uit.rn).kol3:=p_part;
                                                                        END LOOP;
*/
                                                                          --kol1:=p_part;
                                                                      end if;
                                                         /*4*/ELSE -- Нет ТВ
                                                                  --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak:=u*r.kol*r.doly_ch;
/*                                                                  SELECT uf INTO vAp FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                                                                WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid;*/
                                                                  vAp:=trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).uf;
                                                                  SELECT t.rn INTO iExists FROM tb_res_fap t
                                                                               WHERE t.dstart=to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid=vpfarid AND t.rn_isp=c.rn_ispob_ch
                                                                               AND t.n=c.ez AND t.v=vRn_pozmo;
--                                                                   SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                                                     iExists2:=res_sequence;
                                                                     res_sequence:=res_sequence+1;
                                                                     
                                                                   INSERT INTO tb_res_dtv
                                                                     (rnmo_fk, rn, rntv, uf, ap)
                                                                   VALUES
                                                                     (iExists, iExists2, c.tv_ch,vAp, vAp*c.kol);

                                                                  /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).ap:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf*c.kol;--*r.doly_ch;*/

                                                                  --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ak:=t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ak+t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak;
                                                                  --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ap:=t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ap+t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ap;


                                                                          trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3:=0;
                                                                          FOR r1 IN ( SELECT t.dstart,t.farid,t.rn_isp,t.n,t.v FROM tb_res_fap t WHERE (t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                                                                           AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.ind_mo<>0 ) OR (
                                                                                     t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS') AND t.farid=-1
                                                                                      AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.ind_mo<>0  AND t.pri IS NOT NULL)
                                                                                           ) LOOP
                                                                                            FOR r2 IN (SELECT ap FROM v_res_dmotv t WHERE t.dstart=r1.dstart
                                                                                           AND t.farid=r1.farid AND t.rn_isp=r1.rn_isp AND t.n=r1.n AND t.v=r1.v AND t.rntv=c.tv_Ch ) LOOP
                                                                                     trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3:=trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3+r2.ap;
                                                                                     END LOOP;
                                                                          END LOOP;
--                                                                  trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3:=0;
/*                                                                  tb_kol:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez);
                                                                  --kol1:=0;kol3_vz:=0;kol1_vz:=0;
                                                                  trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo:=tb_kol.v.first;
                                                                  while trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo is not null loop
                                                                        if tb_kol.v(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_Pozmo).ind<>0 then
                                                                           trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3+tb_kol.v(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_Pozmo).q(c.tv_ch).ap;
                                                                           --kol1:=kol1+tb_kol.v(n_Pozmo).q(r.tv_ch).ak;
                                                                           end if;
                                                                           trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo:=tb_kol.v.next(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo);
                                                                  end loop;
*/                                                         /*4*/end if;
                                                /*3*/ELSE --Нет МО
                                              vAp:=trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).uf;
                                                --SELECT seq_res.NEXTVAL INTO iExists FROM dual;
                                                iExists:=res_sequence;
                                                res_sequence:=res_sequence+1;
                                                
                                         INSERT INTO tb_res_fap
                                           (dstart, farid, rn_isp, n, v, ez, ind_mo,  key_mo,rn,pri)
                                         VALUES
                                           (to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS'), vpfarid, c.rn_ispob_ch, c.ez, vRn_pozmo,NULL, c.ind, key,iExists,fl_forall);
                                           --SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                             iExists2:=res_sequence;
                                             res_sequence:=res_sequence+1;
                                           
                                           INSERT INTO tb_res_dtv
                                             (rnmo_fk, rn, rntv, uf, ap)
                                           VALUES
                                             (iExists, iExists2, c.tv_ch,vAp, vAp*c.kol);
                                                         /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).key:=key;
                                                         trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).ind:=c.ind;*/--Расчитаем по составу

                                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).podr:=r.rn_podr;
                                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak:=u*r.kol*r.doly_ch;
                                                         /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).ap:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf*c.kol;*/
                                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ak:= t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak;
                                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ap:= t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ap;
                                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).cur_kol:=r.kol;
                                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).cur_kol_vz:=r.kol_vz;
                                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).rn_vo:=r.rn_vo;
                                                         --tb_kol:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez);
                                                         trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3:=0;
                                                          FOR r1 IN ( SELECT t.dstart,t.farid,t.rn_isp,t.n,t.v FROM tb_res_fap t WHERE (t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                                                           AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.ind_mo<>0 ) OR (
                                                                                     t.dstart=to_char(p_start,'DD.MM.YYYY HH24:MI:SS')
                                                                                   AND t.farid=-1 AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.ind_mo<>0  AND t.pri IS NOT NULL)
                                                                           
                                                                           ) LOOP
                                                                            FOR r2 IN (SELECT ap FROM v_res_dmotv t WHERE t.dstart=r1.dstart
                                                                           AND t.farid=r1.farid AND t.rn_isp=r1.rn_isp AND t.n=r1.n AND t.v=r1.v AND t.rntv=c.tv_Ch ) LOOP
                                                                     trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3:=trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3+r2.ap;
                                                                     END LOOP;
                                                          END LOOP;
                                                           --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3:=0;
                                                         --kol1:=0;kol3_vz:=0;kol1_vz:=0;
/*                                                         trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo:=tb_kol.v.first;
                                                         while trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo is not null loop
                                                               if tb_kol.v(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_Pozmo).ind<>0 then
                                                                  trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3+tb_kol.v(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_Pozmo).q(c.tv_ch).ap;
                                                                  --kol1:=kol1+tb_kol.v(n_Pozmo).q(r.tv_ch).ak;
                                                                  --kol3_vz:=kol3_vz+tb_kol.v(n_Pozmo).q(r.tv_ch).ap_vz;
                                                                  --kol1_vz:=kol1_vz+tb_kol.v(n_Pozmo).q(r.tv_ch).ak_vz;
                                                               end if;
                                                               trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo:=tb_kol.v.next(trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).n_pozmo);
                                                         end loop;
*/
/*                                                                         FOR r1 IN ( SELECT t.dstart,t.farid,t.rn_isp,t.n,t.v FROM tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                                                                   AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.ind_mo<>0 ) LOOP
                                                                                    FOR r2 IN (SELECT ap FROM v_res_dmotv t WHERE t.dstart=r1.dstart
                                                                                   AND t.farid=r1.farid AND t.rn_isp=r1.rn_isp AND t.n=r1.n AND t.v=r1.v AND t.rntv=c.tv_Ch ) LOOP
                                                                                       trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3+r2.ap;
                                                                                   END LOOP;
                                                                         END LOOP;*/
                                                /*3*/end if;
                                        /*2*/ELSE --ez нету

                                                  vAp:=trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).uf;
                                                   trall.dez(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) || ' ' || to_char(c.rn_ispob_ch) || ' ' || to_char(c.ez)):=key;
/*                                                   IF c.tv_ch=1563810 THEN
                                                      dbms_output.put_line('dst=' || nvl(trall.disp_ez(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ),-11));
                                                   END IF;
*/                                                   trall.disp_ez(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) || ' ' || to_char(c.rn_ispob_ch) ):= nvl(trall.disp_ez(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) || ' ' || to_char(c.rn_ispob_ch)),'') ||' ' || to_char(c.ez);
/*                                                     SELECT g3.rn INTO iExists FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                                      JOIN TABLE( CAST (trall.disp AS t_res_disp) )  g3 ON g3.rn_farids_fk=g4.rn
                                                      WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid AND rn_ispob=c.rn_ispob_ch;*/

                                                     /*trall.dez.EXTEND;
                                                     trall.dez(trall.dez.LAST):=t_res_dez_el(dez_idx, iExists, c.ez, key);
                                                     dez_idx:=dez_idx+1;  */

                                                 --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).key:=key;
                                                 --t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).vidzag:=c.vidzag;

                                           --SELECT seq_res.NEXTVAL INTO iExists FROM dual;
                                           iExists:=res_sequence;
                                           res_sequence:=res_sequence+1;
                                           
                                           INSERT INTO tb_res_fap
                                           (dstart, farid, rn_isp, n, v, ez, ind_mo,  key_mo,rn,pri)
                                         VALUES
                                           (to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS'), vpfarid, c.rn_ispob_ch, c.ez, vRN_pozmo,null,c.ind, key,iExists,fl_forall);
                                           --SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                           iExists2:=res_sequence;
                                           res_sequence:=res_sequence+1;
                                           
                                           INSERT INTO tb_res_dtv
                                             (rnmo_fk, rn, rntv, uf, ap)
                                           VALUES
                                             (iExists, iExists2, c.tv_ch, vAp, vAp*c.kol);
                                                /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).ind:=c.ind;--Расчитаем по составу*/
                                                --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).podr:=r.rn_podr;
                                                --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak:=u*r.kol*r.doly_ch;
                                                /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).ap:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf*c.kol;*/--*r.doly_ch;
                                                 --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ak:= t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak;
                                                 --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ap:= t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ap;
                                                 --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).cur_kol:=r.kol;
                                                 --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).rn_vo:=r.rn_vo;
/*                                                         FOR uit IN (SELECT rn FROM TABLE(CAST(trall.dfarid AS t_res_dfarid))
                                                                                WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid) LOOP
                                                                           trall.dfarid(uit.rn).kol3:=vAp*c.kol;--trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).ap;
                                                          END LOOP;*/
                                                          trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3:=vAp*c.kol;
                                                 --kol1:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak;
                                                 --kol3_vz:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ap_vz;
                                                 --kol1_vz:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak_vz;
                                        /*2*/end if;
                                /*1*/ELSE -- ispob_ch
                                                  vAp:=trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).uf;
                                                  /*SELECT uf INTO vAp FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                                               WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid;*/
                                                     trall.disp(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) || ' ' || to_char(c.rn_ispob_ch) ):=key;
                                                     trall.disp_ez(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) || ' ' || to_char(c.rn_ispob_ch) ):=to_char(c.ez);
                                                     trall.dez(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) || ' ' || to_char(c.rn_ispob_ch)  || ' ' || to_char(c.ez) ):=NULL;

                                         --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).key:=key;
                                         --t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).vidzag:=c.vidzag;
                                         /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).ind:=c.ind;--Расчитаем по составу*/
                                         --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).tmp:='1';
                                           --SELECT seq_res.NEXTVAL INTO iExists  FROM dual;
                                         iExists:=res_sequence;
                                         res_sequence:=res_sequence+1;
                                           --SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                         iExists2:=res_sequence;
                                         res_sequence:=res_sequence+1;

                                         INSERT INTO tb_res_fap
                                           (dstart, farid, rn_isp, n, v, ez, ind_mo,  key_mo,rn,pri)
                                         VALUES
                                           (to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS'), vpfarid, c.rn_ispob_ch, c.ez,vRN_pozmo,NULL,c.ind, key,iExists,fl_forall);
                                           INSERT INTO tb_res_dtv
                                             (rnmo_fk, rn, rntv, uf, ap)
                                           VALUES
                                             (iExists, iExists2, c.tv_ch, vAp, vap*c.kol);

                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).podr:=r.rn_podr;
                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak:=u*r.kol*r.doly_ch;
                                         /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).ap:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf*c.kol;--*r.doly_ch;*/
                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ak:= t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak;
                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).s_ap:= t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ap;
                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).cur_kol:=r.kol;
                                         --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).rn_vo:=r.rn_vo;
                                        trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3:=vAp*c.kol;
                                        --trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf*c.kol;----trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).ap;
                                         --kol1:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak;
                                         --kol3_vz:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ap_vz;
                                         --kol1_vz:=t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).ak_vz;
                                /*1*/end if;
                                IF fl_forallo IS NOT NULL THEN --Надо размножить по всем интервалам
                                   FOR afg IN (SELECT att_arstart AS dstart,farid  FROM TABLE (cast(intv AS t_res_tb_intv)) ) LOOP
                                          IF NOT trall.disp.EXISTS (to_char(afg.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(afg.farid) || ' ' || to_char(c.rn_ispob_ch) ) THEN
                                                  trall.disp(to_char(afg.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(afg.farid) || ' ' || to_char(c.rn_ispob_ch) ):=key;
                                          END IF;
                                          IF NOT  trall.disp_ez.EXISTS(to_char(afg.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(afg.farid) || ' ' || to_char(c.rn_ispob_ch) ) THEN
                                                   trall.disp_ez(to_char(afg.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(afg.farid) || ' ' || to_char(c.rn_ispob_ch) ):=to_char(c.ez);
                                          ELSIF instr(trall.disp_ez(to_char(afg.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(afg.farid) || ' ' || to_char(c.rn_ispob_ch) ),to_char(c.ez))=0 THEN
                                                  trall.disp_ez(to_char(afg.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(afg.farid) || ' ' || to_char(c.rn_ispob_ch) ):=nvl(trall.disp_ez(to_char(afg.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(afg.farid) || ' ' || to_char(c.rn_ispob_ch)),'') ||' ' || to_char(c.ez);
                                          END IF;
                                          IF NOT trall.dez.EXISTS(to_char(afg.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(afg.farid) || ' ' || to_char(c.rn_ispob_ch)  || ' ' || to_char(c.ez) ) THEN
                                                  trall.dez(to_char(afg.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(afg.farid) || ' ' || to_char(c.rn_ispob_ch)  || ' ' || to_char(c.ez) ):=key;
                                          END IF;
                                   END LOOP;
                                 ELSE
                                      --Добавляем в коллекции по что - то что должно было добавиться без объединения интервалов
                                      IF NOT trall.disp.EXISTS (to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ) THEN
                                              trall.disp(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ):=key;
                                      END IF;
                                      IF NOT  trall.disp_ez.EXISTS(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ) THEN
                                               trall.disp_ez(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ):=to_char(c.ez);
                                      ELSIF instr(trall.disp_ez(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ),to_char(c.ez))=0 THEN
                                              trall.disp_ez(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ):=nvl(trall.disp_ez(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch)),'') ||' ' || to_char(c.ez);
                                      END IF;
                                      IF NOT trall.dez.EXISTS(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch)  || ' ' || to_char(c.ez) ) THEN
                                              trall.dez(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch)  || ' ' || to_char(c.ez) ):=key;
                                      END IF;                                 
                                END IF;
                                --Добавляем в коллекции по что - то что должно было добавиться без объединения интервалов - заверш
                                            tb_td.DELETE;
                                        IF yntd(c.tv_ch)='1' THEN
/*                                                  SELECT kol3, ind INTO vAp,iExists FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                                               WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid;
*/                                            p_res_calculate_td2(tb_td,c.tv_ch, trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3, p.dstart, p.farid, trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).ind, p_start ,c.flag);
                                m:=tb_td.first;
                                while m is not null loop
                                      /*n:=tb_td(m).d.first;
                                      while n is not null LOOP*/
                                       SELECT COUNT(*) INTO iExists FROM ( select * from tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                       AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=m and rownum<2) ;
                                       IF iExists>0 THEN
                                               UPDATE tb_res_fap t
                                                     SET t.ez=c.ez,
                                                              t.ind_mo='0'
                                                     WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch
                                                     AND t.n=c.ez AND t.v=m
                                                     RETURNING t.rn INTO iExists;
                                       ELSE
                                                --SELECT seq_res.NEXTVAL INTO iExists  FROM dual;
                                         iExists:=res_sequence;
                                         res_sequence:=res_sequence+1;

                                             INSERT INTO tb_res_fap
                                               (dstart, farid, rn_isp, n, v, ez, ind_mo,  key_mo,rn,pri)
                                             VALUES
                                               (to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS'), p.farid, c.rn_ispob_ch, c.ez,m,c.ez,'0', NULL,iExists,fl_forallo);
                                        END IF;

                                        SELECT COUNT(*) INTO iExists2 from (select * FROM tb_res_dtv t WHERE
                                        t.rnmo_fk=iExists AND t.rntv=c.tv_ch and rownum<2);
                                        IF iExists2>0 THEN
                                        UPDATE tb_res_dtv t
                                           SET uf=vAp,
                                                     ap=tb_td(m).norm
                                         WHERE t.rnmo_fk=iExists AND t.rntv=c.tv_ch and 
                                         (uf<>vAp or  ap<>tb_td(m).norm);
                                        ELSE
                                           --SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                         iExists2:=res_sequence;
                                         res_sequence:=res_sequence+1;
                                           
                                           INSERT INTO tb_res_dtv
                                             (rnmo_fk, rn, rntv, uf, ap)
                                           VALUES
                                             (iExists, iExists2, c.tv_ch, vAp, tb_td(m).norm);
                                         END IF;
/*                                            UPDATE tb_res_fap t
                                                SET t.ap=t.ap+trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf * c.kol
                                               WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch
                                               AND t.n=c.ez AND t.v=m ;
*/
                                            /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(m).ind:=0;*/
                                            --t(c.rn_ispob_ch).n(r.ez).v(m).podr:=tb_td(m).rn_podr;
                                            --t(r.kdce_ch).n(r.ez).v(m).rn_vo:=tb_td(m).rn_vo;
                                            /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(m).q(c.tv_ch).n(n):=tb_td(m).d(n).td;*/
                                            --t(r.kdce_ch).n(r.ez).v(m).q(r.tv_ch).ak:=kol1;
                                            /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(m).q(c.tv_ch).ap:=tb_td(m).norm;*/
                                            --t(r.kdce_ch).n(r.ez).v(m).s_ak:= t(r.kdce_ch).n(r.ez).v(m).q(r.tv_ch).ak;
                                            --t(r.kdce_ch).n(r.ez).v(m).s_ap:= t(r.kdce_ch).n(r.ez).v(m).q(r.tv_ch).ap;
                                            /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(m).ez:=c.ez;*/
                                            /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(m).q(c.tv_ch).uf:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).kol3;*/
                                            --t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid)(r.kdce_ch).n(r.ez).v(m).q(r.tv_ch).u:=kol1;
                                            /*n:=tb_td(m).d.next(n);
                                      end loop;*/
                                      m:=tb_td.next(m);
                                end loop;
                                ELSE
                                    IF c.tv_ch<>1 THEN
                                          SELECT --+star
                                                COUNT(*) INTO iExists                                                
                                            from(
                                            select * from 
                                      w_ktsg.tb_poz_mo_s n
                                          JOIN (w_ktsg.v_audi a JOIN tb_auth_farid f ON a.att_auth=f.att_auth)
                                          ON     a.att_arver=0 and a.att_var=0
                                                                                          AND n.att_arid=a.att_arid
                                                                                       and n.objtype=a.att_objtype
                                                                                       and (p.dstart<a.att_arend
                                                                                           OR ( --p.dstart=p_start or 
                                                                                              (p.dstart=a.att_arend
                                                                                               AND p.farid<pk_tresult3.F_get_first_arid_for_end(a.att_arid)
                                                                                               and p.dstart<>p_start
                                                                                              )
                                                                                           )
                                                                                       )
                                                                                        and (p.dstart>a.att_arstart
                                                                                              OR (
                                                                                                 (p.dstart=p_start 
                                                                                                    and p.dstart=a.att_arstart
                                                                                                 )or 
                                                                                                 (  p.dstart=a.att_arstart
                                                                                                   AND
                                                                                                   p.farid>=f.farid --pk_tresult3.F_get_first_arid(a.att_auth)
                                                                                                   and p.dstart<>p_start
                                                                                                 )
                                                                                              )
                                                                                        )
                                         where
                                          n.rn_tv=c.tv_ch and rownum<2);
                                     IF iExists >0 THEN
                                    /*SELECT kol3 INTO vAp FROM TABLE(CAST(trall.dfarid AS t_res_dfarid)) g4
                                                               WHERE dstart_fk=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND farid=p.farid;*/
                                       vAp:=trall.dfarid(to_char(vpdstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(vpfarid) ).kol3;
                                       SELECT COUNT(*) INTO iExists FROM (select * from tb_res_fap t WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')
                                       AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch AND t.n=c.ez AND t.v=vRn_Pozmo2 and rownum<2);
                                       IF iExists>0 THEN
                                               UPDATE tb_res_fap t
                                                     SET t.ez=c.ez,
                                                              t.ind_mo='0'
                                                     WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch
                                                     AND t.n=c.ez AND t.v=vRn_Pozmo2
                                                     RETURNING t.rn INTO iExists;
                                       ELSE
                                                --SELECT seq_res.NEXTVAL INTO iExists  FROM dual;
                                                iExists:=res_sequence;
                                                res_sequence:=res_sequence+1;
                                                
                                             INSERT INTO tb_res_fap
                                               (dstart, farid, rn_isp, n, v, ez, ind_mo,  key_mo,rn,pri)
                                             VALUES
                                               (to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS'), p.farid, c.rn_ispob_ch, c.ez,vRn_Pozmo2,c.ez,'0', NULL,iExists,fl_forallo);
                                        END IF;

                                        SELECT COUNT(*) INTO iExists2 FROM (select * from tb_res_dtv t WHERE
                                        t.rnmo_fk=iExists AND t.rntv=c.tv_ch and rownum<2);
                                        IF iExists2>0 THEN
                                        UPDATE tb_res_dtv t
                                           SET uf=vAp,
                                                     ap=vAp--tb_td(m).norm
                                         WHERE t.rnmo_fk=iExists AND t.rntv=c.tv_ch and 
                                         (uf<>vAp or ap<>vAp);
                                        ELSE
                                           --SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                         iExists2:=res_sequence;
                                         res_sequence:=res_sequence+1;
                                                                                      
                                           INSERT INTO tb_res_dtv
                                             (rnmo_fk, rn, rntv, uf, ap)
                                           VALUES
                                             (iExists, iExists2, c.tv_ch, vAp, vAp/*tb_td(m).norm*/);
                                         END IF;
                                      END IF;
                                      END IF; -- iExists
                                END IF;--rntv=1
                                ufTmp:=trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).uf;
                                IF fl_forallo IS NULL  THEN
                                UPDATE v_res_dmotv t
                                                SET t.uf=trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).uf
                                               WHERE t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid=p.farid AND t.rn_isp=c.rn_ispob_ch
                                               AND t.n=c.ez AND t.v=vRn_Pozmo AND t.rntv=c.tv_ch
                                               and t.uf<>trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).uf;
                                 ELSE
                                UPDATE v_res_dmotv t
                                                SET t.uf=trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).uf
                                               WHERE /*t.dstart=to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') AND t.farid=p.farid AND*/ t.rn_isp=c.rn_ispob_ch
                                               AND t.n=c.ez AND t.v=vRn_Pozmo AND t.rntv=c.tv_ch
                                               and t.uf<>trall.dfarid(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) ).uf;
                                 END IF;
                                /*trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rn_ispob_ch).n(c.ez).v(vRN_pozmo).q(c.tv_ch).uf:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).uf;*/

                                --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).u:=u;
                                --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).uf_vz:=uf_vz;
                                --t(r.kdce_ch).n(r.ez).v(r.rn_pozmo).q(r.tv_ch).u_vz:=u_vz;
                                --n_ez:=trall.intv(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r(c.rnisp_k).n.NEXT(n_ez);
                                --END IF; -- Все ez
                                /*IF nvl(length(dez_i),0)=0 THEN
                                        vEz:=NULL;
                              ELSIF instr(dez_i,' ')=0 THEN
                                      vEz:=dez_i;
                                      dez_i:='';
                                ELSE
                                    vEz:=substr(dez_i,1,instr(dez_i,' ')-1);
                                    dez_i:=substr( dez_i,instr(dez_i,' ')+1, length(dez_i)-instr(dez_i,' ') );
                                END IF;*/
                                --dez_i:=trall.dez.NEXT(dez_i);
                                vEz:=ez_am.NEXT(vEz);
                          END LOOP; -- Цикл EZ
                         /*0*/ELSE
                                      NULL;
                                      --Raise_application_error(-20000, 'Что - ' || TO_CHAR(c.tv_ch)|| ' и Куда - ' || TO_CHAR(c.rn_tv));
                        /*0*/END IF;
                  /*farid*/--END IF;
            /*dstart*/--END IF;
            /*IF t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r.COUNT>0 THEN
            t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid) := tb_rint;
            END IF;*/
            --dbms_output.put_line('tb_rcount3=' || t(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS')) (p.farid).tb_r.COUNT);
            /*IF c.tv_ch IN (125109\*,380425*\) THEN
                          dbms_output.put_line( 'tb_rcount4=' || to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || p.farid || ' ' || c.urov  || ' '  || c.att_arstart || ' ' || c.att_arend);
            END IF;*/
           /*IF c.tv_ch IN (1563887\*,380425*\) THEN
              --dbms_output.put_line( 'tb_rcount4=' || p.dstart || ' ' || ba(ba.LAST).dstart || ' ' || ba(ba.LAST).farid || ' ' || ba(ba.LAST).dend);
              --dbms_output.put_line( 'tb_rcount5=' || t.COUNT);
              --p_show_debug(t);
              dbms_output.put_line( 'tb_rcount5=' || c.att_arstart||' '|| p.dstart || ' ' || p.farid);-- || ' ' || ba(ba.LAST).dstart || ' ' || ba(ba.LAST).farid || ba(ba.LAST).dend || ' ur=' || c.urov);
              dbms_output.put_line(trall.disp_ez(to_char(p.dstart,'DD.MM.YYYY HH24:MI:SS') || ' ' || to_char(p.farid) || ' ' || to_char(c.rn_ispob_ch) ));
              --p_show_debug(t);
           END IF;*/ 
                  --dbms_output.put_line('tb_rcount33=' || c.att_arstart || ' '||c.rn_ispob_ch || ' '|| nvl(c.tv_ch,-1) || ' ' ||c.ind || ' ' ||c.urov);
                  --p_show_debug(t);
                  oldkey:=key;
      /*SELECT COUNT(*) INTO r FROM v_res_dmotv t 
      WHERE t.rntv=490139 AND  ind_mo=0 AND t.pri IS NOT NULL AND t.farid=30513060;
      IF r>0 THEN
                    dbms_output.put_line('dstart=' ||c.dstart || ' dend='|| c.dend || ' pdstart=' || p.dstart || ' 1tv_k = ' ||c.rn_tv || ' tv_ch = ' ||c.tv_ch || ' isp_ch= ' || c.rn_ispob_ch || ' urov=' ||c.urov \*|| ' dstart=' || c.dstart || ' dend=' || c.dend || ' ind=' || c.ind*\  );
                    RETURN 1;
      END IF;*/
          /* IF c.tv_ch=125109 THEN
           SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv));
            dbms_output.put_line('кол-во интервалов=' || r);
           FOR itnv IN (SELECT att_arstart, farid FROM TABLE (cast(intv AS t_res_tb_intv)) ) LOOP
           dbms_output.put_line('Интервал= ' || to_char(itnv.att_arstart,'dd.mm.yyyy HH24:MI:SS') || ' '|| itnv.farid);
           END LOOP;
           dbms_output.put_line('1tv_k = ' ||c.rn_tv || ' tv_ch = ' ||c.tv_ch || ' isp_ch= ' || c.rn_ispob_ch || ' urov=' ||c.urov \*|| ' dstart=' || c.dstart || ' dend=' || c.dend || ' ind=' || c.ind*\  );
           dbms_output.put_line('конец интервалам');
SELECT COUNT(*) INTO r2 FROM
           (select dstart,farid,COUNT(*)  from 
                   tb_res_fap t
                   GROUP BY dstart,farid
           );               
               dbms_output.put_line('кол-во интервалов2=' || r2);
               FOR itnv IN (select dstart,farid,COUNT(*)  from 
                   tb_res_fap t
                   GROUP BY dstart,farid
                   ) LOOP
               dbms_output.put_line('Интервал2= ' || itnv.dstart || ' '|| itnv.farid);
               NULL;
               END LOOP;
               dbms_output.put_line('2tv_k = ' ||c.rn_tv || ' tv_ch = ' ||c.tv_ch || ' isp_ch= ' || c.rn_ispob_ch || ' urov=' ||c.urov || ' dstart=' || c.dstart || ' dend=' || c.dend || ' ind=' || c.ind  );
               dbms_output.put_line('конец интервалам2');
            END IF;*/
            
           END LOOP;/*p*/
           
     END IF;
     IF fl_forallo IS NOT NULL  THEN
        fl_forall_p:=TRUE;
     END IF;
           -- Генерируем записи
           IF nvl(trall.ba(trall.ba.LAST).ind_mo,0)<>0 THEN
              -- со второй записи начинаем размножать
              IF mo_int.rnum=1 THEN
                 trall.ba(trall.ba.LAST).dend:=mo_int.dend;
                 trall.ba(trall.ba.LAST).earid:=mo_int.earid;
              END IF;
              IF mo_int.rnum>1 THEN
                 trall.ba.EXTEND;
--                 ba(ba.LAST) := ba(ba.PRIOR(ba.LAST)) ;
                 --ba(ba.LAST).arid_k:=ba(ba.PRIOR(ba.LAST)).arid_k;
                 trall.ba(trall.ba.LAST):=t_res_elem3(trall.ba(trall.ba.PRIOR(trall.ba.LAST)).arid_k,
                      trall.ba(trall.ba.PRIOR(trall.ba.LAST)).att_arid,
                      trall.ba(trall.ba.PRIOR(trall.ba.LAST)).farid,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rnisp_k , --AS isp_k
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rntv_k , --AS tv_k
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rnisp_c , --AS isp_k
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rntv_c, --as tv_ch
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).kol,
--                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ak,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).urov,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).dstart,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).dend,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).earid,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rn_prich,
--                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).deltakol,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ardis,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).key,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).arid_zo,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind_new,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).att_auth1,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).golova,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind_dts,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ez,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind_mo,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).mo_states,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).mo_intv,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).flag);
                 trall.ba(trall.ba.LAST).rn_prich:=mo_int.att_auth;
                 trall.ba(trall.ba.LAST).dstart:=mo_int.dstart;
                 trall.ba(trall.ba.LAST).farid:=mo_int.farid;
                 trall.ba(trall.ba.LAST).dend:=mo_int.dend;
                 trall.ba(trall.ba.LAST).earid:=mo_int.earid;

               --Добавляем интервал - если его нету
               SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv)) WHERE att_arstart=mo_int.dstart AND farid=mo_int.farid;
                  IF r=0 THEN
                      intv.EXTEND;
                      intv(intv.LAST):=t_res_intv(mo_int.dstart, mo_int.farid);
                  END IF;
                 END IF;
              END IF;

           END LOOP; /*intv mo*/
   EXCEPTION
             WHEN OTHERS THEN
                  dbms_output.put_line('error golova='|| p_rntv||' tb_rcount3=' || c.att_arstart ||' isp_ch=' || c.rn_ispob_ch || ' tv_ch='|| nvl(c.tv_ch,-1) || ' ind=' ||c.ind || ' ur=' ||c.urov|| ' '|| SQLERRM);
                   /*trall.trall.ba:=trall.ba;
                  RETURN trall;*/
                  RETURN 1;
           END;
           /*if c.tv_ch=492085 then
              return 1;
           end if ;*/
           --dbms_output.put_line('tv_k = ' ||c.rn_tv || ' tv_ch = ' ||c.tv_ch || ' isp_ch= ' || c.rn_ispob_ch || ' urov=' ||c.urov || ' dstart=' || c.dstart || ' dend=' || c.dend || ' ind=' || c.ind  );

           /*IF c.tv_ch=139757 THEN
               --tmpFlag:=1;
               p_show_debug(trall.intv);
           END IF;*/
           --IF tmpFlag=1 THEN
              --p_show_debug(t);
           --END IF;
                    --cnt_rec:=cnt_rec+1;
           /*dbms_output.put_line('tv_ch = ' ||c.tv_ch);
           p_show_debug(t);*/           
           /*SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv));
           IF r<>oldr THEN
           dbms_output.put_line('кол-во интервалов=' || r);
           FOR itnv IN (SELECT att_arstart, farid FROM TABLE (cast(intv AS t_res_tb_intv)) ) LOOP
           dbms_output.put_line('Интервал= ' || to_char(itnv.att_arstart,'dd.mm.yyyy HH24:MI:SS') || ' '|| itnv.farid);
           END LOOP;
           dbms_output.put_line('1tv_k = ' ||c.rn_tv || ' tv_ch = ' ||c.tv_ch || ' isp_ch= ' || c.rn_ispob_ch || ' urov=' ||c.urov \*|| ' dstart=' || c.dstart || ' dend=' || c.dend || ' ind=' || c.ind*\  );
           dbms_output.put_line('конец интервалам');
           oldr:=r;
           END IF;*/
           /*SELECT COUNT(*) INTO r2 FROM
           (select dstart,farid,COUNT(*)  from 
                   tb_res_fap t
                   GROUP BY dstart,farid
           );
           IF r2<>oldr2 THEN
               dbms_output.put_line('кол-во интервалов2=' || r2);
               FOR itnv IN (select dstart,farid,COUNT(*)  from 
                   tb_res_fap t
                   GROUP BY dstart,farid
                   ) LOOP
               dbms_output.put_line('Интервал2= ' || itnv.dstart || ' '|| itnv.farid);
               NULL;
               END LOOP;
               dbms_output.put_line('2tv_k = ' ||c.rn_tv || ' tv_ch = ' ||c.tv_ch || ' isp_ch= ' || c.rn_ispob_ch || ' urov=' ||c.urov || ' dstart=' || c.dstart || ' dend=' || c.dend || ' ind=' || c.ind  );
               dbms_output.put_line('конец интервалам2');
               oldr2:=r2;
           END IF;*/
/*           IF cnt_rec>10 THEN
              RETURN 1;
           END IF;
*/

/*      IF c.tv_ch=125109 AND c. urov=6 THEN
         RETURN 1;
      END IF;*/
     /* FOR iut IN trall.ddstart.FIRST..trall.ddstart.LAST LOOP
          dbms_output.put_line('123=' || trall.ddstart(iut).rn  );
      END LOOP;
      FOR iut IN trall.dfarid.FIRST.. trall.dfarid.LAST LOOP
          dbms_output.put_line('555=' || trall.dfarid(iut).rn );
          dbms_output.put_line('555=' || trall.dfarid(iut).dstart_fk );
          dbms_output.put_line('555=' || trall.dfarid(iut).farid );
      END LOOP;*/
<<next_state>>

NULL;
END LOOP;
         IF num = trall.ba.COUNT THEN
            EXIT;
         END IF;
         num := trall.ba.COUNT;
         x   := x + 1;
         --IF x>1 THEN EXIT;   END IF;
         --dbms_output.put_line('Urov= ' || x);

           --  dbms_output.put_line(k.dstart || ' ' || k.dend || ' ' || k.farid || ' ' || k.earid || ' ' || k.rn_prich || ' ' || k.rntv_c || ' ' || k.rnisp_c);

         --END LOOP;
       /*IF trall.ba.COUNT>0 THEN
      FOR k12 IN trall.ba.FIRST .. trall.ba.LAST LOOP
          IF trall.ba(k12).urov=x-1 THEN
                trall.ba.DELETE(k12);
             END IF;
          NULL;
      END LOOP;
      END IF;*/

commit;
      END LOOP;
      --trall.trall.ba:=trall.ba;
--      trall.intv:=t;
      --p_show_debug(trall.intv);
      dbms_output.put_line(cntI || ' - ' || cntI2 || ' - ' || cntI3 || ' - ' || cntI4 || ' - ' || cntI5);
      RETURN 1;--trall;
    END;

    FUNCTION F_RES_K_INL2(
                        trall IN OUT NOCOPY t_rec_all,
                        p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL,
                        p_part IN NUMBER DEFAULT 1
                        ) RETURN INTEGER --t_rec_all
      IS
      --trall t_rec_all;
  -- Установка
      TYPE ustnumbers IS  RECORD(
           key PLS_INTEGER,
           rn_tv NUMBER,
           isp_chto NUMBER,
           tv_chto NUMBER, -- Если есть ТВ у исп объекта - то делим на два разных объекта
           rn_pozmo NUMBER
     );
  -- Образец
      TYPE obrnumbers IS  RECORD(
           key PLS_INTEGER,
           tv_izg  NUMBER, -- С кем совм. изготовляется
           tv_obr NUMBER, -- Образец
           arid_mo NUMBER -- Кого защищает
     );
     --Заготовка
      TYPE zagnumbers IS  RECORD(
           key PLS_INTEGER,
           rn_tv  NUMBER -- Кто имеет заготовку
     );
      --ba  t_res_nl3;
      x   PLS_INTEGER := 1; -- Текущий уровень
      num PLS_INTEGER := 0; -- Кол-во записей в коллекции
      key PLS_INTEGER:=1; -- текущий вставляемый key
      oldkey PLS_INTEGER; -- предыдущий key
      dce_chto_key ustnumbers;   -- Текущий  key, ДСЕ-что и rnpozmo
      dce_chto_key_obr obrnumbers;   -- Текущий key,
      dce_chto_key_zag zagnumbers;   -- Текущий key,
      r PLS_INTEGER; -- Для прохода по циклу изменений в ветке
      --izm_cnt PLS_INTEGER; -- Кол-во изменений пройденных в ветке
      --strsql CLOB; -- Текст запроса который выполняется

--      t tb_int_dstart;
      --kol3 NUMBER; -- Временная для расчета кол-ва
      --uf NUMBER; -- Полная применяемость ДСЕ куда
      intv t_res_tb_intv;
      --cnt_intv_v PLS_INTEGER; -- Временная для прохождения по интервалам
      --tb_rint rec_int_farid;
     -- tb_kol rec_ez;
       tb_td  pk_tresult3.tb_td;
      m NUMBER; -- Временная для прохождения по техдобавкам
      n NUMBER;
      fl_relink boolean:=false;
      fl_first_record integer:=1; -- Обрабатываем уровень 0
      --cnt_rec INTEGER:=0; --Счетчик отработанных записей
      fromstart DATE; -- Откуда копируем
      fromfarid NUMBER;--Откуда копируем
--      nmo t_node_mo;
      n_ez NUMBER;
      --tmpFlag INTEGER:=0;
      izdPornom NUMBER;
      izdPozmo NUMBER;
--
      vRN_Pozmo       PLS_INTEGER; -- Позиция для которой счатаем из- за заготовки
      vFaridNext NUMBER; -- Farid следующего за текущим состояния
      vDstart DATE;
      vFarid NUMBER;
      vInd_new CHAR(1);
      vRn_Prich NUMBER;
      cycrn_ispob_ch number;
      cycez NUMBER;
      cycrn_pozmo NUMBER;
      tmpEarid number;
      tmpmo_states t_node_mo;
      tmpmo_intv t_node_mo;
      --iExists PLS_INTEGER;
      --iExists2 PLS_INTEGER;
      --vAp NUMBER;
      oldcntint  PLS_INTEGER:=0;
      cntINT PLS_INTEGER;
   BEGIN
      trall.ba := t_res_nl3();
      intv:= t_res_tb_intv();

      --Добавляем один элемент
      INTv.EXTEND;
      intv(INTv.LAST) := t_res_intv(p_start,-1);
      --trall.intv(to_char(p_start,'DD.MM.YYYY HH24:MI:SS'))(-1).ind:=null;
      FOR c IN (SELECT a.rn_ispob,
                       a.rn AS rn_c,
                       -1 AS rn_kuda,
                       1.0 AS kol,
                       1.0 AS ak,
                       1.0 AS oldkol,
                       x AS urov
                  FROM w_ktsg.v_tv a
                 INNER JOIN w_ktsg.v_tv_s_wa tvs ON a.rn = tvs.rn_tv
                 INNER JOIN w_ktsg.v_audi aa ON aa.ATT_ARID = tvs.ATT_ARID
                                            AND aa.ATT_ARVER = 0
                                            AND aa.ATT_VAR = 0
                 WHERE w_ktsg.pk_VALUES.CURDATE < aa.att_arend
                   AND w_ktsg.pk_VALUES.CURDATE >= aa.att_arstart
                   AND a.rn = p_rntv) LOOP
         trall.ba.EXTEND;
         trall.ba(trall.ba.LAST) :=
          t_res_elem3(-1,
                      -1,
                      -1,
                                   c.rn_ispob , --AS isp_k
                                   c.rn_c , --AS tv_k
                                   c.rn_ispob , --AS isp_ch
                                   c.rn_c, --as tv_ch
                                   c.kol,
                                   --c.ak,
                                   c.urov,
                                   nvl(p_start, to_date('1.01.2007','DD.MM.YYYY')),
                                   nvl(p_end, to_date('1.10.2008','DD.MM.YYYY')),
                                   999999999999999999999999999, --earid
                                   NULL,
                                   -1,
                                   --NULL, --deltakol
                                   NULL,
                                   1,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   w_mmk_raskomp.f_ei_flag(52));

               dce_chto_key.rn_tv:=1;
               dce_chto_key.key:=1;
               dce_chto_key.isp_chto:=c.rn_ispob;
               dce_chto_key.rn_pozmo:=1;
               dce_chto_key.tv_chto:=null;

               dce_chto_key_obr.key:=1;
               dce_chto_key_obr.tv_obr:=1;
               dce_chto_key_obr.arid_mo:=1;
               dce_chto_key_obr.tv_izg:=1;

               dce_chto_key_zag.key:=1;
               dce_chto_key_zag.rn_tv:=1;
      END LOOP;


      --***********************************************************************
      LOOP
     -- IF x>2 THEN EXIT;   END IF;
     BEGIN
      select
       min(l.pornom) into izdPornom
      from
       w_ktsg.tb_poz_mo l
      where l.rn_tv=p_rntv and l.pornom>0;

     select
      s.rn_pozmo into
      izdPozmo
     from
      w_ktsg.tb_poz_mo_s s,
      w_ktsg.tb_audi a,
      w_ktsg.tb_poz_mo mo
     where
      mo.rn=s.rn_pozmo and mo.pornom=izdPornom and
      s.rn_tv=p_rntv and s.att_arid=a.att_arid and
      s.objtype=a.att_objtype and p_Start<a.att_arend and
      p_Start>=a.att_arstart and a.att_arver=0 and a.att_var=0;
      EXCEPTION
               WHEN no_DATA_FOUND THEN
               izdPornom:=null;
               izdPozmo:=null;
      END;
         FOR c IN (
         select
         0 as base,
         d.dstart,
         d.dend,
         --d.oldkol,
         --d.ak,
         d.rn_prich,
         d.ardis,
         d.farid,
         d.earid,
         d.rnisp_C as rnisp_k,
         d.key,
         d.ind_new,
         d.rnISP_c AS rn_ispob,
         d.rnisp_C AS rn_ispob_ch,
         p_rntv AS rn_tv,
         p_rntv AS tv_ch,
         1 AS TV_IZG,
         1 AS kol_o,
         sysdate as ATT_ARSTART,
         sysdate AS att_arend,
         1 as att_auth,
         '1' as att_ardis,
         1 AS att_arver,
         izdPozmo AS rn_pozmo,
         '0' AS ind,
         1 AS att_arid,
         1 AS arid_zo,
         null as ATT_PREVARID,
         52 AS ez,
         w_mmk_raskomp.f_ei_flag(52) as flag,
         d.att_arid as arid_k,
         1 AS kol,
         --d.izms as izms,
         1 as ran,
         1 as urov
          FROM TABLE(CAST(trall.ba AS t_res_nl3)) d
          WHERE fl_first_record =1
          union all(
         SELECT ---full(d)
         1 as base,b.*, (x + 1) AS urov
                     FROM (--- leading(d) use_nl(d s) use_nl(s a) use_nl(s C) use_nl(ksp d)
                           SELECT --+ first_rows leading(d)
                             d.dstart
                             ,d.dend,
                             --d.oldkol,
                             --d.ak*decode (ksp.ind,1,ksp.kol_o,0) * nvl2(ksp.att_ardis,0,1) AS ak,
                             d.rn_prich,
                             d.ardis,
                             d.farid,
                             d.earid,
                             d.rnisp_c AS rnisp_k,
                             d.key,
                             d.ind_new,
                             ksp.*,
--                             ,ksp.kol_o * d.kol /**tvs.DOLY*//* AS kol,
                             d.att_arid as arid_k,
                             ksp.kol_o AS kol,
                             --d.izms,
                             rank() over (PARTITION BY d.key,ksp.tv_ch ORDER BY ksp.att_arid) AS ran
                             FROM TABLE(CAST(trall.ba AS t_res_nl3)) d
                             JOIN
                             (
                             SELECT --+ leading(tv) use_nl(tv s a tvc)  index(tv AK1_TV)
                             -- УСТАНОВКА КОМПОНЕНТ
                                    tv.rn_ispob, -- Исп куда
                                    s.rn_ispob_ch, -- Исп что
                                    s.rn_tv, -- ТВ куда
                                    nvl(tvc.RN,1) AS TV_CH, -- ТВ что NULL введен из за дублирования записей при двух технологических вариантах
                                    NULL AS TV_IZG, -- С кем совместно изготавливается
                                    s.kol /**tvs.DOLY*/ AS kol_o,
                                    a.ATT_ARSTART,
                                    a.att_arend,
                                    a.att_auth,
                                    a.att_ardis,
                                    att_arver,
                                    rn_pozmo,
                                    '1' AS ind,
                                    a.att_arid,
                                    NULL AS arid_zo, --арид кого защищает образец
                                    a.ATT_PREVARID,
                                    s.rn_ei_ust AS ez,
                                    w_mmk_raskomp.f_ei_flag(rn_ei_ust) as flag
                             from
                              w_ktsg.v_tv tv
                             JOIN w_ktsg.tb_ust_comp_s s ON tv.rn = s.rn_tv
                             JOIN w_ktsg.v_audi a ON
                                                 s.att_arid = a.att_arid
                                                 AND a.ATT_VAR = 0
                                                 AND a.att_arver =0-- NVL2(a.att_ardis, 1, 0)
                              LEFT JOIN w_ktsg.v_tv tvc ON s.rn_ispob_ch=tvc.RN_ISPOB
                              --JOIN tb_auth_farid fa ON a.att_auth=fa.att_auth
                             UNION ALL -- ОБРАЗЕЦ
                             SELECT --+leading(tv) use_nl(o a t tv) index(tv AK1_TV) star
                             tv.rn_ispob,-- Исп куда - защ объект
                             w_mmkt.f_get_rn_ispob(o.rn_tv_obr), -- Исп что - образец
                             t.rn_tv, -- ТВ куда - защ объекта
                             o.rn_tv_obr, -- ТВ что - образец
                             o.rn_tv_izg,
                             1 as kol,
                             a.att_arstart,
                             a.att_arend,
                             a.att_auth,
                             a.att_ardis,
                             a.att_arver,
                             t.rn_pozmo,
                             '3' as ind,
                             a.att_arid,
                             o.arid_pozmo AS arid_zo, --арид кого защищает образец
                             a.ATT_PREVARID,
                             52 AS ez,
                             w_mmk_raskomp.f_ei_flag(52) as flag
                             FROM
                                    w_ktsg.tb_obr_s o
                                    JOIN w_ktsg.v_audi a on
                                         o.att_arid=a.ATT_ARID and
                                         o.objtype=a.ATT_OBJTYPE and
                                         a.att_var=0 and  a.att_arver =0-- NVL2(a.att_ardis, 1, 0)
                                    JOIN w_ktsg.tb_poz_mo_s t on t.att_arid=o.arid_pozmo
                                    JOIN w_ktsg.v_tv  tv on t.rn_Tv=tv.rn
                                    --JOIN tb_auth_farid fa ON a.att_auth=fa.att_auth
                           UNION ALL -- ЗАГОТОВКА
                           SELECT--+leading(tvz) use_nl(tz tvz az tvcz) index(tvz AK1_TV) star
                                 tvz.RN_ISPOB AS rn_ispob, -- Исп куда
                                 tz.rn_ispob_zag AS rn_ispob_ch,-- Исп что
                                 tz.rn_tv AS rn_tv,-- ТВ куда
/*                                 CASE WHEN f_res_cex_pol_mat(tz.rn_tv,az.ATT_ARSTART,f_get_first_arid(az.att_auth)) IS NOT NULL THEN
                                 (SELECT rn_tv FROM w_ktsg.tb_poz_mo m WHERE m.rn=f_res_cex_pol_mat(tz.rn_tv,az.ATT_ARSTART,f_get_first_arid(az.att_auth)) )
                                 ELSE
                                     NULL
                                 END*/
                                 nvl(tvcz.rn,1) AS tv_ch,-- ТВ что
                                 NULL AS TV_IZG, -- С кем совместно изготавливается  - только для образцов
                                 tz.normrash /**tvs.DOLY*/ AS kol_o,
                                 az.ATT_ARSTART,
                                 az.att_arend,
                                 az.att_auth,
                                 az.att_ardis,
                                 az.att_arver,
                                 f_res_cex_pol_mat(tz.rn_tv,az.ATT_ARSTART,f_get_first_arid(az.att_auth)) AS rn_pozmo,
                                 '2' AS ind, -- Заготовка
                                 az.att_arid,
                                 NULL AS arid_zo, --арид кого защищает образец
                                 az.ATT_PREVARID,
                                 tz.rn_ei AS ez,
                                 w_mmk_raskomp.f_ei_flag(rn_ei) as flag
                           FROM
                               w_ktsg.tb_t_zag_s tz
                               JOIN w_ktsg.v_tv tvz ON tz.rn_tv=tvz.RN
                               JOIN w_ktsg.v_audi az ON
                                                            tz.att_arid=az.ATT_ARID AND
                                                            tz.objtype=az.ATT_OBJTYPE AND
                                                            az.ATT_VAR=0 AND az.att_arver=0--nvl2(az.ATT_ARDIS, 1, 0)
                               LEFT JOIN w_ktsg.v_tv tvcz ON tz.rn_ispob_zag=tvcz.RN_ISPOB
                                --JOIN tb_auth_farid fa ON az.att_auth=fa.att_auth
                                                 ) ksp ON
                                                       D.rnisp_c = ksp.rn_ispob
                                                       AND nvl(d.rntv_c,-15)=nvl(ksp.rn_tv,-15)
                                                       AND d.urov = x
                                                       AND (
                                                           (d.dstart < ksp.att_arend AND -- Дата конца состояний для раскомплектовки до изменений должна быть внутри интервала
                                                            d.dend >= ksp.att_arend AND
                                                            rn_prich = -1)
                                                          OR
                                                           -- Завершение
                                                           (
                                                             (   d.dstart < ksp.att_arend
                                                                        OR -- дата завершения действия должна быть внутри интервала
                                                              (d.dstart = ksp.att_arend
                                                              -- Чтоб при изменениях с одной даты попадали состояния идущие по состоянию своих изменений после верхнего
                                                              AND
                                                              w_mmkt.pk_tresult2.f_get_first_arid_for_end(ksp.att_arid)-d.farid >0--= 0
                                                              AND rn_prich<>-1
                                                              )
                                                           )
                                                               AND
                                                             (   d.dend > ksp.att_arend
                                                                 OR
                                                                 (
                                                                 d.dend=ksp.att_arend
                                                                  AND
                                                                  w_mmkt.pk_tresult2.f_get_first_arid_for_end(ksp.att_arid)-d.farid < 0
                                                                 )
                                                            )
                                                            )
                                                          OR
                                                          -- Начало
                                                           (
                                                              (d.dstart < ksp.att_arstart ----- дата начала действия должна быть внутри интервала
                                                                        OR
                                                                 (d.dstart = ksp.att_arstart
                                                                  AND
                                                                   f_get_first_arid(ksp.att_auth)-d.farid >= 0
                                                                )
                                                              )
                                                              AND
                                                            (d.dend > ksp.att_arstart
                                                                   OR
                                                              (
                                                                     --d.dstart=ksp.att_arstart  07.07.2008
                                                                     d.dend=ksp.att_arstart
                                                                 AND
                                                                     --fa.farid-d.farid<0
                                                                     --f_get_first_arid(ksp.att_auth)-d.farid<0 07.07.2008
                                                                     f_get_first_arid(ksp.att_auth)-d.earid<0
                                                                 --AND d.rn_prich<>-1
                                                              )
                                                            )
                                                           )
                                                          OR -- Учитываем изменения конца интервала - если дата начала состояния равна дате конца интервала и
                                                              -- дате конца заданного к расчету периода - то берем ее
                                                           (p_end=d.dend AND
                                                            ksp.att_arstart=p_end
                                                           )
                                                          OR
                                                            (
                                                            (d.dstart > -- То что действует на всем интервале и не аннулировано
                                                            ksp.att_arstart
                                                            OR (
                                                            d.dstart=ksp.att_arstart
                                                                                    AND
                                                                pk_tresult3.f_get_first_arid(ksp.att_auth)-d.farid <= 0
                                                            )
                                                            )
                                                             AND
                                                             (d.dend < ksp.att_arend
                                                                    OR (
                                                                    d.dend=ksp.att_arend
                                                                    AND
                                                                    pk_tresult3.f_get_first_arid_for_end(ksp.att_arid)-d.earid >=0
                                                                    )
                                                            ) AND
                                                            ksp.att_ardis IS NULL
                                                            )
                                                       )
                                              ) b
                                              )

                    ORDER BY base,key, ind,rn_ispob_ch, tv_ch, rn_tv, tv_izg, rn_pozmo, arid_zo, att_arstart--,ind
                    ) LOOP
                    BEGIN
     IF fl_first_record=0 THEN
                    --w_otk.p_load_log('att_arid=' || c.att_arid || ' rn_Tv=' || c.rn_tv || ' rn_isp= ' || c.rn_ispob_ch || ' ind=' || c.ind,9);
                    IF c.ind=2 AND  c.rn_ispob_ch=F_Get_rn_ispOb(c.rn_tv)  THEN -- Исключение зацикливания по заготовке
                          NULL;
                          GOTO next_state;
                    ELSE

            -- Размножение интервалов - чтоб по дате окончания размножались при удаленном следующем состоянии
            -- Получить арид следующего состояния - чтоб определить его farid
            IF c.att_arend<=p_end THEN
                 vFaridNext:=w_common.pk_audi.GetNextActual(c.att_arid,'1');
                 IF vFaridNext<>-1 THEN
                  --Проверить - является ли след. состояние аннулированием
                 SELECT COUNT(*) INTO r FROM tb_audi a WHERE a.att_arid=vFaridNext AND a.att_ardis IS NOT NULL;
                 SELECT f_get_first_arid(att_auth) INTO vFaridNext FROM tb_audi WHERE att_arid=vFaridNext;
                 IF r=1 THEN
                    SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv)) WHERE att_arstart=c.att_arend AND farid=vFaridNext;
                       IF r=0 THEN --Нет такого интервала - создаем
                          intv.EXTEND;
                          intv(intv.LAST):=t_res_intv(c.att_arend, vFaridNext);
                          -- Копируем все что было в ближайшем кверху интервале в данный
                          -- Скопировать из верхнего интервала все в этот интервал
                          -- копируем из минимального который меньше данного
                               SELECT att_arstart,farid
                               INTO fromstart, fromfarid
                                FROM (
                              SELECT att_arstart, farid
                               FROM TABLE (cast(intv AS t_res_tb_intv))
                              WHERE att_arstart<c.att_arend OR (att_arstart=c.att_arend AND farid<vFaridNext)
                              ORDER BY att_arstart DESC, farid DESC)
                              WHERE rownum<2;
                               /*IF trall.intv.exists(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS')) then
                      \*farid*\IF trall.intv(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS')).EXISTS(fromfarid) THEN
                                  FOR g1 IN (SELECT t.dstart,t.farid,t.rn_isp,t.n,t.v,t.ez,t.ind_mo,t.key_mo,t.rn AS rnfrom
                                       FROM tb_res_fap t
                                       WHERE t.dstart=to_char(fromstart\*c.dstart*\,'DD.MM.YYYY HH24:MI:SS') AND t.farid=fromfarid
                                       ) LOOP
                                         \*SELECT seq_res.NEXTVAL INTO iExists FROM dual;
                                       INSERT INTO tb_res_fap
                                         (dstart, farid, rn_isp, n, v, ez, ind_mo, key_mo, rn)
                                       VALUES
                                         (to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'), vFaridNext, g1.rn_isp, g1.n, g1.v, g1.ez, g1.ind_mo, g1.key_mo, iExists);
                                         -- Копируем ТВ
                                                FOR g2 IN (SELECT t.rntv,t.uf,t.ap FROM tb_res_dtv t WHERE t.rnmo_fk=g1.rnfrom) LOOP
                                                SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                                    INSERT INTO tb_res_dtv
                                                      (rnmo_fk, rn, rntv, uf,ap)
                                                    VALUES
                                                      (iExists, iExists2, g2.rntv, g2.uf,g2.ap);
                                                END LOOP;
                                         END LOOP;*\
                                       trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'))(vFaridNext):=trall.intv(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS'))(fromfarid);

                                       --Удаление собственных позиций
                                       \*m:=trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v.FIRST;
                                       WHILE m IS NOT NULL LOOP
                                             IF trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v(m).ind=0 THEN
                                             trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v.DELETE(m);
                                       END IF;
                                       m:=trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v.next(m);*\
                                       END LOOP;
                                   ELSE
                                     trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'))(vFaridNext).ind:=null;
                                   END IF;
                               ELSE-- Еще вообще ничего нет
                                 trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'))(vFaridNext).ind:=null;
                               END IF;*/
                       END IF;
                    END IF; -- r=1
               END IF;-- vFaridNext<>-1
            END IF;

            IF c.att_arstart > c.dstart OR (c.att_arstart = c.dstart AND f_get_first_arid(c.att_auth)>c.farid AND c.rn_prich<>-1) OR (c.rn_prich=c.att_auth AND c.att_arstart=p_start AND c.att_arstart=c.dstart) THEN --Встретили изменение
               IF f_get_prev_actual2(c.att_arid,'1') = -1 THEN
                  -- Предыдущего состояния не было - это новое
                  vInd_new:='1';
               END IF;
               -- Началось  внутри интервала
               vRn_prich := c.att_auth;
               vDstart := c.att_arstart;
               vFarid  := f_get_first_arid(c.att_auth);
               --Добавляем интервал - если его нету
               SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv)) WHERE att_arstart=c.att_arstart AND farid=vfarid;
               IF r=0 THEN
                  intv.EXTEND;
                  intv(intv.LAST):=t_res_intv(c.att_arstart, vFarid);
               END IF;
            ELSE
               -- Началось вне(до) интервала
               vRn_prich := c.rn_prich;
               vDstart := c.dstart;
               vFarid :=c.farid;
               -- Изменение - состояние начало действовать до интервала
            END IF;

            IF c.ind=1 AND f_is_mo_actual( vDstart, vFarid,c.rn_pozmo,p_start)=-1 THEN
                               -- Позиция неактуальна
                               GOTO next_state;
            ELSIF c.ind=3 AND F_is_arid_actual(vDstart,vFarid,c.arid_zo,p_start)=-1 THEN
                               -- Позиция неактуальна
                               GOTO next_state;
            END IF;

            --Цикл
            trall.ba.EXTEND;
            trall.ba(trall.ba.LAST) := t_res_elem3(
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       null);
            trall.ba(trall.ba.LAST).arid_k:=c.arid_k;
            trall.ba(trall.ba.LAST).att_arid := c.att_arid;
            trall.ba(trall.ba.LAST).rntv_k := c.rn_tv; --rn_tvk;
            trall.ba(trall.ba.LAST).rntv_c := c.tv_ch;
            trall.ba(trall.ba.LAST).rnisp_c := c.rn_ispob_ch;
            trall.ba(trall.ba.LAST).rnisp_k := c.rnisp_k;
            trall.ba(trall.ba.LAST).urov := c.urov;
            trall.ba(trall.ba.LAST).ind := c.ind;
            trall.ba(trall.ba.LAST).arid_zo:=c.arid_zo;
            trall.ba(trall.ba.LAST).att_auth1:=c.att_auth;
            trall.ba(trall.ba.LAST).ez:=c.ez;
            trall.ba(trall.ba.LAST).flag:=c.flag;
            -- Простановка key
            IF c.ind='1' THEN
            -- Установка
            IF dce_chto_key.key<>c.key OR dce_chto_key.isp_chto<>c.rn_ispob_ch OR dce_chto_key.rn_pozmo<>c.rn_pozmo  OR nvl(dce_chto_key.tv_chto,-15)<>nvl(c.tv_ch,-15) THEN
                        key:=key+1;
                        dce_chto_key.key:=c.key;
                        dce_chto_key.rn_tv:=c.rn_tv;
                        dce_chto_key.isp_chto:= c.rn_ispob_ch;
                        dce_chto_key.rn_pozmo:= c.rn_pozmo;
                        dce_chto_key.tv_chto:=c.tv_ch;
            END IF;
            ELSIF c.ind=3 THEN
            -- Образец
            IF dce_chto_key_obr.key<>c.key OR dce_chto_key_obr.tv_obr<>c.tv_ch OR dce_chto_key_obr.arid_mo<>c.arid_zo OR dce_chto_key_obr.tv_izg<>c.TV_IZG THEN
                         key:=key+1;
                        dce_chto_key_obr.key:=c.key;
                        dce_chto_key_obr.tv_obr:= c.TV_CH;
                        dce_chto_key_obr.arid_mo := c.arid_zo;
                        dce_chto_key_obr.tv_izg := c.tv_izg;
            END IF;
            ELSIF c.ind=2 THEN
            -- Заготовка
               IF dce_chto_key_zag.key<>c.key OR dce_chto_key_zag.rn_tv<>c.rn_tv THEN
                         key:=key+1;
                        dce_chto_key_zag.key:=c.key;
                        dce_chto_key_zag.rn_tv:= c.RN_TV;
               END IF;
            END IF;
            trall.ba(trall.ba.LAST).key:=key;

            trall.ba(trall.ba.LAST).ind_new:=vInd_new;
               trall.ba(trall.ba.LAST).rn_prich:=vRN_Prich;
               trall.ba(trall.ba.LAST).dstart:=vDstart;
               trall.ba(trall.ba.LAST).farid:=vFarid;

            -- Если вверху ввелось с 0 - то чтоб введенные внизу также считались введенными с 0 - протягивание введения вниз
--            IF c.rn_tv =177819 THEN
--               DBMS_output.put_line(c.tv_ch || ' ' || c.ran);
--            END IF;
            IF c.ind_new IS NOT NULL AND c.ran=1 THEN
               --DBMS_output.put_line('->' || c.tv_ch || ' ' || c.ran);
               IF nvl(trall.ba(trall.ba.LAST).ind_new,'0') <>'1' THEN
                  trall.ba(trall.ba.LAST).ind_new:='2';
               END IF;
            END IF;
            tmpEArid:=f_get_first_arid_for_end(c.att_arid);
            IF c.att_arend > c.dend OR (c.att_arend =c.dend AND tmpEarid>c.earid) THEN
               --Состояние закончилось вне(после) интервала
               trall.ba(trall.ba.LAST).dend := c.dend;
               trall.ba(trall.ba.LAST).earid := c.Earid;
            ELSE
              --Состояние закончилось до интервала
               trall.ba(trall.ba.LAST).dend := c.att_arend;
               trall.ba(trall.ba.LAST).earid := tmpEarid;
            END IF;


            IF c.ardis IS NOT NULL THEN
                    trall.ba(trall.ba.LAST).ardis:=to_char(to_number(c.ardis) + to_number(nvl(c.att_ardis,0)));
            ELSE
                        trall.ba(trall.ba.LAST).ardis:=c.att_ardis;
            END IF;

            trall.ba(trall.ba.LAST).kol := c.kol;
--            ba(ba.LAST).ak := c.ak;
            trall.ba(trall.ba.LAST).golova := p_rntv;
            --С той же даты другое изменение
            IF c.att_arstart = c.dstart AND c.rn_prich <> c.att_auth AND c.rn_prich <> -1 THEN
               --Если разные изменения - то
               IF f_get_first_arid(c.rn_prich)<f_get_first_arid(c.att_auth) THEN
                  -- Верхнее раньше нижнего
                  -- Встречалось ли оно раньше
                  trall.ba(trall.ba.LAST).ind_dts := '1';
               ELSE
                  -- Нижнее раньше верхнего
                   trall.ba(trall.ba.LAST).ind_dts := '2';
               END IF;
            ELSE
               trall.ba(trall.ba.LAST).ind_dts := '0';
            END IF;
            --PIPE ROW(ba(ba.LAST));
            END IF;
           END IF;--fl_first_record
           -- Проверка существования более двух интервалов в маршруте ТВ_что
           --ba(ba.LAST).mo_states := t_node_mo();
           tmpmo_states:= t_node_mo();
           tmpmo_states.DELETE;
           tmpmo_intv:= t_node_mo();
           tmpmo_intv.DELETE;
           --ba(ba.LAST).mo_intv := t_node_mo();
           P_GET_MO_INTERVALS(p_start,c.tv_ch, trall.ba(trall.ba.LAST).dstart, trall.ba(trall.ba.LAST).farid, trall.ba(trall.ba.LAST).dend, trall.ba(trall.ba.LAST).earid, trall.ba(trall.ba.LAST).rn_prich, trall.ba(trall.ba.LAST).ind_mo,tmpmo_states,/*ba(ba.LAST).mo_intv*/tmpmo_intv);

           FOR mo_int IN ( -- Размножение интервалов при изменении маршрута
                          SELECT dstart,dend,farid,earid,att_auth,rownum AS rnum FROM (
           SELECT trall.ba(trall.ba.LAST).dstart AS dstart,trall.ba(trall.ba.LAST).dend AS dend, trall.ba(trall.ba.LAST).farid AS farid , trall.ba(trall.ba.LAST).earid AS earid, trall.ba(trall.ba.LAST).rn_prich AS att_auth FROM dual
           WHERE nvl(trall.ba(trall.ba.LAST).ind_mo,0)=0
           UNION
           SELECT att_arstart,att_arend,
           CASE WHEN att_arstart=p_start THEN -1 ELSE
           farid END AS farid,
           earid,
           att_auth FROM TABLE (CAST (/*ba(ba.LAST).*/tmpmo_intv  AS t_node_mo))
           WHERE trall.ba(trall.ba.LAST).ind_mo>0)
           ) LOOP
           fl_first_record:=0;
           -- Генерируем записи
           IF nvl(trall.ba(trall.ba.LAST).ind_mo,0)<>0 THEN
              -- со второй записи начинаем размножать
              IF mo_int.rnum=1 THEN
                 trall.ba(trall.ba.LAST).dend:=mo_int.dend;
                 trall.ba(trall.ba.LAST).earid:=mo_int.earid;
              END IF;
              IF mo_int.rnum>1 THEN
                 trall.ba.EXTEND;
--                 ba(ba.LAST) := ba(ba.PRIOR(ba.LAST)) ;
                 --ba(ba.LAST).arid_k:=ba(ba.PRIOR(ba.LAST)).arid_k;
                 trall.ba(trall.ba.LAST):=t_res_elem3(trall.ba(trall.ba.PRIOR(trall.ba.LAST)).arid_k,
                      trall.ba(trall.ba.PRIOR(trall.ba.LAST)).att_arid,
                      trall.ba(trall.ba.PRIOR(trall.ba.LAST)).farid,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rnisp_k , --AS isp_k
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rntv_k , --AS tv_k
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rnisp_c , --AS isp_k
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rntv_c, --as tv_ch
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).kol,
--                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ak,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).urov,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).dstart,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).dend,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).earid,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rn_prich,
--                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).deltakol,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ardis,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).key,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).arid_zo,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind_new,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).att_auth1,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).golova,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind_dts,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ez,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind_mo,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).mo_states,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).mo_intv,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).flag);
                 trall.ba(trall.ba.LAST).rn_prich:=mo_int.att_auth;
                 trall.ba(trall.ba.LAST).dstart:=mo_int.dstart;
                 trall.ba(trall.ba.LAST).farid:=mo_int.farid;
                 trall.ba(trall.ba.LAST).dend:=mo_int.dend;
                 trall.ba(trall.ba.LAST).earid:=mo_int.earid;

               --Добавляем интервал - если его нету
               SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv)) WHERE att_arstart=mo_int.dstart AND farid=mo_int.farid;
                  IF r=0 THEN
                      intv.EXTEND;
                      intv(intv.LAST):=t_res_intv(mo_int.dstart, mo_int.farid);
                  END IF;
                 END IF;
              END IF;

           END LOOP; /*intv mo*/
   EXCEPTION
             WHEN OTHERS THEN
                  dbms_output.put_line('error golova='|| p_rntv||' tb_rcount3=' || c.att_arstart ||' isp_ch=' || c.rn_ispob_ch || ' tv_ch='|| nvl(c.tv_ch,-1) || ' ind=' ||c.ind || ' ur=' ||c.urov|| ' '|| SQLERRM);
                   /*trall.trall.ba:=trall.ba;
                  RETURN trall;*/
           END;
           --dbms_output.put_line('tv_k = ' ||c.rn_tv || ' tv_ch = ' ||c.tv_ch || ' isp_ch= ' || c.rn_ispob_ch || ' urov=' ||c.urov || ' dstart=' || c.dstart || ' dend=' || c.dend || ' ind=' || c.ind  );

           /*IF c.tv_ch=139757 THEN
               --tmpFlag:=1;
               p_show_debug(trall.intv);
           END IF;*/
           --IF tmpFlag=1 THEN
              --p_show_debug(t);
           --END IF;
                    --cnt_rec:=cnt_rec+1;
           /*dbms_output.put_line('tv_ch = ' ||c.tv_ch);
           p_show_debug(t);*/
           /*SELECT COUNT(*) INTO  cntint FROM TABLE (cast(intv AS t_res_tb_intv));
           IF cntint<>oldcntint THEN
                 dbms_output.put_line('кол-во интервалов=' || cntint || ' urov=' || c.urov);
                 \*FOR itnv IN (SELECT att_arstart, farid FROM TABLE (cast(intv AS t_res_tb_intv)) ) LOOP
                 dbms_output.put_line('Интервал= ' || itnv.att_arstart || ' '|| itnv.farid);
                 END LOOP;*\
                 oldcntint:=cntint;
           END IF;*/
/*           IF cnt_rec>10 THEN
              RETURN 1;
           END IF;
*/
<<next_state>>
NULL;
END LOOP;
         IF num = trall.ba.COUNT THEN
            EXIT;
         END IF;
         num := trall.ba.COUNT;
         x   := x + 1;
         --IF x>1 THEN EXIT;   END IF;
         --dbms_output.put_line('Urov= ' || x);

           --  dbms_output.put_line(k.dstart || ' ' || k.dend || ' ' || k.farid || ' ' || k.earid || ' ' || k.rn_prich || ' ' || k.rntv_c || ' ' || k.rnisp_c);

         --END LOOP;
       /*IF trall.ba.COUNT>0 THEN
      FOR k12 IN trall.ba.FIRST .. trall.ba.LAST LOOP
          IF trall.ba(k12).urov=x-1 THEN
                trall.ba.DELETE(k12);
             END IF;
          NULL;
      END LOOP;
      END IF;*/
--commit;
      END LOOP;
      --trall.trall.ba:=trall.ba;
--      trall.intv:=t;
      --p_show_debug(trall.intv);
      RETURN 1;--trall;
    END;
      --***********************************************************************
    FUNCTION F_RES_K_INL2obr(
                        trall IN OUT NOCOPY t_rec_all,
                        p_start   IN DATE,
                        p_end     IN DATE,
                        p_rntv    IN NUMBER DEFAULT NULL,
                        p_rnispob IN NUMBER DEFAULT NULL,
                        p_part IN NUMBER DEFAULT 1
                        ) RETURN INTEGER --t_rec_all
      IS
      --trall t_rec_all;
  -- Установка
      TYPE ustnumbers IS  RECORD(
           key PLS_INTEGER,
           rn_tv NUMBER,
           isp_chto NUMBER,
           tv_chto NUMBER, -- Если есть ТВ у исп объекта - то делим на два разных объекта
           rn_pozmo NUMBER
     );
  -- Образец
      TYPE obrnumbers IS  RECORD(
           key PLS_INTEGER,
           tv_izg  NUMBER, -- С кем совм. изготовляется
           tv_obr NUMBER, -- Образец
           arid_mo NUMBER -- Кого защищает
     );
     --Заготовка
      TYPE zagnumbers IS  RECORD(
           key PLS_INTEGER,
           rn_tv  NUMBER -- Кто имеет заготовку
     );
      --ba  t_res_nl3;
      x   PLS_INTEGER := 1; -- Текущий уровень
      num PLS_INTEGER := 0; -- Кол-во записей в коллекции
      key PLS_INTEGER:=1; -- текущий вставляемый key
      oldkey PLS_INTEGER; -- предыдущий key
      dce_chto_key ustnumbers;   -- Текущий  key, ДСЕ-что и rnpozmo
      dce_chto_key_obr obrnumbers;   -- Текущий key,
      dce_chto_key_zag zagnumbers;   -- Текущий key,
      r PLS_INTEGER; -- Для прохода по циклу изменений в ветке
      --izm_cnt PLS_INTEGER; -- Кол-во изменений пройденных в ветке
      --strsql CLOB; -- Текст запроса который выполняется

--      t tb_int_dstart;
      --kol3 NUMBER; -- Временная для расчета кол-ва
      --uf NUMBER; -- Полная применяемость ДСЕ куда
      intv t_res_tb_intv;
      --cnt_intv_v PLS_INTEGER; -- Временная для прохождения по интервалам
      --tb_rint rec_int_farid;
     -- tb_kol rec_ez;
       tb_td  pk_tresult3.tb_td;
      m NUMBER; -- Временная для прохождения по техдобавкам
      n NUMBER;
      fl_relink boolean:=false;
      fl_first_record integer:=1; -- Обрабатываем уровень 0
      --cnt_rec INTEGER:=0; --Счетчик отработанных записей
      fromstart DATE; -- Откуда копируем
      fromfarid NUMBER;--Откуда копируем
--      nmo t_node_mo;
      n_ez NUMBER;
      --tmpFlag INTEGER:=0;
      izdPornom NUMBER;
      izdPozmo NUMBER;
--
      vRN_Pozmo       PLS_INTEGER; -- Позиция для которой счатаем из- за заготовки
      vFaridNext NUMBER; -- Farid следующего за текущим состояния
      vDstart DATE;
      vFarid NUMBER;
      vInd_new CHAR(1);
      vRn_Prich NUMBER;
      cycrn_ispob_ch number;
      cycez NUMBER;
      cycrn_pozmo NUMBER;
      tmpEarid number;
      tmpmo_states t_node_mo;
      tmpmo_intv t_node_mo;
      --iExists PLS_INTEGER;
      --iExists2 PLS_INTEGER;
      --vAp NUMBER;
      oldcntint  PLS_INTEGER:=0;
      cntINT PLS_INTEGER;
   BEGIN
      trall.ba := t_res_nl3();
      intv:= t_res_tb_intv();

      --Добавляем один элемент
      INTv.EXTEND;
      intv(INTv.LAST) := t_res_intv(p_start,-1);
      --trall.intv(to_char(p_start,'DD.MM.YYYY HH24:MI:SS'))(-1).ind:=null;
      FOR c IN (SELECT a.rn_ispob,
                       a.rn AS rn_c,
                       -1 AS rn_kuda,
                       1.0 AS kol,
                       1.0 AS ak,
                       1.0 AS oldkol,
                       x AS urov
                  FROM w_ktsg.v_tv a
                 INNER JOIN w_ktsg.v_tv_s_wa tvs ON a.rn = tvs.rn_tv
                 INNER JOIN w_ktsg.v_audi aa ON aa.ATT_ARID = tvs.ATT_ARID
                                            AND aa.ATT_ARVER = 0
                                            AND aa.ATT_VAR = 0
                 WHERE w_ktsg.pk_VALUES.CURDATE < aa.att_arend
                   AND w_ktsg.pk_VALUES.CURDATE >= aa.att_arstart
                   AND a.rn = p_rntv) LOOP
         trall.ba.EXTEND;
         trall.ba(trall.ba.LAST) :=
          t_res_elem3(-1,
                      -1,
                      -1,
                                   c.rn_ispob , --AS isp_k
                                   c.rn_c , --AS tv_k
                                   c.rn_ispob , --AS isp_ch
                                   c.rn_c, --as tv_ch
                                   c.kol,
                                   --c.ak,
                                   c.urov,
                                   nvl(p_start, to_date('1.01.2007','DD.MM.YYYY')),
                                   nvl(p_end, to_date('1.10.2008','DD.MM.YYYY')),
                                   999999999999999999999999999, --earid
                                   NULL,
                                   -1,
                                   --NULL, --deltakol
                                   NULL,
                                   1,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   w_mmk_raskomp.f_ei_flag(52));

               dce_chto_key.rn_tv:=1;
               dce_chto_key.key:=1;
               dce_chto_key.isp_chto:=c.rn_ispob;
               dce_chto_key.rn_pozmo:=1;
               dce_chto_key.tv_chto:=null;

               dce_chto_key_obr.key:=1;
               dce_chto_key_obr.tv_obr:=1;
               dce_chto_key_obr.arid_mo:=1;
               dce_chto_key_obr.tv_izg:=1;

               dce_chto_key_zag.key:=1;
               dce_chto_key_zag.rn_tv:=1;
      END LOOP;


      --***********************************************************************
      LOOP
     -- IF x>2 THEN EXIT;   END IF;
     BEGIN
      select
       min(l.pornom) into izdPornom
      from
       w_ktsg.tb_poz_mo l
      where l.rn_tv=p_rntv and l.pornom>0;

     select
      s.rn_pozmo into
      izdPozmo
     from
      w_ktsg.tb_poz_mo_s s,
      w_ktsg.tb_audi a,
      w_ktsg.tb_poz_mo mo
     where
      mo.rn=s.rn_pozmo and mo.pornom=izdPornom and
      s.rn_tv=p_rntv and s.att_arid=a.att_arid and
      s.objtype=a.att_objtype and p_Start<a.att_arend and
      p_Start>=a.att_arstart and a.att_arver=0 and a.att_var=0;
      EXCEPTION
               WHEN no_DATA_FOUND THEN
               izdPornom:=null;
               izdPozmo:=null;
      END;
         FOR c IN (
         select
         0 as base,
         d.dstart,
         d.dend,
         --d.oldkol,
         --d.ak,
         d.rn_prich,
         d.ardis,
         d.farid,
         d.earid,
         d.rnisp_C as rnisp_k,
         d.key,
         d.ind_new,
         d.rnISP_c AS rn_ispob,
         d.rnisp_C AS rn_ispob_ch,
         p_rntv AS rn_tv,
         p_rntv AS tv_ch,
         1 AS TV_IZG,
         1 AS kol_o,
         sysdate as ATT_ARSTART,
         sysdate AS att_arend,
         1 as att_auth,
         '1' as att_ardis,
         1 AS att_arver,
         izdPozmo AS rn_pozmo,
         '0' AS ind,
         1 AS att_arid,
         1 AS arid_zo,
         null as ATT_PREVARID,
         52 AS ez,
         w_mmk_raskomp.f_ei_flag(52) as flag,
         d.att_arid as arid_k,
         1 AS kol,
         --d.izms as izms,
         1 as ran,
         1 as urov
          FROM TABLE(CAST(trall.ba AS t_res_nl3)) d
          WHERE fl_first_record =1
          union all(
         SELECT ---full(d)
         1 as base,b.*, (x + 1) AS urov
                     FROM (--- leading(d) use_nl(d s) use_nl(s a) use_nl(s C) use_nl(ksp d)
                           SELECT --+ first_rows leading(d)
                             d.dstart
                             ,d.dend,
                             --d.oldkol,
                             --d.ak*decode (ksp.ind,1,ksp.kol_o,0) * nvl2(ksp.att_ardis,0,1) AS ak,
                             d.rn_prich,
                             d.ardis,
                             d.farid,
                             d.earid,
                             d.rnisp_c AS rnisp_k,
                             d.key,
                             d.ind_new,
                             ksp.*,
--                             ,ksp.kol_o * d.kol /**tvs.DOLY*//* AS kol,
                             d.att_arid as arid_k,
                             ksp.kol_o AS kol,
                             --d.izms,
                             rank() over (PARTITION BY d.key,ksp.tv_ch ORDER BY ksp.att_arid) AS ran
                             FROM TABLE(CAST(trall.ba AS t_res_nl3)) d
                             JOIN
                             (
                             SELECT --+  use_nl(tv s a tvc)  index(tv AK1_TV)
                             -- УСТАНОВКА КОМПОНЕНТ
                                    tv.rn_ispob, -- Исп куда
                                    s.rn_ispob_ch, -- Исп что
                                    s.rn_tv, -- ТВ куда
                                    nvl(tvc.RN,1) AS TV_CH, -- ТВ что NULL введен из за дублирования записей при двух технологических вариантах
                                    NULL AS TV_IZG, -- С кем совместно изготавливается
                                    s.kol /**tvs.DOLY*/ AS kol_o,
                                    a.ATT_ARSTART,
                                    a.att_arend,
                                    a.att_auth,
                                    a.att_ardis,
                                    att_arver,
                                    rn_pozmo,
                                    '1' AS ind,
                                    a.att_arid,
                                    NULL AS arid_zo, --арид кого защищает образец
                                    a.ATT_PREVARID,
                                    s.rn_ei_ust AS ez,
                                    w_mmk_raskomp.f_ei_flag(rn_ei_ust) as flag
                             from
                              w_ktsg.v_tv tv
                             JOIN w_ktsg.tb_ust_comp_s s ON tv.rn = s.rn_tv
                             JOIN w_ktsg.v_audi a ON
                                                 s.att_arid = a.att_arid
                                                 AND a.ATT_VAR = 0
                                                 AND a.att_arver =0-- NVL2(a.att_ardis, 1, 0)
                              LEFT JOIN w_ktsg.v_tv tvc ON s.rn_ispob_ch=tvc.RN_ISPOB
                              --JOIN tb_auth_farid fa ON a.att_auth=fa.att_auth
                             UNION ALL -- ОБРАЗЕЦ
                             SELECT --+ use_nl(o a t tv) index(tv AK1_TV) star
                             tv.rn_ispob,-- Исп куда - защ объект
                             --w_mmkt.f_get_rn_ispob(o.rn_tv_obr), -- Исп что - образец
                             tvo.RN_ISPOB, -- Исп что - образец
                             t.rn_tv, -- ТВ куда - защ объекта
                             o.rn_tv_obr, -- ТВ что - образец
                             o.rn_tv_izg,
                             1 as kol,
                             a.att_arstart,
                             a.att_arend,
                             a.att_auth,
                             a.att_ardis,
                             a.att_arver,
                             t.rn_pozmo,
                             '3' as ind,
                             a.att_arid,
                             o.arid_pozmo AS arid_zo, --арид кого защищает образец
                             a.ATT_PREVARID,
                             52 AS ez,
                             w_mmk_raskomp.f_ei_flag(52) as flag
                             FROM
                                    w_ktsg.tb_obr_s o
                                    JOIN w_ktsg.v_audi a on
                                         o.att_arid=a.ATT_ARID and
                                         o.objtype=a.ATT_OBJTYPE and
                                         a.att_var=0 and  a.att_arver =0-- NVL2(a.att_ardis, 1, 0)
                                    JOIN w_ktsg.tb_poz_mo_s t on t.att_arid=o.arid_pozmo
                                    JOIN w_ktsg.v_tv  tv on t.rn_Tv=tv.rn
                                    JOIN w_ktsg.v_tv tvo ON o.rn_tv_obr=tvo.RN
                                    --JOIN tb_auth_farid fa ON a.att_auth=fa.att_auth
                           UNION ALL -- ЗАГОТОВКА
                           SELECT--+  use_nl(tz tvz az tvcz) index(tvz AK1_TV) star
                                 tvz.RN_ISPOB AS rn_ispob, -- Исп куда
                                 tz.rn_ispob_zag AS rn_ispob_ch,-- Исп что
                                 tz.rn_tv AS rn_tv,-- ТВ куда
/*                                 CASE WHEN f_res_cex_pol_mat(tz.rn_tv,az.ATT_ARSTART,f_get_first_arid(az.att_auth)) IS NOT NULL THEN
                                 (SELECT rn_tv FROM w_ktsg.tb_poz_mo m WHERE m.rn=f_res_cex_pol_mat(tz.rn_tv,az.ATT_ARSTART,f_get_first_arid(az.att_auth)) )
                                 ELSE
                                     NULL
                                 END*/
                                 nvl(tvcz.rn,1) AS tv_ch,-- ТВ что
                                 NULL AS TV_IZG, -- С кем совместно изготавливается  - только для образцов
                                 tz.normrash /**tvs.DOLY*/ AS kol_o,
                                 az.ATT_ARSTART,
                                 az.att_arend,
                                 az.att_auth,
                                 az.att_ardis,
                                 az.att_arver,
                                 f_res_cex_pol_mat(tz.rn_tv,az.ATT_ARSTART,f_get_first_arid(az.att_auth)) AS rn_pozmo,
                                 '2' AS ind, -- Заготовка
                                 az.att_arid,
                                 NULL AS arid_zo, --арид кого защищает образец
                                 az.ATT_PREVARID,
                                 tz.rn_ei AS ez,
                                 w_mmk_raskomp.f_ei_flag(rn_ei) as flag
                           FROM
                               w_ktsg.tb_t_zag_s tz
                               JOIN w_ktsg.v_tv tvz ON tz.rn_tv=tvz.RN
                               JOIN w_ktsg.v_audi az ON
                                                            tz.att_arid=az.ATT_ARID AND
                                                            tz.objtype=az.ATT_OBJTYPE AND
                                                            az.ATT_VAR=0 AND az.att_arver=0--nvl2(az.ATT_ARDIS, 1, 0)
                               LEFT JOIN w_ktsg.v_tv tvcz ON tz.rn_ispob_zag=tvcz.RN_ISPOB
                                --JOIN tb_auth_farid fa ON az.att_auth=fa.att_auth
                                                 ) ksp ON
                                                       /*D.rnisp_c = ksp.rn_ispob
                                                       AND nvl(d.rntv_c,-15)=nvl(ksp.rn_tv,-15)*/
                                                       d.rnisp_k=ksp.rn_ispob_ch
                                                       AND nvl(d.rntv_k,-15)=nvl(ksp.tv_ch,-15)
                                                       AND d.urov = x
                                                       AND (
                                                           (d.dstart < ksp.att_arend AND -- Дата конца состояний для раскомплектовки до изменений должна быть внутри интервала
                                                            d.dend >= ksp.att_arend AND
                                                            rn_prich = -1)
                                                          OR
                                                           -- Завершение
                                                           (
                                                             (   d.dstart < ksp.att_arend
                                                                        OR -- дата завершения действия должна быть внутри интервала
                                                              (d.dstart = ksp.att_arend
                                                              -- Чтоб при изменениях с одной даты попадали состояния идущие по состоянию своих изменений после верхнего
                                                              AND
                                                              w_mmkt.pk_tresult2.f_get_first_arid_for_end(ksp.att_arid)-d.farid >0--= 0
                                                              AND rn_prich<>-1
                                                              )
                                                           )
                                                               AND
                                                             (   d.dend > ksp.att_arend
                                                                 OR
                                                                 (
                                                                 d.dend=ksp.att_arend
                                                                  AND
                                                                  w_mmkt.pk_tresult2.f_get_first_arid_for_end(ksp.att_arid)-d.farid < 0
                                                                 )
                                                            )
                                                            )
                                                          OR
                                                          -- Начало
                                                           (
                                                              (d.dstart < ksp.att_arstart ----- дата начала действия должна быть внутри интервала
                                                                        OR
                                                                 (d.dstart = ksp.att_arstart
                                                                  AND
                                                                   f_get_first_arid(ksp.att_auth)-d.farid >= 0
                                                                )
                                                              )
                                                              AND
                                                            (d.dend > ksp.att_arstart
                                                                   OR
                                                              (
                                                                     --d.dstart=ksp.att_arstart  07.07.2008
                                                                     d.dend=ksp.att_arstart
                                                                 AND
                                                                     --fa.farid-d.farid<0
                                                                     --f_get_first_arid(ksp.att_auth)-d.farid<0 07.07.2008
                                                                     f_get_first_arid(ksp.att_auth)-d.earid<0
                                                                 --AND d.rn_prich<>-1
                                                              )
                                                            )
                                                           )
                                                          OR -- Учитываем изменения конца интервала - если дата начала состояния равна дате конца интервала и
                                                              -- дате конца заданного к расчету периода - то берем ее
                                                           (p_end=d.dend AND
                                                            ksp.att_arstart=p_end
                                                           )
                                                          OR
                                                            (
                                                            (d.dstart > -- То что действует на всем интервале и не аннулировано
                                                            ksp.att_arstart
                                                            OR (
                                                            d.dstart=ksp.att_arstart
                                                                                    AND
                                                                pk_tresult3.f_get_first_arid(ksp.att_auth)-d.farid <= 0
                                                            )
                                                            )
                                                             AND
                                                             (d.dend < ksp.att_arend
                                                                    OR (
                                                                    d.dend=ksp.att_arend
                                                                    AND
                                                                    pk_tresult3.f_get_first_arid_for_end(ksp.att_arid)-d.earid >=0
                                                                    )
                                                            ) AND
                                                            ksp.att_ardis IS NULL
                                                            )
                                                       )
                                              ) b
                                              )

                    ORDER BY base,key, ind,rn_ispob_ch, tv_ch, rn_tv, tv_izg, rn_pozmo, arid_zo, att_arstart--,ind
                    ) LOOP
                    BEGIN
     IF fl_first_record=0 THEN
                    --w_otk.p_load_log('att_arid=' || c.att_arid || ' rn_Tv=' || c.rn_tv || ' rn_isp= ' || c.rn_ispob_ch || ' ind=' || c.ind,9);
                    IF c.ind=2 AND  c.rn_ispob_ch=F_Get_rn_ispOb(c.rn_tv)  THEN -- Исключение зацикливания по заготовке
                          NULL;
                          GOTO next_state;
                    ELSE

            -- Размножение интервалов - чтоб по дате окончания размножались при удаленном следующем состоянии
            -- Получить арид следующего состояния - чтоб определить его farid
            IF c.att_arend<=p_end THEN
                 vFaridNext:=w_common.pk_audi.GetNextActual(c.att_arid,'1');
                 IF vFaridNext<>-1 THEN
                  --Проверить - является ли след. состояние аннулированием
                 SELECT COUNT(*) INTO r FROM tb_audi a WHERE a.att_arid=vFaridNext AND a.att_ardis IS NOT NULL;
                 SELECT f_get_first_arid(att_auth) INTO vFaridNext FROM tb_audi WHERE att_arid=vFaridNext;
                 IF r=1 THEN
                    SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv)) WHERE att_arstart=c.att_arend AND farid=vFaridNext;
                       IF r=0 THEN --Нет такого интервала - создаем
                          intv.EXTEND;
                          intv(intv.LAST):=t_res_intv(c.att_arend, vFaridNext);
                          -- Копируем все что было в ближайшем кверху интервале в данный
                          -- Скопировать из верхнего интервала все в этот интервал
                          -- копируем из минимального который меньше данного
                               SELECT att_arstart,farid
                               INTO fromstart, fromfarid
                                FROM (
                              SELECT att_arstart, farid
                               FROM TABLE (cast(intv AS t_res_tb_intv))
                              WHERE att_arstart<c.att_arend OR (att_arstart=c.att_arend AND farid<vFaridNext)
                              ORDER BY att_arstart DESC, farid DESC)
                              WHERE rownum<2;
                               /*IF trall.intv.exists(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS')) then
                      \*farid*\IF trall.intv(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS')).EXISTS(fromfarid) THEN
                                  FOR g1 IN (SELECT t.dstart,t.farid,t.rn_isp,t.n,t.v,t.ez,t.ind_mo,t.key_mo,t.rn AS rnfrom
                                       FROM tb_res_fap t
                                       WHERE t.dstart=to_char(fromstart\*c.dstart*\,'DD.MM.YYYY HH24:MI:SS') AND t.farid=fromfarid
                                       ) LOOP
                                         \*SELECT seq_res.NEXTVAL INTO iExists FROM dual;
                                       INSERT INTO tb_res_fap
                                         (dstart, farid, rn_isp, n, v, ez, ind_mo, key_mo, rn)
                                       VALUES
                                         (to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'), vFaridNext, g1.rn_isp, g1.n, g1.v, g1.ez, g1.ind_mo, g1.key_mo, iExists);
                                         -- Копируем ТВ
                                                FOR g2 IN (SELECT t.rntv,t.uf,t.ap FROM tb_res_dtv t WHERE t.rnmo_fk=g1.rnfrom) LOOP
                                                SELECT seq_res.NEXTVAL INTO iExists2 FROM dual;
                                                    INSERT INTO tb_res_dtv
                                                      (rnmo_fk, rn, rntv, uf,ap)
                                                    VALUES
                                                      (iExists, iExists2, g2.rntv, g2.uf,g2.ap);
                                                END LOOP;
                                         END LOOP;*\
                                       trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'))(vFaridNext):=trall.intv(to_char(fromstart,'DD.MM.YYYY HH24:MI:SS'))(fromfarid);

                                       --Удаление собственных позиций
                                       \*m:=trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v.FIRST;
                                       WHILE m IS NOT NULL LOOP
                                             IF trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v(m).ind=0 THEN
                                             trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v.DELETE(m);
                                       END IF;
                                       m:=trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS')) (vFaridNext).tb_r(c.rn_ispob_ch).n(c.ez).v.next(m);*\
                                       END LOOP;
                                   ELSE
                                     trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'))(vFaridNext).ind:=null;
                                   END IF;
                               ELSE-- Еще вообще ничего нет
                                 trall.intv(to_char(c.att_arend,'DD.MM.YYYY HH24:MI:SS'))(vFaridNext).ind:=null;
                               END IF;*/
                       END IF;
                    END IF; -- r=1
               END IF;-- vFaridNext<>-1
            END IF;

            IF c.att_arstart > c.dstart OR (c.att_arstart = c.dstart AND f_get_first_arid(c.att_auth)>c.farid AND c.rn_prich<>-1) OR (c.rn_prich=c.att_auth AND c.att_arstart=p_start AND c.att_arstart=c.dstart) THEN --Встретили изменение
               IF f_get_prev_actual2(c.att_arid,'1') = -1 THEN
                  -- Предыдущего состояния не было - это новое
                  vInd_new:='1';
               END IF;
               -- Началось  внутри интервала
               vRn_prich := c.att_auth;
               vDstart := c.att_arstart;
               vFarid  := f_get_first_arid(c.att_auth);
               --Добавляем интервал - если его нету
               SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv)) WHERE att_arstart=c.att_arstart AND farid=vfarid;
               IF r=0 THEN
                  intv.EXTEND;
                  intv(intv.LAST):=t_res_intv(c.att_arstart, vFarid);
               END IF;
            ELSE
               -- Началось вне(до) интервала
               vRn_prich := c.rn_prich;
               vDstart := c.dstart;
               vFarid :=c.farid;
               -- Изменение - состояние начало действовать до интервала
            END IF;

            IF c.ind=1 AND f_is_mo_actual( vDstart, vFarid,c.rn_pozmo,p_start)=-1 THEN
                               -- Позиция неактуальна
                               GOTO next_state;
            ELSIF c.ind=3 AND F_is_arid_actual(vDstart,vFarid,c.arid_zo,p_start)=-1 THEN
                               -- Позиция неактуальна
                               GOTO next_state;
            END IF;

            --Цикл
            trall.ba.EXTEND;
            trall.ba(trall.ba.LAST) := t_res_elem3(
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       null);
            trall.ba(trall.ba.LAST).arid_k:=c.arid_k;
            trall.ba(trall.ba.LAST).att_arid := c.att_arid;
            trall.ba(trall.ba.LAST).rntv_k := c.rn_tv; --rn_tvk;
            trall.ba(trall.ba.LAST).rntv_c := c.tv_ch;
            trall.ba(trall.ba.LAST).rnisp_c := c.rn_ispob_ch;
            trall.ba(trall.ba.LAST).rnisp_k := c.rn_ispob;--c.rnisp_k;
            trall.ba(trall.ba.LAST).urov := c.urov;
            trall.ba(trall.ba.LAST).ind := c.ind;
            trall.ba(trall.ba.LAST).arid_zo:=c.arid_zo;
            trall.ba(trall.ba.LAST).att_auth1:=c.att_auth;
            trall.ba(trall.ba.LAST).ez:=c.ez;
            trall.ba(trall.ba.LAST).flag:=c.flag;
            -- Простановка key
            IF c.ind='1' THEN
            -- Установка
            IF dce_chto_key.key<>c.key OR dce_chto_key.isp_chto<>c.rn_ispob_ch OR dce_chto_key.rn_pozmo<>c.rn_pozmo  OR nvl(dce_chto_key.tv_chto,-15)<>nvl(c.tv_ch,-15) THEN
                        key:=key+1;
                        dce_chto_key.key:=c.key;
                        dce_chto_key.rn_tv:=c.rn_tv;
                        dce_chto_key.isp_chto:= c.rn_ispob_ch;
                        dce_chto_key.rn_pozmo:= c.rn_pozmo;
                        dce_chto_key.tv_chto:=c.tv_ch;
            END IF;
            ELSIF c.ind=3 THEN
            -- Образец
            IF dce_chto_key_obr.key<>c.key OR dce_chto_key_obr.tv_obr<>c.tv_ch OR dce_chto_key_obr.arid_mo<>c.arid_zo OR dce_chto_key_obr.tv_izg<>c.TV_IZG THEN
                         key:=key+1;
                        dce_chto_key_obr.key:=c.key;
                        dce_chto_key_obr.tv_obr:= c.TV_CH;
                        dce_chto_key_obr.arid_mo := c.arid_zo;
                        dce_chto_key_obr.tv_izg := c.tv_izg;
            END IF;
            ELSIF c.ind=2 THEN
            -- Заготовка
               IF dce_chto_key_zag.key<>c.key OR dce_chto_key_zag.rn_tv<>c.rn_tv THEN
                         key:=key+1;
                        dce_chto_key_zag.key:=c.key;
                        dce_chto_key_zag.rn_tv:= c.RN_TV;
               END IF;
            END IF;
            trall.ba(trall.ba.LAST).key:=key;

            trall.ba(trall.ba.LAST).ind_new:=vInd_new;
               trall.ba(trall.ba.LAST).rn_prich:=vRN_Prich;
               trall.ba(trall.ba.LAST).dstart:=vDstart;
               trall.ba(trall.ba.LAST).farid:=vFarid;

            -- Если вверху ввелось с 0 - то чтоб введенные внизу также считались введенными с 0 - протягивание введения вниз
--            IF c.rn_tv =177819 THEN
--               DBMS_output.put_line(c.tv_ch || ' ' || c.ran);
--            END IF;
            IF c.ind_new IS NOT NULL AND c.ran=1 THEN
               --DBMS_output.put_line('->' || c.tv_ch || ' ' || c.ran);
               IF nvl(trall.ba(trall.ba.LAST).ind_new,'0') <>'1' THEN
                  trall.ba(trall.ba.LAST).ind_new:='2';
               END IF;
            END IF;
            tmpEArid:=f_get_first_arid_for_end(c.att_arid);
            IF c.att_arend > c.dend OR (c.att_arend =c.dend AND tmpEarid>c.earid) THEN
               --Состояние закончилось вне(после) интервала
               trall.ba(trall.ba.LAST).dend := c.dend;
               trall.ba(trall.ba.LAST).earid := c.Earid;
            ELSE
              --Состояние закончилось до интервала
               trall.ba(trall.ba.LAST).dend := c.att_arend;
               trall.ba(trall.ba.LAST).earid := tmpEarid;
            END IF;


            IF c.ardis IS NOT NULL THEN
                    trall.ba(trall.ba.LAST).ardis:=to_char(to_number(c.ardis) + to_number(nvl(c.att_ardis,0)));
            ELSE
                        trall.ba(trall.ba.LAST).ardis:=c.att_ardis;
            END IF;

            trall.ba(trall.ba.LAST).kol := c.kol;
--            ba(ba.LAST).ak := c.ak;
            trall.ba(trall.ba.LAST).golova := p_rntv;
            --С той же даты другое изменение
            IF c.att_arstart = c.dstart AND c.rn_prich <> c.att_auth AND c.rn_prich <> -1 THEN
               --Если разные изменения - то
               IF f_get_first_arid(c.rn_prich)<f_get_first_arid(c.att_auth) THEN
                  -- Верхнее раньше нижнего
                  -- Встречалось ли оно раньше
                  trall.ba(trall.ba.LAST).ind_dts := '1';
               ELSE
                  -- Нижнее раньше верхнего
                   trall.ba(trall.ba.LAST).ind_dts := '2';
               END IF;
            ELSE
               trall.ba(trall.ba.LAST).ind_dts := '0';
            END IF;
            --PIPE ROW(ba(ba.LAST));
            END IF;
           END IF;--fl_first_record
           -- Проверка существования более двух интервалов в маршруте ТВ_что
           --ba(ba.LAST).mo_states := t_node_mo();
           tmpmo_states:= t_node_mo();
           tmpmo_states.DELETE;
           tmpmo_intv:= t_node_mo();
           tmpmo_intv.DELETE;
           --ba(ba.LAST).mo_intv := t_node_mo();
           P_GET_MO_INTERVALS(p_start,c.tv_ch, trall.ba(trall.ba.LAST).dstart, trall.ba(trall.ba.LAST).farid, trall.ba(trall.ba.LAST).dend, trall.ba(trall.ba.LAST).earid, trall.ba(trall.ba.LAST).rn_prich, trall.ba(trall.ba.LAST).ind_mo,tmpmo_states,/*ba(ba.LAST).mo_intv*/tmpmo_intv);

           FOR mo_int IN ( -- Размножение интервалов при изменении маршрута
                          SELECT dstart,dend,farid,earid,att_auth,rownum AS rnum FROM (
           SELECT trall.ba(trall.ba.LAST).dstart AS dstart,trall.ba(trall.ba.LAST).dend AS dend, trall.ba(trall.ba.LAST).farid AS farid , trall.ba(trall.ba.LAST).earid AS earid, trall.ba(trall.ba.LAST).rn_prich AS att_auth FROM dual
           WHERE nvl(trall.ba(trall.ba.LAST).ind_mo,0)=0
           UNION
           SELECT att_arstart,att_arend,
           CASE WHEN att_arstart=p_start THEN -1 ELSE
           farid END AS farid,
           earid,
           att_auth FROM TABLE (CAST (/*ba(ba.LAST).*/tmpmo_intv  AS t_node_mo))
           WHERE trall.ba(trall.ba.LAST).ind_mo>0)
           ) LOOP
           fl_first_record:=0;
           -- Генерируем записи
           IF nvl(trall.ba(trall.ba.LAST).ind_mo,0)<>0 THEN
              -- со второй записи начинаем размножать
              IF mo_int.rnum=1 THEN
                 trall.ba(trall.ba.LAST).dend:=mo_int.dend;
                 trall.ba(trall.ba.LAST).earid:=mo_int.earid;
              END IF;
              IF mo_int.rnum>1 THEN
                 trall.ba.EXTEND;
--                 ba(ba.LAST) := ba(ba.PRIOR(ba.LAST)) ;
                 --ba(ba.LAST).arid_k:=ba(ba.PRIOR(ba.LAST)).arid_k;
                 trall.ba(trall.ba.LAST):=t_res_elem3(trall.ba(trall.ba.PRIOR(trall.ba.LAST)).arid_k,
                      trall.ba(trall.ba.PRIOR(trall.ba.LAST)).att_arid,
                      trall.ba(trall.ba.PRIOR(trall.ba.LAST)).farid,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rnisp_k , --AS isp_k
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rntv_k , --AS tv_k
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rnisp_c , --AS isp_k
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rntv_c, --as tv_ch
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).kol,
--                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ak,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).urov,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).dstart,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).dend,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).earid,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).rn_prich,
--                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).deltakol,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ardis,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).key,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).arid_zo,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind_new,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).att_auth1,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).golova,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind_dts,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ez,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).ind_mo,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).mo_states,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).mo_intv,
                                   trall.ba(trall.ba.PRIOR(trall.ba.LAST)).flag);
                 trall.ba(trall.ba.LAST).rn_prich:=mo_int.att_auth;
                 trall.ba(trall.ba.LAST).dstart:=mo_int.dstart;
                 trall.ba(trall.ba.LAST).farid:=mo_int.farid;
                 trall.ba(trall.ba.LAST).dend:=mo_int.dend;
                 trall.ba(trall.ba.LAST).earid:=mo_int.earid;

               --Добавляем интервал - если его нету
               SELECT COUNT(*) INTO  r FROM TABLE (cast(intv AS t_res_tb_intv)) WHERE att_arstart=mo_int.dstart AND farid=mo_int.farid;
                  IF r=0 THEN
                      intv.EXTEND;
                      intv(intv.LAST):=t_res_intv(mo_int.dstart, mo_int.farid);
                  END IF;
                 END IF;
              END IF;

           END LOOP; /*intv mo*/
   EXCEPTION
             WHEN OTHERS THEN
                  dbms_output.put_line('error golova='|| p_rntv||' tb_rcount3=' || c.att_arstart ||' isp_ch=' || c.rn_ispob_ch || ' tv_ch='|| nvl(c.tv_ch,-1) || ' ind=' ||c.ind || ' ur=' ||c.urov|| ' '|| SQLERRM);
                   /*trall.trall.ba:=trall.ba;
                  RETURN trall;*/
           END;
           --dbms_output.put_line('tv_k = ' ||c.rn_tv || ' tv_ch = ' ||c.tv_ch || ' isp_ch= ' || c.rn_ispob_ch || ' urov=' ||c.urov || ' dstart=' || c.dstart || ' dend=' || c.dend || ' ind=' || c.ind  );

           /*IF c.tv_ch=139757 THEN
               --tmpFlag:=1;
               p_show_debug(trall.intv);
           END IF;*/
           --IF tmpFlag=1 THEN
              --p_show_debug(t);
           --END IF;
                    --cnt_rec:=cnt_rec+1;
           /*dbms_output.put_line('tv_ch = ' ||c.tv_ch);
           p_show_debug(t);*/
           SELECT COUNT(*) INTO  cntint FROM TABLE (cast(intv AS t_res_tb_intv));
           IF cntint<>oldcntint THEN
                 dbms_output.put_line('кол-во интервалов=' || cntint || ' urov=' || c.urov);
                 /*FOR itnv IN (SELECT att_arstart, farid FROM TABLE (cast(intv AS t_res_tb_intv)) ) LOOP
                 dbms_output.put_line('Интервал= ' || itnv.att_arstart || ' '|| itnv.farid);
                 END LOOP;*/
                 oldcntint:=cntint;
           END IF;
/*           IF cnt_rec>10 THEN
              RETURN 1;
           END IF;
*/
<<next_state>>
NULL;
END LOOP;
         IF num = trall.ba.COUNT THEN
            EXIT;
         END IF;
         num := trall.ba.COUNT;
         x   := x + 1;
         --IF x>1 THEN EXIT;   END IF;
         --dbms_output.put_line('Urov= ' || x);

           --  dbms_output.put_line(k.dstart || ' ' || k.dend || ' ' || k.farid || ' ' || k.earid || ' ' || k.rn_prich || ' ' || k.rntv_c || ' ' || k.rnisp_c);

         --END LOOP;
       /*IF trall.ba.COUNT>0 THEN
      FOR k12 IN trall.ba.FIRST .. trall.ba.LAST LOOP
          IF trall.ba(k12).urov=x-1 THEN
                trall.ba.DELETE(k12);
             END IF;
          NULL;
      END LOOP;
      END IF;*/
--commit;
      END LOOP;
      --trall.trall.ba:=trall.ba;
--      trall.intv:=t;
      --p_show_debug(trall.intv);
      RETURN 1;--trall;
    END;
--***********************************************************************      
   FUNCTION F_RES RETURN t_res_nl3
      PIPELINED IS
    trall t_rec_all;
    tbe t_res_elem3;
   BEGIN
        --tb:=t_res_nl3();
        tbe:=t_res_elem3(NULL,NULL,NULL,NULL,null,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
        NULL,NULL,null);
       -- trall:=pk_tresult3.F_RES_K_INL('1.04.2007','1.12.2007',488055);
        FOR c IN (SELECT * FROM TABLE(CAST (trall.ba AS t_res_nl3))
        ) LOOP
          tbe.arid_k:=c.arid_k;
          tbe.att_arid:=c.att_arid;
          tbe.farid:=c.farid;
          tbe.rnisp_k:=c.rnisp_k;
          tbe.rntv_k:=c.rntv_k;
          tbe.rnisp_c:=c.rnisp_c;
          tbe.rntv_c:=c.rntv_c;
          tbe.kol:=c.kol;
          tbe.ind:=c.ind;
          tbe.urov:=c.urov;
          tbe.dstart:=c.dstart;
          tbe.dend:=c.dend;
          tbe.rn_prich:=c.rn_prich;
          tbe.ardis:=c.ardis;
          tbe.key:=c.key;
          tbe.arid_zo:=c.arid_zo;
          tbe.ind_new:=c.ind_new;
          tbe.att_auth1:=c.att_auth1;
          tbe.golova:=c.golova;
          PIPE ROW (tbe);
        END LOOP;
       RETURN;
   END;
END PK_TRESULT35;
/
------------------------------------------
--  Changed type sys_plsql_1166944_9_2  --
------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_1166944_9_2 as object (RN_UZL NUMBER,
RN_CHTO NUMBER,
KOL NUMBER);
/
-------------------------------------------
--  Changed type sys_plsql_1166944_27_2  --
-------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_1166944_27_2 as table of W_MMKT."SYS_PLSQL_1166944_9_2";
/
----------------------------------------------
--  Changed type sys_plsql_1166944_dummy_2  --
----------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_1166944_DUMMY_2 as table of number;
/
------------------------------------------
--  Changed type sys_plsql_1220703_9_1  --
------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_1220703_9_1 as object (RN_UZL NUMBER,
RN_CHTO NUMBER,
KOL NUMBER);
/
-------------------------------------------
--  Changed type sys_plsql_1220703_27_1  --
-------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_1220703_27_1 as table of W_MMKT."SYS_PLSQL_1220703_9_1";
/
----------------------------------------------
--  Changed type sys_plsql_1220703_dummy_1  --
----------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_1220703_DUMMY_1 as table of number;
/
-------------------------------------------
--  Changed type sys_plsql_2221697_12_1  --
-------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_2221697_12_1 as object (NUM INTEGER,
NUMOSN NUMBER,
RN_PRICH NUMBER,
ZEX VARCHAR2(255),
TYP CHAR(1),
NOMIZM VARCHAR2(30),
RN_PODR NUMBER(3),
KORNAIM VARCHAR2(3),
DTSD NUMBER,
DTPV_F NUMBER,
DT_F NUMBER);
/
-------------------------------------------
--  Changed type sys_plsql_2221697_85_1  --
-------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_2221697_85_1 as table of W_MMKT."SYS_PLSQL_2221697_12_1";
/
----------------------------------------------
--  Changed type sys_plsql_2221697_dummy_1  --
----------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_2221697_DUMMY_1 as table of number;
/
---------------------------------------
--  New type sys_plsql_642883_149_1  --
---------------------------------------
create or replace type w_mmkt.SYS_PLSQL_642883_149_1 as object (RN_TV NUMBER,
DIZM DATE,
RNISPOB_B NUMBER,
RNISPOB_S NUMBER,
RN_VID_ISPOB_B NUMBER,
RN_VID_ISPOB_S NUMBER,
RN_EI_B NUMBER,
RN_EI_S NUMBER,
NORMRASH_B NUMBER,
NORMRASH_S NUMBER,
VIDZAG_B VARCHAR2(30),
VIDZAG_S VARCHAR2(30),
KOLDETZAG_B NUMBER,
KOLDETZAG_S NUMBER,
VESZAG_B NUMBER,
VESZAG_S NUMBER,
GEOMR_DL_B NUMBER,
GEOMR_DL_S NUMBER,
GEOMR_SH_B NUMBER,
GEOMR_SH_S NUMBER,
TZAGNOTE_B VARCHAR2(2000),
TZAGNOTE_S VARCHAR2(2000));
/

---------------------------------------
--  New type sys_plsql_642883_362_1  --
---------------------------------------
create or replace type w_mmkt.SYS_PLSQL_642883_362_1 as table of W_MMKT."SYS_PLSQL_642883_149_1";
/

-----------------------------------------
--  New type sys_plsql_642883_dummy_2  --
-----------------------------------------
create or replace type w_mmkt.SYS_PLSQL_642883_DUMMY_2 as table of number;
/

-----------------------------------------
--  Changed type sys_plsql_696759_9_2  --
-----------------------------------------
create or replace type w_mmkt.SYS_PLSQL_696759_9_2 as object (RN_UZL NUMBER,
RN_CHTO NUMBER,
KOL NUMBER);
/
------------------------------------------
--  Changed type sys_plsql_696759_27_2  --
------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_696759_27_2 as table of W_MMKT."SYS_PLSQL_696759_9_2";
/
---------------------------------------------
--  Changed type sys_plsql_696759_dummy_2  --
---------------------------------------------
create or replace type w_mmkt.SYS_PLSQL_696759_DUMMY_2 as table of number;
/
-----------------------------------
--  Changed type t_find_mmk_tmp  --
-----------------------------------
create or replace type w_mmkt.T_FIND_MMK_tmp as object
(
OBOZN Varchar2(255),
PACK_OBOZN varchar2(255),
TIP_ISPOB char(1),
VID_ISPOB varchar2(30) ,
VID_NAIM varchar2(255),
ind_nalcomp char(1),
VI varchar2(30),
IND_SOSTAV number,
ATT_ARID NUMBER,
RN_TV NUMBER,
DOLY NUMBER,
TVNAIM VARCHAR2(255),
TVMASSA NUMBER,
OBJTYPE NUMBER,
TVNOTE VARCHAR2(2000),
SPR number
)
/
----------------------------------------
--  Changed type t_find_tv_klon_temp  --
----------------------------------------
create or replace type w_mmkt.T_Find_tv_klon_temp as object
(--Иванова Вера 14.02.2007 
     Rn number,--RN техварианта исполь.объекта
     Obozn Varchar2(300),--обозначение исполь.объекта
     vi Varchar2(2),--вариант изготовления исполь.объекта
     TvNaim Varchar2(300),--наименование исполь.объекта
     m VARCHAR2(500),--МО исполь.объекта
     tr VARCHAR2(300),--информация о труде исполь.объекта
     Nom_num varchar2(200),--номенкл. номер объекта (материала из справочника),взятого в качестве заготовки при изготовлениии объекта 
     z varchar2(300),--обозначение используемого объекта,взятого в качестве заготовки при изготовлениии объекта 
     doly varchar2(50),--доля изготовления технологического варианта
     geomr_dl number,--геометрические размеры заготовки
     geomr_sh number,--геометрические размеры заготовки
     ind_komp number,--индикатор наличия компонент у объекта
     rn_ispob number,--RN исполь.объекта
     kol number,--конструктор. кол-во вхождения в сборку(если она задана)
     ap number,--технол.кол-во (с учетом всех вышестоящих технол.добавок) вхождения в сборку(если она задана)
     ez varchar2(10),--единица измерения вхождения в сборку(если она задана)
     --Заглядова, 19.10.07
     vid_Isp_ob VARCHAR2(30) --вид использ.объекта  
)
/
----------------------------------
--  Changed type t_find_tv_set  --
----------------------------------
create or replace type w_mmkt.t_find_tv_set is Table of t_find_tv
--Иванова Вера 14.02.2007
/
---------------------------------
--  Changed type t_info_ispob  --
---------------------------------
create or replace type w_mmkt.T_INFO_ISPOB as object
(--Изместьев А.А. 4.09.2007
ISP_RN            number,            --  РН объекта
ISP_OBOZN_B varchar2(255),    --Обозначение было
ISP_OBOZN_S varchar2(255),    --Обозначение Стало
ISP_TIP_B        char(1),              --Тип объекта было
ISP_TIP_S        char(1),              --Тип объекта Стало
ISP_VID            number,            --Вид Исп Объекта код
ISP_VID_TXT     varchar2(255),         --Вид ИспОб ТЕкст
ISP_IZG            char(1)              --Индикатор "может изотавливатся"
)
/
------------------------------
--  Changed type t_info_mo  --
------------------------------
create or replace type w_mmkt.T_INFO_MO as object
(--Изместьев А.А. 4.09.2007
MO_TV_RN             number,                --РН ТВ объекта
MO_RN                   number,                --РН МО
MO_PORNOM         number                 --Пор Ном МО





)
/
------------------------------
--  Changed type t_info_tv  --
------------------------------
create or replace type w_mmkt.T_INFO_TV as object
(--Изместьев А.А. 4.09.2007
TV_RN             number,                --РН ТВ объекта
TV_VI             Varchar2(30),          --Вариант изготовления
TV_IZG            char(1),                  --Изготавливаемый       
TV_IND            char(1),                  --Индикатор наличия комплектующих
TV_DOLY_B         number,                   --Доля было
TV_DOLY_S         number,                   --Доля Cтало
TV_NAIM_B           varchar2(255),         --Наименование ТВ было
TV_NAIM_S           varchar2(255),         --Наименование ТВ cтало
TV_MASSA_B          number,              --Масса ТВ было
TV_MASSA_S          number,              --Масса ТВ Стало
TV_NOTE_B          varchar2(2000),       --Примечание было
TV_NOTE_S          varchar2(2000)       --Примечание Стало
)
/
-------------------------------
--  Changed type t_info_zag  --
-------------------------------
create or replace type w_mmkt.T_INFO_ZAG as object
(--Изместьев А.А. 4.09.2007
ZAG_ARID_B           Number,               --Арид заготовки было
ZAG_ARID_S           Number,               --Арид заготовки Cтало
ZAG_RN_TV                    Number,               --РН ТехВар для которого заготовка
ZAG_RN_ISP_B               number,               --ЕТ объекта заготовки Было
ZAG_RN_ISP_S               number,               --ЕТ объекта заготовки стало
ZAG_OBOZN_B                varchar2(255),        --Обозначение заготовки Было
ZAG_OBOZN_S                varchar2(255),        --Обозначение заготовки Было
ZAG_ISPVID_B                 varchar2(30),       --Вид исп об заготовки было
ZAG_ISPVID_S                 varchar2(30),       --Вид исп об заготовки Сьало
ZAR_ISP_RNVID_B            number,               --РН вида объекта заготовки Было
ZAR_ISP_RNVID_S            number,               --РН вида объекта заготовки Стало
ZAG_RN_EI_B                   number,               --РН ед измерения Было
ZAG_RN_EI_S                   number,               --РН ед измерения Стало
ZAG_EI_B                         varchar2(30),        --Ед измерения Было
ZAG_EI_S                         varchar2(30),        --Ед измерения Стало
ZAG_NORMRAZ_B            number,               --Норма расхода Было       
ZAG_NORMRAZ_S            number,               --Норма расхода Стало
ZAG_VID_ZAG_B               varchar2(30),        --Вид   заготовки было (КОД)
ZAG_VID_ZAG_S               varchar2(30),        --Вид   заготовки СТАЛО (КОД)
ZAG_VID_STR_B               varchar2(100),        --Вид   заготовки ТЕКСТ было 
ZAG_VID_STR_S               varchar2(100),        --Вид   заготовки ТЕКСТ СТАЛО 
ZAG_KOLD_B                      number,                --Кол Дет из заг было
ZAG_KOLD_S                      number,                --Кол Дет из заг Стало
ZAG_VES_B                      number,                --Вес заготовки БЫЛО
ZAG_VES_S                      number,                --Вес заготовки СТАЛО
ZAG_DL_B                      number,                --Геометрия Длина БЫЛО
ZAG_DL_S                      number,                --Геометрия Длина Стало
ZAG_SH_B                      number,                --Геометрия Ширина БЫЛО
ZAG_SH_S                      number,                --Геометрия Ширина СТало
ZAG_NOTE_B                varchar2(2000),        --Примечание заготовки Было
ZAG_NOTE_S                varchar2(2000)        --Примечание заготовки Стало
)
/
--------------------------------------
--  Changed type t_izms_td_all_tmp  --
--------------------------------------
create or replace type w_mmkt.T_IZMS_TD_ALL_tmp as object
(-- v24.04.2009
RN_TV             NUMBER,            -- РН ТВ 
pornum            NUMBER,            -- Порядковый номер позиции МО
rn_pozmo          NUMBER,            -- Ид позиции 
ARID_POZMO        NUMBER,            -- Арид на который добавка
RN_PODR_INITTD    NUMBER,
TD_ARID_B         NUMBER,            -- Арид техдоб БЫЛО
TD_ARID_S         NUMBER,            -- Арид техдоб СТАЛО
ATT_AUTH          NUMBER,            -- Ид документа основания
ATT_AUTHTYPE      NUMBER,            -- Тип документа основания
ATT_ALT           NUMBER,            -- GUID пользователя породившего состояние
ATT_ALTTYPE       NUMBER,            -- Тип пользователя
DIZM              DATE,              -- Дата корректировки
T_Start           DATE,              --  Дата дата начала действия
T_End             DATE,              -- Дата окончания действия 
TEHNDOB_B         NUMBER,            -- Техдоб. пользователя было
TEHNDOB_N         NUMBER,            -- Техдоб. пользователя стало
TEHNKOL_B         NUMBER,            -- Техн. кол. пользователя
TEHNKOL_S         NUMBER,            -- Техн. кол. пользователя стало
MAXPART_B         NUMBER,            -- Макс. партия было
MAXPART_S         NUMBER,            -- Макс. партия стало
MINPART_B         NUMBER,            -- Мин. партия было
MINPART_S         NUMBER,            -- Мин. партия стало
RN_PODR_ISP_B     NUMBER,            -- Ид. подразделения испытателя было
RN_PODR_ISP_S     NUMBER,            -- Ид. подразделения испытателя стало
IND_SADKA_B       CHAR(1),           -- Одной садкой было
IND_SADKA_S       CHAR(1),           -- Одной садкой стало
TEHNDOBNOTE_B     VARCHAR2(2000),    -- Примечание было
TEHNDOBNOTE_S     VARCHAR2(2000)    -- Примечания стало
)
/
----------------------------------
--  Changed type t_izms_td_tmp  --
----------------------------------
create or replace type w_mmkt.T_IZMS_TD_TMP as object
(-- v24.04.2009
RN_TV             NUMBER,            -- РН ТВ 
pornum            NUMBER,            -- Порядковый номер позиции МО
rn_pozmo          NUMBER,            -- Ид позиции 
ARID_POZMO        NUMBER,            -- Арид на который добавка
RN_PODR_INITTD    NUMBER,
ATT_AUTH          NUMBER,            -- Ид документа основания
ATT_AUTHTYPE      NUMBER,            -- Тип документа основания
ATT_ALT           NUMBER,            -- GUID пользователя породившего состояние
ATT_ALTTYPE       NUMBER,            -- Тип пользователя
DIZM              DATE,              -- Дата корректировки
T_Start           DATE,              --  Дата дата начала действия
T_End             DATE,              -- Дата окончания действия 
TEHNDOB_B         NUMBER,            -- Техдоб. пользователя было
TEHNDOB_N         NUMBER,            -- Техдоб. пользователя стало
TEHNKOL_B         NUMBER,            -- Техн. кол. пользователя
TEHNKOL_S         NUMBER,            -- Техн. кол. пользователя стало
MAXPART_B         NUMBER,            -- Макс. партия было
MAXPART_S         NUMBER,            -- Макс. партия стало
MINPART_B         NUMBER,            -- Мин. партия было
MINPART_S         NUMBER,            -- Мин. партия стало
RN_PODR_ISP_B     NUMBER,            -- Ид. подразделения испытателя было
RN_PODR_ISP_S     NUMBER,            -- Ид. подразделения испытателя стало
IND_SADKA_B       CHAR(1),           -- Одной садкой было
IND_SADKA_S       CHAR(1),           -- Одной садкой стало
TEHNDOBNOTE_B     VARCHAR2(2000),    -- Примечание было
TEHNDOBNOTE_S     VARCHAR2(2000)     -- Примечания стало

)
/
---------------------------------
--  Changed type t_izm_mo_tmp  --
---------------------------------
create or replace type w_mmkt.T_IZM_MO_tmp as object
(--Изместьев А.А. 4.09.2007
MO_TV_RN             number,                --РН ТВ объекта
MO_RN                   number,                --РН МО
MO_PORNOM         number,                 --Пор Ном МО
MO_IND_MPR         char(1),                   --Индикатор местаприменения "1" ДА
MO_ATT_ARID         number,
--MO_RN_POZMO      number,
MO_RNPODR          number,
MO_TXTPODR         varchar2(30),
MO_RNVO               number,
MO_TXTVO              varchar2(30),
MO_NOTE               varchar2(2000),
MO_TD                     varchar2(2000),        --Примечание по техдобавке
--F_GET_TEHNDOB_STRING
MO_IS_CH              Number --1 - если поменялось состояние 0  - нет
)
/
----------------------------------
--  Changed type t_izm_obr_tmp  --
----------------------------------
create or replace type w_mmkt.T_IZM_OBR_TMP as object
(--Изместьев А.А. 4.09.2007
OBR_TYP                   number, --Тип изменения (1- анулирование, 2 - введение, 3 - изменение)
OBR_RN_POZ_MOS     number, --РН  ПОЗMOS установки  
OBR_OBOZN_Z            varchar2(255), --Обозначение  Защищаемого объекта
   
OBR_RNTV_IZG                 number,  --РН ТВ совместно изготавливаетмого
OBR_RNTV_OBR          number, --РНТВ образца
OBR_OBOZN_OBR varchar2(255), --Обозначение  образца

OBR_RNPODR_ISP number, --Цех испытатель
RN_PODR_INITTD number, --Цех инициатор
OBR_TEHN_KOL              number, --Кол-во было технологическое
OBR_MAX_PART number, --МАксимальная партия
OBR_NOTE            varchar2(2000), --Примечания


OBR_MO_Z                varchar2(3), --Цех защиты текстовый + Вид обработки
OBR_MO_I                varchar2(2) --Цех инициатор защиты


)
/
----------------------------------
--  Changed type t_izm_ust_tmp  --
----------------------------------
create or replace type w_mmkt.T_IZM_UST_tmp as object
(--Изместьев А.А. 4.09.2007
UST_TYP                   number, --Тип изменения (1- анулирование, 2 - введение, 3 - изменение)
UST_RN_POZ_MO     number, --РН  ПОЗЩО установки     
UST_RNTV                 number, 
UST_KOL_B              number, --Кол-во было
UST_KOL_S              number, --Кол-во было
UST_IND1_B             char(1),
UST_IND1_S             char(1),
UST_IND2_B             char(1),
UST_IND2_S             char(1),
UST_NOTE_B             varchar2(2000),
UST_NOTE_S             varchar2(2000),
UST_RNEI_B             number,
UST_RNEI_S             number,
UST_EI_B             Varchar2(30),
UST_EI_S             Varchar2(30),
UST_MODET_B             Varchar2(50), -- Последний цех + цех установки был
UST_MODET_S             Varchar2(50),
UST_MO_B                varchar2(7), --Цех установки
UST_MO_S                varchar2(7),
UST_RNISP               number,
UST_VID_IZM             number, --0 было 1 - стало
USN_ISPOB_B             Varchar2(255),
USN_ISPOB_S             Varchar2(255),
UST_TV_NAIM            varchar2(255),
UST_TV_DOL_B            number,
UST_TV_VI               varchar2(30)



--Все стало кроме обозначения не нужны Гыыыыы
)
/
--------------------------
--  Changed type t_kor  --
--------------------------
create or replace type w_mmkt.t_kor as object
(
kornaim VARCHAR2(3)
)
/
------------------------------
--  Changed type t_kor_set  --
------------------------------
create or replace type w_mmkt.t_kor_set as TABLE OF t_kor;
/
-----------------------------------
--  Changed type t_orascps_elem  --
-----------------------------------
create or replace type w_mmkt.T_ORASCPS_ELEM as object
(
       golova NUMBER, -- что раскомплектовываем
        tv_ch NUMBER, -- Тв что
        isp_ch NUMBER, -- Исп что
        tv_k NUMBER, -- Тв -куда
        isp_k NUMBER, --Исп куда
        urov NUMBER -- на каком уровне встретилось
)
/
------------------------------
--  Changed type t_orascps  --
------------------------------
create or replace type w_mmkt.T_ORASCPS is TABLE OF T_ORASCPS_ELEM;
/
---------------------------------
--  Changed type t_rep_struc2  --
---------------------------------
create or replace type w_mmkt.T_REP_STRUC2 as object
(--Изместьев А.А. 26.06.2008
     RN_GL number, --РН_ТВ Головной сборки на которую идет раскомплектовка
     ISP_GL varchar2(255), --Обозначение Головы
     
     

--TV
     RN_TV_CH number, --РН_ТВ ЧТО
     OBOZN_CHB varchar2(255), --Обозначение ЧТО
     OBOZN_CHS varchar2(255), --Обозначение ЧТО
     NAIM_CHB varchar2(255), --Наименование техварианта ЧТО
     NAIM_CHS varchar2(255), --Наименование техварианта ЧТО
     VI_CH varchar2(30), --Вар изгот. ЧТО
     MASS_CHB number, --Масса ЧТО
     MASS_CHS number, --Масса ЧТО     
     VID_CHB varchar(255), --Вид исполнения ЧТО
     VID_CHS varchar(255), --Вид исполнения ЧТО     
     DOL_CH number, --Доля ЧТО

--Zagot     
     ZAG_OBOZNB varchar2(255), --Обозначение заготовки
     ZAG_OBOZNS varchar2(255), --Обозначение заготовки     
     ZAGI_VIDB varchar2(255), --ВИД объекта заготовки
     ZAGI_VIDS varchar2(255), --ВИД объекта заготовки     
     ZAGI_TYPB char(1), --Тип объекта заготовки
     ZAGI_TYPS char(1), --Тип объекта заготовки     
     ZAG_LB number, 
     ZAG_LS number,      
     ZAG_WB number,
     ZAG_WS number,     
     ZAG_VESB number,
     ZAG_VESS number,     
     ZAG_NRASB number,
     ZAG_NRASS number,     
     ZAG_NUMDB number,
     ZAG_NUMDS number,     
     ZAG_VIDB varchar2(100), --ВИд Заготовки
     ZAG_VIDS varchar2(100), --ВИд Заготовки     
     ZAG_EIB varchar2(30) , --Ед изм заг (Текст)
     ZAG_EIS varchar2(30) , --Ед изм заг (Текст)     
     ZAG_NOTEB Varchar(2000), --Примечание по заготовке
     ZAG_NOTES Varchar(2000), --Примечание по заготовке     
--МАршрут БЫЛО - СТАЛО отдельно!!!!!
--Применяемость ТОЖЕ ОТДЕЛЬНО Бум делать!!!
--К применяемости отнесем и Образцы и применение в качестве заготовки!!!!!


--Применяемость     
--     NUM_SB number , --Вхождение в сборку констр. ИТОГО
--     NUM_AP number, --Вхождение в сборку Техн. ИТОГО
     RN_TV_K number, --Вхождение куда
     OBOZN_K varchar2(250), --Обозначение куда
     RN_MO_K number, -- ПОЗ_МО вхождения в куда 


     IS_LEV number, --ЛЕвое вхождение - ХЗ ЧЕ ТАКОЕ

    
     TYP_MMK number, --ДЛя Дсе ЧТО тип карты ( 0 - Новая ММК,
                        -- 1 - Идущая сделана ММК, 2 - ММК, 
                        --3 - Изменяемая ММК в Другом перечене (В текущем низя)
     NUM_SBU number, --Кол-во в сборку на уровень констр.
     
     Is_OBR number, -- Если образец 1 Да 0 как деталь 2 как заготовка


OBOZN_OBIZG varchar2(255), --с каким ДСЕ изготавливается
OBR_MAXP number, --Образец максимальная партия
OBR_TK number, --Образец техн количество
CEH_ISP varchar2(3), --Цех испытатель
CEH_INIT varchar2(3), -- цех инициатор

--
POR_SORT number, --Порядок сортировки (Сборка или нет 1-й уровень)
POR_VID number --Порядок сортировки (Вид объекта -2-й уровень
-- придется подправить текст так чтоб было нормально по убыванию, 3-й уровень Обозначение ЧТО)


     
)
/
------------------------------------
--  Changed type t_rep_struc_tmp  --
------------------------------------
create or replace type w_mmkt.T_REP_STRUC_TMP as object
(--Изместьев А.А. 14.03.2007
     RN_GL number, --РН_ТВ Головной сборки на которую идет раскомплектовка
     ISP_GL varchar2(255), --Обозначение Головы
     
     RN_TV_CH number, --РН_ТВ ЧТО
     OBOZN_CH varchar2(255), --Обозначение ЧТО
     NAIM_CH varchar2(255), --Наименование техварианта ЧТО
     VI_CH varchar2(30), --Вар изгот. ЧТО
     MASS_CH number, --Масса ЧТО
     VID_CH varchar(255), --Вид исполнения ЧТО
     DOL_CH number, --Доля ЧТО
     
     ZAG_OBOZN varchar2(255), --Обозначение заготовки
     ZAGI_VID varchar2(255), --ВИД объекта заготовки
     ZAGI_TYP char(1), --Тип объекта заготовки
     ZAG_L number, 
     ZAG_W number,
     ZAG_VES number,
     ZAG_NRAS number,
     ZAG_NUMD number,
     ZAG_VID varchar2(100), --ВИд Заготовки
     ZAG_EI varchar2(30) , --Ед изм заг (Текст)
     ZAG_NOTE Varchar(2000), --Примечание по заготовке
     
     NUM_SB number , --Вхождение в сборку констр. ИТОГО
     NUM_AP number, --Вхождение в сборку Техн. ИТОГО
     RN_TV_K number, --Вхождение куда
     OBOZN_K varchar2(250), --Обозначение куда
     IS_LEV number, --Если левое вхождение а не в сборку
     RN_MO_K number, -- ПОЗ_МО вхождения в куда 
     
     TYP_MMK number, --ДЛя Дсе ЧТО тип карты ( 0 - Новая, 1 - Идущая, 2 - измененная, 3 - Идущая ММВ(ММК) , 4 - В разработке)
     NUM_SBU number, --Кол-во в сборку на уровень констр.
     
Is_OBR number, -- Если образец
OBOZN_OBIZG varchar2(255), --с каким ДСЕ изготавливается
OBR_MAXP number, --Образец максимальная партия
OBR_TK number, --Образец техн количество
CEH_ISP varchar2(3), --Цех испытатель
CEH_INIT varchar2(3), -- цех инициатор
POR_SORT number, --Порядок сортировки (Сборка или нет 1-й уровень)
POR_VID number --Порядок сортировки (Вид объекта -2-й уровень
-- придется подправить текст так чтоб было нормально по убыванию, 3-й уровень Обозначение ЧТО)


     
)
/
------------------------------------
--  Changed type t_tb_rep_izm_tv  --
------------------------------------
create or replace type w_mmkt.T_TB_REP_IZM_TV is Table of T_REP_IZM_TV
--Изместьев А.А. 4.09.07
/
-------------------------------------
--  Changed type t_tb_rep_izm_zag  --
-------------------------------------
create or replace type w_mmkt.T_TB_REP_IZM_ZAG is Table of T_REP_IZM_ZAG
--Изместьев А.А. 10.09.07
/
-----------------------------------
--  Changed type t_tb_rep_stuc2  --
-----------------------------------
create or replace type w_mmkt.t_Tb_REP_STUC2 is Table of t_rep_struc2
--Изместьев А.А. 26.05.08
/
-------------------------------
--  Changed type t_tv_info1  --
-------------------------------
CREATE OR REPLACE TYPE W_MMKT.T_TV_INFO1 IS OBJECT
-- 24.11.2007 Бельтюков Н.В.
-- 26.05.2008 Бельтюков Н.В. Добавлены столбцы KOL_ZAPUSK, KOL_VYPUSK
-- 17.10.2008 Бельтюков Н.В. Добавлены столбцы IND_OBJ, RN_PS_TV, NOMIZM_TV
-- 13.02.2009 Бельтюков Н.В. Добавлены столбцы IND_OBJ, RN_PS_TV, NOMIZM_TV
-- Тип-запись, возвращаемый функцией поиска ММК
(
     RN           NUMBER,         --RN технол. варианта используемого объекта
     OBOZN        VARCHAR2(255),  --обозначение исполь.объекта
     VI           VARCHAR2(30),   --вариант изготовления технол. варианта
     TVNAIM       VARCHAR2(255),  --наименование технол. варианта
     DOLY         NUMBER,         --доля изготовления технологического варианта
     IND_NALCOMP  CHAR(1),        --индикатор наличия компонент у объекта
     RN_ISPOB     NUMBER,         --RN исполь.объекта
     RN_MAT       NUMBER,         --RN материала Справочника материалов
     VID_ISPOB    VARCHAR2(30),   --вид использ.объекта
     TIP_ISPOB    CHAR(1),        --тип использ.объекта
     IND_OBJ      VARCHAR2(30),   --индикатор объекта (ММК/ММВ для тех. варианта или описание для используемого объекта)
     IND_NOMZA    CHAR(1),        --индикатор наличия объекта в Номзе 
     RN_PS_TV     NUMBER,         --RN текущего изменения ММК/ММВ
     NOMIZM_TV    VARCHAR2(30),   --номер текущего изменения ММК/ММВ 
     MO_STRING    VARCHAR2(500),  --МО использ.объекта
     TRUD_STRING  VARCHAR2(300),  --информация о труде исполь.объекта
     NN           VARCHAR2(25),   --номенкл. номер объекта (материала из справочника),взятого в качестве заготовки при изготовлениии объекта
     OBOZN_TZAG   VARCHAR2(255),  --обозначение используемого объекта,взятого в качестве заготовки при изготовлениии объекта
     NORMRASH     NUMBER,         --норма расхода заготовки
     GEOMR_DL     NUMBER,         --геометрические размеры заготовки
     GEOMR_SH     NUMBER,         --геометрические размеры заготовки
     KDZ          NUMBER,         --Количество деталей из заготовки
     VESZAG       NUMBER,         --Вес заготовки
     KOL          NUMBER,         --конструктор. кол-во вхождения в сборку(если она задана)
     KOL_ZAPUSK   NUMBER,         --технол.кол-во с учетом всех вышестоящих технол.добавок + собственные технол. добавки
     KOL_VYPUSK   NUMBER,         --технол.кол-во с учетом всех вышестоящих технол.добавок
     EI           VARCHAR2(30)   --единица измерения вхождения в сборку(если она задана)
)
/
-----------------------------------
--  Changed type t_tv_info_set1  --
-----------------------------------
CREATE OR REPLACE TYPE W_MMKT.T_TV_INFO_SET1 IS TABLE OF T_TV_INFO1
/
----------------------------
--  New type body kjlkjk  --
----------------------------
create or replace type body w_mmkt.kjlkjk is
  
  -- Member procedures and functions
  member procedure <ProcedureName>(<Parameter> <Datatype>) is
  begin
    <Statements>;
  end;
  
end;
/

